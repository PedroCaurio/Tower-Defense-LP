--- FILE: \conf.lua ---

function love.conf(t)
	t.title = "Archer vs Mage"
	t.window.icon = "assets/icon.png"
	t.version = "11.5"
	t.window.width = 800
	t.window.height = 600
	t.console = true


	-- t.window.minheight = 500
	-- t.window.minwidth = 500
	-- t.window.resizable = true
	-- t.window.borderless = true
	-- t.window.vsync = 1
	-- t.window.display = 2
	-- t.window.fullscreen = true
end



--- FILE: \main.lua ---

local game = require("src/main_game")


--- FILE: \lib\bump.lua ---



--- FILE: \lib\anim8\anim8.lua ---

local anim8 = {
  _VERSION     = 'anim8 v2.3.1',
  _DESCRIPTION = 'An animation library for LÖVE',
  _URL         = 'https://github.com/kikito/anim8',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique García Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local Grid = {}

local _frames = {}

local function assertPositiveInteger(value, name)
  if type(value) ~= 'number' then error(("%s should be a number, was %q"):format(name, tostring(value))) end
  if value < 1 then error(("%s should be a positive number, was %d"):format(name, value)) end
  if value ~= math.floor(value) then error(("%s should be an integer, was %f"):format(name, value)) end
end

local function createFrame(self, x, y)
  local fw, fh = self.frameWidth, self.frameHeight
  return love.graphics.newQuad(
    self.left + (x-1) * fw + x * self.border,
    self.top  + (y-1) * fh + y * self.border,
    fw,
    fh,
    self.imageWidth,
    self.imageHeight
  )
end

local function getGridKey(...)
  return table.concat( {...} ,'-' )
end

local function getOrCreateFrame(self, x, y)
  if x < 1 or x > self.width or y < 1 or y > self.height then
    error(("There is no frame for x=%d, y=%d"):format(x, y))
  end
  local key = self._key
  _frames[key]       = _frames[key]       or {}
  _frames[key][x]    = _frames[key][x]    or {}
  _frames[key][x][y] = _frames[key][x][y] or createFrame(self, x, y)
  return _frames[key][x][y]
end

local function parseInterval(str)
  if type(str) == "number" then return str,str,1 end
  str = str:gsub('%s', '') -- remove spaces
  local min, max = str:match("^(%d+)-(%d+)$")
  assert(min and max, ("Could not parse interval from %q"):format(str))
  min, max = tonumber(min), tonumber(max)
  local step = min <= max and 1 or -1
  return min, max, step
end

function Grid:getFrames(...)
  local result, args = {}, {...}
  local minx, maxx, stepx, miny, maxy, stepy

  for i=1, #args, 2 do
    minx, maxx, stepx = parseInterval(args[i])
    miny, maxy, stepy = parseInterval(args[i+1])
    for y = miny, maxy, stepy do
      for x = minx, maxx, stepx do
        result[#result+1] = getOrCreateFrame(self,x,y)
      end
    end
  end

  return result
end

local Gridmt = {
  __index = Grid,
  __call  = Grid.getFrames
}

local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)
  assertPositiveInteger(frameWidth,  "frameWidth")
  assertPositiveInteger(frameHeight, "frameHeight")
  assertPositiveInteger(imageWidth,  "imageWidth")
  assertPositiveInteger(imageHeight, "imageHeight")

  left   = left   or 0
  top    = top    or 0
  border = border or 0

  local key  = getGridKey(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)

  local grid = setmetatable(
    { frameWidth  = frameWidth,
      frameHeight = frameHeight,
      imageWidth  = imageWidth,
      imageHeight = imageHeight,
      left        = left,
      top         = top,
      border      = border,
      width       = math.floor(imageWidth/frameWidth),
      height      = math.floor(imageHeight/frameHeight),
      _key        = key
    },
    Gridmt
  )
  return grid
end

-----------------------------------------------------------

local Animation = {}

local function cloneArray(arr)
  local result = {}
  for i=1,#arr do result[i] = arr[i] end
  return result
end

local function parseDurations(durations, frameCount)
  local result = {}
  if type(durations) == 'number' then
    for i=1,frameCount do result[i] = durations end
  else
    local min, max, step
    for key,duration in pairs(durations) do
      assert(type(duration) == 'number', "The value [" .. tostring(duration) .. "] should be a number")
      min, max, step = parseInterval(key)
      for i = min,max,step do result[i] = duration end
    end
  end

  if #result < frameCount then
    error("The durations table has length of " .. tostring(#result) .. ", but it should be >= " .. tostring(frameCount))
  end

  return result
end

local function parseIntervals(durations)
  local result, time = {0},0
  for i=1,#durations do
    time = time + durations[i]
    result[i+1] = time
  end
  return result, time
end

local Animationmt = { __index = Animation }
local nop = function() end

local function newAnimation(frames, durations, onLoop)
  local td = type(durations);
  if (td ~= 'number' or durations <= 0) and td ~= 'table' then
    error("durations must be a positive number. Was " .. tostring(durations) )
  end
  onLoop = onLoop or nop
  durations = parseDurations(durations, #frames)
  local intervals, totalDuration = parseIntervals(durations)
  return setmetatable({
      frames         = cloneArray(frames),
      durations      = durations,
      intervals      = intervals,
      totalDuration  = totalDuration,
      onLoop         = onLoop,
      timer          = 0,
      position       = 1,
      status         = "playing",
      flippedH       = false,
      flippedV       = false
    },
    Animationmt
  )
end

function Animation:clone()
  local newAnim = newAnimation(self.frames, self.durations, self.onLoop)
  newAnim.flippedH, newAnim.flippedV = self.flippedH, self.flippedV
  return newAnim
end

function Animation:flipH()
  self.flippedH = not self.flippedH
  return self
end

function Animation:flipV()
  self.flippedV = not self.flippedV
  return self
end

local function seekFrameIndex(intervals, timer)
  local high, low, i = #intervals-1, 1, 1

  while(low <= high) do
    i = math.floor((low + high) / 2)
    if     timer >= intervals[i+1] then low  = i + 1
    elseif timer <  intervals[i]   then high = i - 1
    else
      return i
    end
  end

  return i
end

function Animation:update(dt)
  if self.status ~= "playing" then return end

  self.timer = self.timer + dt
  local loops = math.floor(self.timer / self.totalDuration)
  if loops ~= 0 then
    self.timer = self.timer - self.totalDuration * loops
    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]
    f(self, loops)
  end

  self.position = seekFrameIndex(self.intervals, self.timer)
end

function Animation:pause()
  self.status = "paused"
end

function Animation:gotoFrame(position)
  self.position = position
  self.timer = self.intervals[self.position]
end

function Animation:pauseAtEnd()
  self.position = #self.frames
  self.timer = self.totalDuration
  self:pause()
end

function Animation:pauseAtStart()
  self.position = 1
  self.timer = 0
  self:pause()
end

function Animation:resume()
  self.status = "playing"
end

function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)
  love.graphics.draw(image, self:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky))
end

function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)
  local frame = self.frames[self.position]
  if self.flippedH or self.flippedV then
    r,sx,sy,ox,oy,kx,ky = r or 0, sx or 1, sy or 1, ox or 0, oy or 0, kx or 0, ky or 0
    local _,_,w,h = frame:getViewport()

    if self.flippedH then
      sx = sx * -1
      ox = w - ox
      kx = kx * -1
      ky = ky * -1
    end

    if self.flippedV then
      sy = sy * -1
      oy = h - oy
      kx = kx * -1
      ky = ky * -1
    end
  end
  return frame, x, y, r, sx, sy, ox, oy, kx, ky
end

function Animation:getDimensions()
  local _,_,w,h = self.frames[self.position]:getViewport()
  return w,h
end

-----------------------------------------------------------

anim8.newGrid       = newGrid
anim8.newAnimation  = newAnimation

return anim8


--- FILE: \lib\anim8\spec\love-mocks.lua ---

-- mocks for LÖVE functions
local unpack = _G.unpack or table.unpack

local Quadmt = {
  __eq = function(a,b)
    if #a ~= #b then return false end
    for i,v in ipairs(a) do
      if b[i] ~= v then return false end
    end
    return true
  end,
  __tostring = function(self)
    local buffer = {}
    for i,v in ipairs(self) do
      buffer[i] = tostring(v)
    end
    return "quad: {" .. table.concat(buffer, ",") .. "}"
  end,
  getViewport = function(self)
    return unpack(self)
  end
}

Quadmt.__index = Quadmt

_G.love = {
  graphics = {
    newQuad = function(...)
      return setmetatable({...}, Quadmt)
    end,
    draw = function()
    end,
    getLastDrawq = function()
    end
  }
}


--- FILE: \lib\anim8\spec\anim8\animation_spec.lua ---

require 'spec.love-mocks'

local anim8        = require 'anim8'
local newAnimation = anim8.newAnimation

describe("anim8", function()
  describe("newAnimation", function()

    it("Throws an error if durations is not a positive number or a table", function()
      assert.error(function() newAnimation({}, 'foo') end)
      assert.error(function() newAnimation({}, -1)    end)
      assert.error(function() newAnimation({}, 0)     end)
    end)

    it("sets the basic stuff", function()
      local a = newAnimation({1,2,3}, 4)
      assert.equal(0,         a.timer)
      assert.equal(1,         a.position)
      assert.equal("playing", a.status)
      assert.same({1,2,3}, a.frames)
      assert.same({4,4,4}, a.durations)
      assert.same({0,4,8,12}, a.intervals)
      assert.equal(12, a.totalDuration)
    end)
    it("makes a clone of the frame table", function()
      local frames = {1,2,3}
      local a = newAnimation(frames, 4)
      assert.same(frames, a.frames)
      assert.not_equal (frames, a.frames)
    end)

    describe("when parsing the durations", function()
      it("reads a simple array", function()
        local a = newAnimation({1,2,3,4}, {5,6,7,8})
        assert.same({5,6,7,8}, a.durations)
      end)
      it("reads a hash with strings or numbers", function()
        local a = newAnimation({1,2,3,4}, {['1-3']=1, [4]=4})
        assert.same({1,1,1,4}, a.durations)
      end)
      it("reads mixed-up durations", function()
        local a = newAnimation({1,2,3,4}, {5, ['2-4']=2})
        assert.same({5,2,2,2}, a.durations)
      end)
      describe("when given erroneous imput", function()
        it("throws errors for keys that are not integers or strings", function()
          assert.error(function() newAnimation({1}, {[{}]=1}) end)
          assert.error(function() newAnimation({1}, {[print]=1}) end)
          assert.error(function() newAnimation({1}, {print}) end)
        end)
        it("throws errors when frames are missing durations", function()
          assert.error(function() newAnimation({1,2,3,4,5}, {["1-3"]=1}) end)
          assert.error(function() newAnimation({1,2,3,4,5}, {1,2,3,4}) end)
        end)
      end)
    end)
  end)

  describe("Animation", function()
    describe(":update", function()
      it("moves to the next frame #focus", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(0.5)
        assert.equal(1, a.position)
        a:update(0.5)
        assert.equal(2, a.position)
      end)
      it("moves several frames if needed", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(2.1)
        assert.equal(3, a.position)
      end)

      describe("When the last frame is spent", function()
        it("goes back to the first frame in animations", function()
          local a = newAnimation({1,2,3,4}, 1)
          a:update(4.1)
          assert.equal(1, a.position)
        end)
      end)

      describe("When there are different durations per frame", function()
        it("moves the frame correctly", function()
          local a = newAnimation({1,2,3,4}, {1,2,1,1})
          a:update(1.1)
          assert.equal(2, a.position)
          a:update(1.1)
          assert.equal(2, a.position)
          a:update(1.1)
          assert.equal(3, a.position)
        end)
      end)

      describe("When the animation loops", function()
        it("invokes the onloop callback", function()
          local looped = false;
          local a = newAnimation({1,2,3}, 1, function() looped = true end)
          assert.False(looped)
          a:update(4)
          assert.True(looped)
        end)
        it("accepts the callback as a string", function()
          local a = newAnimation({1,2,3}, 1, 'foo')
          a.foo = function(self) self.looped = true end
          assert.Nil(a.looped)
          a:update(4)
          assert.True(a.looped)

        end)
        it("counts the loops", function()
          local count = 0;
          local a = newAnimation({1,2,3}, 1, function(_, x) count = count + x end)
          a:update(4)
          assert.equals(count, 1)
          a:update(7)
          assert.equals(count, 3)
        end)
        it("counts negative loops", function()
          local count = 0;
          local a = newAnimation({1,2,3}, 1, function(_, x) count = count + x end)
          a:update(-2)
          assert.equals(count, -1)
          a:update(-6)
          assert.equals(count, -3)
        end)
      end)
    end)

    describe(":pause", function()
      it("stops animations from happening", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:pause()
        a:update(1)
        assert.equal(2, a.position)
      end)
    end)

    describe(":resume", function()
      it("reanudates paused animations", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:pause()
        a:resume()
        a:update(1)
        assert.equal(3, a.position)
      end)
    end)

    describe(":gotoFrame", function()
      it("moves the position and time to the frame specified", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:gotoFrame(1)
        assert.equal(1, a.position)
        assert.equal(0, a.timer)
      end)
    end)

    describe(":pauseAtEnd", function()
      it("goes to the last frame, and pauses", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:pauseAtEnd()
        assert.equal(4, a.position)
        assert.equal(4, a.timer)
        assert.equal('paused', a.status)
      end)
    end)

    describe(":pauseAtStart", function()
      it("goes to the first frame, and pauses", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:pauseAtStart()
        assert.equal(1, a.position)
        assert.equal(0, a.timer)
        assert.equal('paused', a.status)
      end)
    end)

    describe(":draw", function()
      it("invokes love.graphics.draw with the expected parameters", function()
        spy.on(love.graphics, 'draw')
        local img, frame1, frame2, frame3 = {},{},{},{}
        local a   = newAnimation({frame1, frame2, frame3}, 1)
        a:draw(img, 1,2,3,4,5,6,7,8,9)
        assert.spy(love.graphics.draw).was.called_with(img, frame1, 1,2,3,4,5,6,7,8,9)
      end)
    end)

    describe(":clone", function()
      it("returns a new animation with the same properties - but reset to the initial frame", function()
        local frames = {1,2,3,4}
        local a = newAnimation(frames, 1)
        a:update(1)
        a:pause()
        local b = a:clone()
        assert.not_equal(frames, b.frames)
        assert.same(frames, b.frames)
        assert.same(a.durations, b.durations)
        assert.equal(0, b.timer)
        assert.equal(1, b.position)
        assert.equal("playing", b.status )

        assert.False(b.flippedH)
        assert.False(b.flippedV)

        a:flipV()
        assert.True(a:clone().flippedV)

        a:flipH()
        assert.True(a:clone().flippedH)

      end)
    end)

    describe(":getDimensions", function()
      it("returns the width and height of the current frame", function()
        local frame1 = love.graphics.newQuad(0,0,10,10)
        local frame2 = love.graphics.newQuad(0,0,20,30)
        local frame3 = love.graphics.newQuad(0,0,5,15)

        local a = newAnimation({frame1, frame2, frame3}, 1)

        assert.same({10,10}, {a:getDimensions()})
        a:update(1.1)
        assert.same({20,30}, {a:getDimensions()})
        a:update(1)
        assert.same({5,15}, {a:getDimensions()})
        a:update(1)
        assert.same({10,10}, {a:getDimensions()})
      end)
    end)

    describe(":flipH and :flipV", function()
      local img, frame, a
      before_each(function()
        spy.on(love.graphics, 'draw')
        img = {}
        frame = love.graphics.newQuad(1,2,3,4) -- x,y,width, height
        a     = newAnimation({frame}, 1)
      end)
      it("defaults to non-flipped", function()
        assert.False(a.flippedH)
        assert.False(a.flippedV)
      end)

      it("Flips the animation horizontally (does not create a clone)", function()
        a:flipH()
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, -5,6,3-7,8,-9,-10)

        assert.equal(a, a:flipH())
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,6,7,8,9,10)
      end)

      it("Flips the animation vertically (does not create a clone)", function()
        a:flipV()
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,-6,7,4-8,-9,-10)

        assert.equal(a, a:flipV())
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,6,7,8,9,10)
      end)
    end)
  end)
end)


--- FILE: \lib\anim8\spec\anim8\grid_spec.lua ---

require 'spec.love-mocks'

local anim8 = require 'anim8'

local newQuad   = love.graphics.newQuad
local newGrid   = anim8.newGrid

describe("anim8", function()

  describe("newGrid", function()
    it("throws error if any of its parameters is not a positive integer", function()
      assert.error(function() newGrid() end)
      assert.error(function() newGrid(1) end)
      assert.error(function() newGrid(1,1,1,-1) end)
      assert.error(function() newGrid(0,1,1,1) end)
      assert.error(function() newGrid(1,1,'a',1) end)
    end)

    it("preserves the values", function()
      local g = newGrid(1,2,3,4,5,6,7)
      assert.equal(1, g.frameWidth)
      assert.equal(2, g.frameHeight)
      assert.equal(3, g.imageWidth)
      assert.equal(4, g.imageHeight)
      assert.equal(5, g.left)
      assert.equal(6, g.top)
      assert.equal(7, g.border)
    end)

    it("calculates width and height", function()
      local g = newGrid(32,32,64,256)
      assert.equal(2, g.width)
      assert.equal(8, g.height)
    end)

    it("presets border and offsets to 0", function()
      local g = newGrid(32,32,64,256)
      assert.equal(0, g.left)
      assert.equal(0, g.top)
      assert.equal(0, g.border)
    end)
  end)

  describe("Grid", function()
    describe("getFrames", function()
      local g, nq
      before_each(function()
        g = newGrid(16,16,64,64)
        nq = function(x,y) return newQuad(x,y, 16,16, 64,64) end
      end)

      describe("with 2 integers", function()
        it("returns a single frame", function()
          assert.equal(nq(0,0), g:getFrames(1,1)[1])
        end)
        it("returns another single frame", function()
          assert.equal(nq(32,16), g:getFrames(3,2)[1])
        end)
        it("throws an error if the frame does not exist", function()
          assert.error(function() g:getFrames(10,10) end)
        end)
      end)

      describe("with several pairs of integers", function()
        it("returns a list of frames", function()
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(0,32), nq(16,16), nq(32,0)}, frames)
        end)
        it("takes into account border widths", function()
          g = newGrid(16,16,64,64,0,0,1)
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(1,35), nq(18,18), nq(35,1)}, frames)
        end)
        it("takes into account left and top", function()
          g = newGrid(16,16,64,64,10,20)
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(10,52), nq(26,36), nq(42,20)}, frames)
        end)
      end)

      describe("with a string and a integer", function()
        it("returns a list of frames", function()
          local frames = g:getFrames('1-2', 2)
          assert.equal(nq(0,16) , frames[1])
          assert.equal(nq(16,16), frames[2])
        end)
        it("throws an error for invalid strings", function()
          assert.error(function() g:getFrames('foo', 1) end)
          assert.error(function() g:getFrames('foo-bar', 1) end)
          assert.error(function() g:getFrames('1-foo', 1) end)
        end)
        it("throws an error for valid strings representing too big indexes", function()
          assert.error(function() g:getFrames('1000-1') end)
        end)
      end)

      describe("with several strings", function()
        it("returns a list of frames", function()
          local frames = g:getFrames('1-2',2, 3,2)
          assert.same({nq(0,16), nq(16,16), nq(32,16)}, frames)
        end)
        it("parses rows first, then columns", function()
          local frames = g:getFrames('1-3','1-3')
          assert.same({ nq(0,0),  nq(16,0),  nq(32,0),
                        nq(0,16), nq(16,16), nq(32,16),
                        nq(0,32), nq(16,32), nq(32,32)
                      },
                      frames)
        end)
        it("counts backwards if the first number in the string is greater than the second one", function()
          local frames = g:getFrames('3-1',2)
          assert.same({nq(32,16), nq(16,16), nq(0,16)}, frames)
        end)
      end)


      describe("with a non-number or string", function()
        it("throws an error", function()
          assert.error(function() g:getFrames({1,10}) end)
        end)
      end)

      describe("When two similar grids are requested for the same quad", function()
        it("is not created twice", function()
          local g2 = newGrid(16,16,64,64)
          local q1 = setmetatable(g:getFrames(1,1)[1], nil)
          local q2 = setmetatable(g2:getFrames(1,1)[1], nil)
          assert.equal(q1, q2)
        end)
      end)

    end)

    describe("()", function()
      it("is a shortcut to :getFrames", function()
        local g = newGrid(16,16,64,64)
        assert.equal(g:getFrames(1,1)[1], g(1,1)[1])
      end)
    end)
  end)
end)


--- FILE: \lib\bump.lua\bump.lua ---

local bump = {
  _VERSION     = 'bump v3.1.7',
  _URL         = 'https://github.com/kikito/bump.lua',
  _DESCRIPTION = 'A collision detection library for Lua',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2014 Enrique García Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

------------------------------------------
-- Auxiliary functions
------------------------------------------
local DELTA = 1e-10 -- floating-point margin of error

local abs, floor, ceil, min, max = math.abs, math.floor, math.ceil, math.min, math.max

local function sign(x)
  if x > 0 then return 1 end
  if x == 0 then return 0 end
  return -1
end

local function nearest(x, a, b)
  if abs(a - x) < abs(b - x) then return a else return b end
end

local function assertType(desiredType, value, name)
  if type(value) ~= desiredType then
    error(name .. ' must be a ' .. desiredType .. ', but was ' .. tostring(value) .. '(a ' .. type(value) .. ')')
  end
end

local function assertIsPositiveNumber(value, name)
  if type(value) ~= 'number' or value <= 0 then
    error(name .. ' must be a positive integer, but was ' .. tostring(value) .. '(' .. type(value) .. ')')
  end
end

local function assertIsRect(x,y,w,h)
  assertType('number', x, 'x')
  assertType('number', y, 'y')
  assertIsPositiveNumber(w, 'w')
  assertIsPositiveNumber(h, 'h')
end

local defaultFilter = function()
  return 'slide'
end

------------------------------------------
-- Rectangle functions
------------------------------------------

local function rect_getNearestCorner(x,y,w,h, px, py)
  return nearest(px, x, x+w), nearest(py, y, y+h)
end

-- This is a generalized implementation of the liang-barsky algorithm, which also returns
-- the normals of the sides where the segment intersects.
-- Returns nil if the segment never touches the rect
-- Notice that normals are only guaranteed to be accurate when initially ti1, ti2 == -math.huge, math.huge
local function rect_getSegmentIntersectionIndices(x,y,w,h, x1,y1,x2,y2, ti1,ti2)
  ti1, ti2 = ti1 or 0, ti2 or 1
  local dx, dy = x2-x1, y2-y1
  local nx, ny
  local nx1, ny1, nx2, ny2 = 0,0,0,0
  local p, q, r

  for side = 1,4 do
    if     side == 1 then nx,ny,p,q = -1,  0, -dx, x1 - x     -- left
    elseif side == 2 then nx,ny,p,q =  1,  0,  dx, x + w - x1 -- right
    elseif side == 3 then nx,ny,p,q =  0, -1, -dy, y1 - y     -- top
    else                  nx,ny,p,q =  0,  1,  dy, y + h - y1 -- bottom
    end

    if p == 0 then
      if q <= 0 then return nil end
    else
      r = q / p
      if p < 0 then
        if     r > ti2 then return nil
        elseif r > ti1 then ti1,nx1,ny1 = r,nx,ny
        end
      else -- p > 0
        if     r < ti1 then return nil
        elseif r < ti2 then ti2,nx2,ny2 = r,nx,ny
        end
      end
    end
  end

  return ti1,ti2, nx1,ny1, nx2,ny2
end

-- Calculates the minkowsky difference between 2 rects, which is another rect
local function rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)
  return x2 - x1 - w1,
         y2 - y1 - h1,
         w1 + w2,
         h1 + h2
end

local function rect_containsPoint(x,y,w,h, px,py)
  return px - x > DELTA      and py - y > DELTA and
         x + w - px > DELTA  and y + h - py > DELTA
end

local function rect_isIntersecting(x1,y1,w1,h1, x2,y2,w2,h2)
  return x1 < x2+w2 and x2 < x1+w1 and
         y1 < y2+h2 and y2 < y1+h1
end

local function rect_getSquareDistance(x1,y1,w1,h1, x2,y2,w2,h2)
  local dx = x1 - x2 + (w1 - w2)/2
  local dy = y1 - y2 + (h1 - h2)/2
  return dx*dx + dy*dy
end

local function rect_detectCollision(x1,y1,w1,h1, x2,y2,w2,h2, goalX, goalY)
  goalX = goalX or x1
  goalY = goalY or y1

  local dx, dy      = goalX - x1, goalY - y1
  local x,y,w,h     = rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)

  local overlaps, ti, nx, ny

  if rect_containsPoint(x,y,w,h, 0,0) then -- item was intersecting other
    local px, py    = rect_getNearestCorner(x,y,w,h, 0, 0)
    local wi, hi    = min(w1, abs(px)), min(h1, abs(py)) -- area of intersection
    ti              = -wi * hi -- ti is the negative area of intersection
    overlaps = true
  else
    local ti1,ti2,nx1,ny1 = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, math.huge)

    -- item tunnels into other
    if ti1
    and ti1 < 1
    and (abs(ti1 - ti2) >= DELTA) -- special case for rect going through another rect's corner
    and (0 < ti1 + DELTA
      or 0 == ti1 and ti2 > 0)
    then
      ti, nx, ny = ti1, nx1, ny1
      overlaps   = false
    end
  end

  if not ti then return end

  local tx, ty

  if overlaps then
    if dx == 0 and dy == 0 then
      -- intersecting and not moving - use minimum displacement vector
      local px, py = rect_getNearestCorner(x,y,w,h, 0,0)
      if abs(px) < abs(py) then py = 0 else px = 0 end
      nx, ny = sign(px), sign(py)
      tx, ty = x1 + px, y1 + py
    else
      -- intersecting and moving - move in the opposite direction
      local ti1, _
      ti1,_,nx,ny = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, 1)
      if not ti1 then return end
      tx, ty = x1 + dx * ti1, y1 + dy * ti1
    end
  else -- tunnel
    tx, ty = x1 + dx * ti, y1 + dy * ti
  end

  return {
    overlaps  = overlaps,
    ti        = ti,
    move      = {x = dx, y = dy},
    normal    = {x = nx, y = ny},
    touch     = {x = tx, y = ty},
    itemRect  = {x = x1, y = y1, w = w1, h = h1},
    otherRect = {x = x2, y = y2, w = w2, h = h2}
  }
end

------------------------------------------
-- Grid functions
------------------------------------------

local function grid_toWorld(cellSize, cx, cy)
  return (cx - 1)*cellSize, (cy-1)*cellSize
end

local function grid_toCell(cellSize, x, y)
  return floor(x / cellSize) + 1, floor(y / cellSize) + 1
end

-- grid_traverse* functions are based on "A Fast Voxel Traversal Algorithm for Ray Tracing",
-- by John Amanides and Andrew Woo - http://www.cse.yorku.ca/~amana/research/grid.pdf
-- It has been modified to include both cells when the ray "touches a grid corner",
-- and with a different exit condition

local function grid_traverse_initStep(cellSize, ct, t1, t2)
  local v = t2 - t1
  if     v > 0 then
    return  1,  cellSize / v, ((ct + v) * cellSize - t1) / v
  elseif v < 0 then
    return -1, -cellSize / v, ((ct + v - 1) * cellSize - t1) / v
  else
    return 0, math.huge, math.huge
  end
end

local function grid_traverse(cellSize, x1,y1,x2,y2, f)
  local cx1,cy1        = grid_toCell(cellSize, x1,y1)
  local cx2,cy2        = grid_toCell(cellSize, x2,y2)
  local stepX, dx, tx  = grid_traverse_initStep(cellSize, cx1, x1, x2)
  local stepY, dy, ty  = grid_traverse_initStep(cellSize, cy1, y1, y2)
  local cx,cy          = cx1,cy1

  f(cx, cy)

  -- The default implementation had an infinite loop problem when
  -- approaching the last cell in some occassions. We finish iterating
  -- when we are *next* to the last cell
  while abs(cx - cx2) + abs(cy - cy2) > 1 do
    if tx < ty then
      tx, cx = tx + dx, cx + stepX
      f(cx, cy)
    else
      -- Addition: include both cells when going through corners
      if tx == ty then f(cx + stepX, cy) end
      ty, cy = ty + dy, cy + stepY
      f(cx, cy)
    end
  end

  -- If we have not arrived to the last cell, use it
  if cx ~= cx2 or cy ~= cy2 then f(cx2, cy2) end

end

local function grid_toCellRect(cellSize, x,y,w,h)
  local cx,cy = grid_toCell(cellSize, x, y)
  local cr,cb = ceil((x+w) / cellSize), ceil((y+h) / cellSize)
  return cx, cy, cr - cx + 1, cb - cy + 1
end

------------------------------------------
-- Responses
------------------------------------------

local touch = function(world, col, x,y,w,h, goalX, goalY, filter)
  return col.touch.x, col.touch.y, {}, 0
end

local cross = function(world, col, x,y,w,h, goalX, goalY, filter)
  local cols, len = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local slide = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move  = col.touch, col.move
  if move.x ~= 0 or move.y ~= 0 then
    if col.normal.x ~= 0 then
      goalX = tch.x
    else
      goalY = tch.y
    end
  end

  col.slide = {x = goalX, y = goalY}

  x,y = tch.x, tch.y
  local cols, len  = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local bounce = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move = col.touch, col.move
  local tx, ty = tch.x, tch.y

  local bx, by = tx, ty

  if move.x ~= 0 or move.y ~= 0 then
    local bnx, bny = goalX - tx, goalY - ty
    if col.normal.x == 0 then bny = -bny else bnx = -bnx end
    bx, by = tx + bnx, ty + bny
  end

  col.bounce   = {x = bx,  y = by}
  x,y          = tch.x, tch.y
  goalX, goalY = bx, by

  local cols, len    = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

------------------------------------------
-- World
------------------------------------------

local World = {}
local World_mt = {__index = World}

-- Private functions and methods

local function sortByWeight(a,b) return a.weight < b.weight end

local function sortByTiAndDistance(a,b)
  if a.ti == b.ti then
    local ir, ar, br = a.itemRect, a.otherRect, b.otherRect
    local ad = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, ar.x,ar.y,ar.w,ar.h)
    local bd = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, br.x,br.y,br.w,br.h)
    return ad < bd
  end
  return a.ti < b.ti
end

local function addItemToCell(self, item, cx, cy)
  self.rows[cy] = self.rows[cy] or setmetatable({}, {__mode = 'v'})
  local row = self.rows[cy]
  row[cx] = row[cx] or {itemCount = 0, x = cx, y = cy, items = setmetatable({}, {__mode = 'k'})}
  local cell = row[cx]
  self.nonEmptyCells[cell] = true
  if not cell.items[item] then
    cell.items[item] = true
    cell.itemCount = cell.itemCount + 1
  end
end

local function removeItemFromCell(self, item, cx, cy)
  local row = self.rows[cy]
  if not row or not row[cx] or not row[cx].items[item] then return false end

  local cell = row[cx]
  cell.items[item] = nil
  cell.itemCount = cell.itemCount - 1
  if cell.itemCount == 0 then
    self.nonEmptyCells[cell] = nil
  end
  return true
end

local function getDictItemsInCellRect(self, cl,ct,cw,ch)
  local items_dict = {}
  for cy=ct,ct+ch-1 do
    local row = self.rows[cy]
    if row then
      for cx=cl,cl+cw-1 do
        local cell = row[cx]
        if cell and cell.itemCount > 0 then -- no cell.itemCount > 1 because tunneling
          for item,_ in pairs(cell.items) do
            items_dict[item] = true
          end
        end
      end
    end
  end

  return items_dict
end

local function getCellsTouchedBySegment(self, x1,y1,x2,y2)

  local cells, cellsLen, visited = {}, 0, {}

  grid_traverse(self.cellSize, x1,y1,x2,y2, function(cx, cy)
    local row  = self.rows[cy]
    if not row then return end
    local cell = row[cx]
    if not cell or visited[cell] then return end

    visited[cell] = true
    cellsLen = cellsLen + 1
    cells[cellsLen] = cell
  end)

  return cells, cellsLen
end

local function getInfoAboutItemsTouchedBySegment(self, x1,y1, x2,y2, filter)
  local cells, len = getCellsTouchedBySegment(self, x1,y1,x2,y2)
  local cell, rect, l,t,w,h, ti1,ti2, tii0,tii1
  local visited, itemInfo, itemInfoLen = {},{},0
  for i=1,len do
    cell = cells[i]
    for item in pairs(cell.items) do
      if not visited[item] then
        visited[item]  = true
        if (not filter or filter(item)) then
          rect           = self.rects[item]
          l,t,w,h        = rect.x,rect.y,rect.w,rect.h

          ti1,ti2 = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, 0, 1)
          if ti1 and ((0 < ti1 and ti1 < 1) or (0 < ti2 and ti2 < 1)) then
            -- the sorting is according to the t of an infinite line, not the segment
            tii0,tii1    = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, -math.huge, math.huge)
            itemInfoLen  = itemInfoLen + 1
            itemInfo[itemInfoLen] = {item = item, ti1 = ti1, ti2 = ti2, weight = min(tii0,tii1)}
          end
        end
      end
    end
  end
  table.sort(itemInfo, sortByWeight)
  return itemInfo, itemInfoLen
end

local function getResponseByName(self, name)
  local response = self.responses[name]
  if not response then
    error(('Unknown collision type: %s (%s)'):format(name, type(name)))
  end
  return response
end


-- Misc Public Methods

function World:addResponse(name, response)
  self.responses[name] = response
end

function World:project(item, x,y,w,h, goalX, goalY, filter)
  assertIsRect(x,y,w,h)

  goalX = goalX or x
  goalY = goalY or y
  filter  = filter  or defaultFilter

  local collisions, len = {}, 0

  local visited = {}
  if item ~= nil then visited[item] = true end

  -- This could probably be done with less cells using a polygon raster over the cells instead of a
  -- bounding rect of the whole movement. Conditional to building a queryPolygon method
  local tl, tt = min(goalX, x),       min(goalY, y)
  local tr, tb = max(goalX + w, x+w), max(goalY + h, y+h)
  local tw, th = tr-tl, tb-tt

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, tl,tt,tw,th)

  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  for other,_ in pairs(dictItemsInCellRect) do
    if not visited[other] then
      visited[other] = true

      local responseName = filter(item, other)
      if responseName then
        local ox,oy,ow,oh   = self:getRect(other)
        local col           = rect_detectCollision(x,y,w,h, ox,oy,ow,oh, goalX, goalY)

        if col then
          col.other    = other
          col.item     = item
          col.type     = responseName

          len = len + 1
          collisions[len] = col
        end
      end
    end
  end

  table.sort(collisions, sortByTiAndDistance)

  return collisions, len
end

function World:countCells()
  local count = 0
  for _,row in pairs(self.rows) do
    for _,_ in pairs(row) do
      count = count + 1
    end
  end
  return count
end

function World:hasItem(item)
  return not not self.rects[item]
end

function World:getItems()
  local items, len = {}, 0
  for item,_ in pairs(self.rects) do
    len = len + 1
    items[len] = item
  end
  return items, len
end

function World:countItems()
  local len = 0
  for _ in pairs(self.rects) do len = len + 1 end
  return len
end

function World:getRect(item)
  local rect = self.rects[item]
  if not rect then
    error('Item ' .. tostring(item) .. ' must be added to the world before getting its rect. Use world:add(item, x,y,w,h) to add it first.')
  end
  return rect.x, rect.y, rect.w, rect.h
end

function World:toWorld(cx, cy)
  return grid_toWorld(self.cellSize, cx, cy)
end

function World:toCell(x,y)
  return grid_toCell(self.cellSize, x, y)
end


--- Query methods

function World:queryRect(x,y,w,h, filter)

  assertIsRect(x,y,w,h)

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_isIntersecting(x,y,w,h, rect.x, rect.y, rect.w, rect.h)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:queryPoint(x,y, filter)
  local cx,cy = self:toCell(x,y)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cx,cy,1,1)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_containsPoint(rect.x, rect.y, rect.w, rect.h, x, y)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:querySegment(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local items = {}
  for i=1, len do
    items[i] = itemInfo[i].item
  end
  return items, len
end

function World:querySegmentWithCoords(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local dx, dy        = x2-x1, y2-y1
  local info, ti1, ti2
  for i=1, len do
    info  = itemInfo[i]
    ti1   = info.ti1
    ti2   = info.ti2

    info.weight  = nil
    info.x1      = x1 + dx * ti1
    info.y1      = y1 + dy * ti1
    info.x2      = x1 + dx * ti2
    info.y2      = y1 + dy * ti2
  end
  return itemInfo, len
end


--- Main methods

function World:add(item, x,y,w,h)
  local rect = self.rects[item]
  if rect then
    error('Item ' .. tostring(item) .. ' added to the world twice.')
  end
  assertIsRect(x,y,w,h)

  self.rects[item] = {x=x,y=y,w=w,h=h}

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      addItemToCell(self, item, cx, cy)
    end
  end

  return item
end

function World:remove(item)
  local x,y,w,h = self:getRect(item)

  self.rects[item] = nil
  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      removeItemFromCell(self, item, cx, cy)
    end
  end
end

function World:update(item, x2,y2,w2,h2)
  local x1,y1,w1,h1 = self:getRect(item)
  w2,h2 = w2 or w1, h2 or h1
  assertIsRect(x2,y2,w2,h2)

  if x1 ~= x2 or y1 ~= y2 or w1 ~= w2 or h1 ~= h2 then

    local cellSize = self.cellSize
    local cl1,ct1,cw1,ch1 = grid_toCellRect(cellSize, x1,y1,w1,h1)
    local cl2,ct2,cw2,ch2 = grid_toCellRect(cellSize, x2,y2,w2,h2)

    if cl1 ~= cl2 or ct1 ~= ct2 or cw1 ~= cw2 or ch1 ~= ch2 then

      local cr1, cb1 = cl1+cw1-1, ct1+ch1-1
      local cr2, cb2 = cl2+cw2-1, ct2+ch2-1
      local cyOut

      for cy = ct1, cb1 do
        cyOut = cy < ct2 or cy > cb2
        for cx = cl1, cr1 do
          if cyOut or cx < cl2 or cx > cr2 then
            removeItemFromCell(self, item, cx, cy)
          end
        end
      end

      for cy = ct2, cb2 do
        cyOut = cy < ct1 or cy > cb1
        for cx = cl2, cr2 do
          if cyOut or cx < cl1 or cx > cr1 then
            addItemToCell(self, item, cx, cy)
          end
        end
      end

    end

    local rect = self.rects[item]
    rect.x, rect.y, rect.w, rect.h = x2,y2,w2,h2

  end
end

function World:move(item, goalX, goalY, filter)
  local actualX, actualY, cols, len = self:check(item, goalX, goalY, filter)

  self:update(item, actualX, actualY)

  return actualX, actualY, cols, len
end

function World:check(item, goalX, goalY, filter)
  filter = filter or defaultFilter

  local visited = {[item] = true}
  local visitedFilter = function(itm, other)
    if visited[other] then return false end
    return filter(itm, other)
  end

  local cols, len = {}, 0

  local x,y,w,h = self:getRect(item)

  local projected_cols, projected_len = self:project(item, x,y,w,h, goalX,goalY, visitedFilter)

  while projected_len > 0 do
    local col = projected_cols[1]
    len       = len + 1
    cols[len] = col

    visited[col.other] = true

    local response = getResponseByName(self, col.type)

    goalX, goalY, projected_cols, projected_len = response(
      self,
      col,
      x, y, w, h,
      goalX, goalY,
      visitedFilter
    )
  end

  return goalX, goalY, cols, len
end


-- Public library functions

bump.newWorld = function(cellSize)
  cellSize = cellSize or 64
  assertIsPositiveNumber(cellSize, 'cellSize')
  local world = setmetatable({
    cellSize       = cellSize,
    rects          = {},
    rows           = {},
    nonEmptyCells  = {},
    responses = {}
  }, World_mt)

  world:addResponse('touch', touch)
  world:addResponse('cross', cross)
  world:addResponse('slide', slide)
  world:addResponse('bounce', bounce)

  return world
end

bump.rect = {
  getNearestCorner              = rect_getNearestCorner,
  getSegmentIntersectionIndices = rect_getSegmentIntersectionIndices,
  getDiff                       = rect_getDiff,
  containsPoint                 = rect_containsPoint,
  isIntersecting                = rect_isIntersecting,
  getSquareDistance             = rect_getSquareDistance,
  detectCollision               = rect_detectCollision
}

bump.responses = {
  touch  = touch,
  cross  = cross,
  slide  = slide,
  bounce = bounce
}

return bump


--- FILE: \lib\bump.lua\spec\bump_spec.lua ---

local bump = require 'bump'

describe('bump', function()

  describe('newWorld', function()
    it('creates a world', function()
      assert.truthy(bump.newWorld())
    end)

    it('defaults the cellSize to 64', function()
      assert.equal(bump.newWorld().cellSize, 64)
    end)

    it('can set the cellSize', function()
      assert.equal(bump.newWorld(32).cellSize, 32)
    end)

    it('throws an error if cellsize is not a positive number', function()
      assert.error(function() bump.newWorld(-10) end)
      assert.error(function() bump.newWorld("") end)
    end)
  end)

end)


--- FILE: \lib\bump.lua\spec\rect_spec.lua ---

local rect = require('bump').rect

describe('bump.rect', function()

  describe('detectCollision', function()
    local detect = rect.detectCollision
    describe('when item is static', function()

      describe('when itemRect does not intersect otherRect', function()
        it('returns nil', function()
          local c = detect(0,0,1,1, 5,5,1,1, 0,0)
          assert.is_nil(c)
        end)
      end)

      describe('when itemRect overlaps otherRect', function()
        it('returns overlaps, normal, move, ti, diff, itemRect, otherRect', function()
          local c = detect(0,0,7,6, 5,5,1,1, 0, 0)

          assert.is_true(c.overlaps)
          assert.equals(c.ti, -2)
          assert.same(c.move, {x = 0, y = 0})
          assert.same(c.itemRect, {x=0,y=0,w=7,h=6})
          assert.same(c.otherRect, {x=5,y=5,w=1,h=1})
          assert.same(c.normal, {x=0, y=-1})

        end)
      end)

    end)

    describe('when item is moving', function()
      describe('when itemRect does not intersect otherRect', function()
        it('returns nil', function()
          local c = detect(0,0,1,1, 5,5,1,1, 0,1)
          assert.is_nil(c)
        end)
      end)
      describe('when itemRect intersects otherRect', function()
        it('detects collisions from the left', function()
          local c = detect(1,1,1,1, 5,0,1,1, 6,0)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=-1, y=0})
        end)
        it('detects collisions from the right', function()
          local c = detect(6,0,1,1, 1,0,1,1, 1,1)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.8)
          assert.same(c.normal, {x=1, y=0})
        end)
        it('detects collisions from the top', function()
          local c = detect(0,0,1,1, 0,4,1,1, 0,5)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=0, y=-1})
        end)
        it('detects collisions from the bottom', function()
          local c = detect(0,4,1,1, 0,0,1,1, 0,-1)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=0, y=1})
        end)
      end)
      it('does not get caught by nasty corner cases', function()
        assert.is_nil(detect( 0,16,16,16, 16,0,16,16, -1,15))
      end)
    end)
  end)
end)



--- FILE: \lib\bump.lua\spec\responses_spec.lua ---

local bump            = require('bump')
local detect          = bump.rect.detectCollision
local responses  = bump.responses

local world = bump.newWorld()

local touch = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y}
end

local slide = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  responses.slide(world, col, x, y, w, h, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y, col.slide.x, col.slide.y}
end

local bounce = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  responses.bounce(world, col, x, y, w, h, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y, col.bounce.x, col.bounce.y }
end

describe('bump.responses', function()
  describe('touch', function()
    describe('when resolving collisions', function()
      describe('on overlaps', function()
        describe('when there is no movement', function()
          it('returns the left,top coordinates of the minimum displacement on static items', function()

            --                                          -2-1 0 1 2 3 4 5 6 7 8 9 10
            --      -2 -1 0 1 2 3 4 5 6 7 8 9           -2 · ┌–––┐ · ┌–––┐ · ┌–––┐ ·
            --      -1  ┌–––┐ · ┌–––┐ · ┌–––┐           -1 · │0-1│ · │0-1│ · │0-1│ ·
            --       0  │ ┌–––––––––––––––┐ │ 1  2  3    0 · └–┌–––––––––––––––┐–┘ ·
            --       1  └–│–┘ · └–––┘ · └–│–┘            1 · · │ · · · · · · · │ · ·
            --       2  · │ · · · · · · · │ ·            2 · · │ · · · · · · · │ · ·
            --       3  ┌–│–┐ · ┌–––┐ · ┌–│–┐            3 ┌–––│ · · · · · · · │–––┐
            --       4  │ │ │ · │ · │ · │ │ │ 4  5  6    4 -1 0│ · · · · · · · │1 0│
            --       5  └–│–┘ · └–––┘ · └–│–┘            5 └–––│ · · · · · · · │–––┘
            --       6  · │ · · · · · · · │ ·            6 · · │ · · · · · · · │ · ·
            --       7  ┌–│–┐ · ┌–––┐ · ┌–│–┐            7 · · │ · · · · · · · │ · ·
            --       8  │ └–––––––––––––––┘ │ 7  8  9    8 · ┌–└–––––––––––––––┘–┐ ·
            --       9  └–––┘ · └–––┘ · └–––┘            9 · │0 1│ · ╎0 1╎ · │0 1│ ·
            --      10                                  10 · └–––┘ · └╌╌╌┘ · └–––┘ ·

            assert.same(touch(-1,-1,2,2, 0,0,8,8), {-1,-2, 0, -1}) -- 1
            assert.same(touch( 3,-1,2,2, 0,0,8,8), { 3,-2, 0, -1}) -- 2
            assert.same(touch( 7,-1,2,2, 0,0,8,8), { 7,-2, 0, -1}) -- 3

            assert.same(touch(-1, 3,2,2, 0,0,8,8), {-2, 3, -1, 0}) -- 4
            assert.same(touch( 3, 3,2,2, 0,0,8,8), { 3, 8,  0, 1}) -- 5
            assert.same(touch( 7, 3,2,2, 0,0,8,8), { 8, 3,  1, 0}) -- 6

            assert.same(touch(-1, 7,2,2, 0,0,8,8), {-1, 8,  0, 1}) -- 7
            assert.same(touch( 3, 7,2,2, 0,0,8,8), { 3, 8,  0, 1}) -- 8
            assert.same(touch( 7, 7,2,2, 0,0,8,8), { 7, 8,  0, 1}) -- 9

          end)
        end)

        describe('when the item is moving', function()
          it('returns the left,top coordinates of the overlaps with the movement line, opposite direction', function()
            assert.same(touch(3,3,2,2, 0,0,8,8, 4, 3), { -2,  3, -1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 2, 3), {  8,  3,  1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 2, 3), {  8,  3,  1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 3, 4), {  3, -2,  0, -1})
            assert.same(touch(3,3,2,2, 0,0,8,8, 3, 2), {  3,  8,  0,  1})
          end)
        end)
      end)

      describe('on tunnels', function()
        it('returns the coordinates of the item when it starts touching the other, and the normal', function()
          assert.same(touch(-3, 3,2,2, 0,0,8,8, 3,3), { -2,  3, -1,  0})
          assert.same(touch( 9, 3,2,2, 0,0,8,8, 3,3), {  8,  3,  1,  0})
          assert.same(touch( 3,-3,2,2, 0,0,8,8, 3,3), {  3, -2,  0, -1})
          assert.same(touch( 3, 9,2,2, 0,0,8,8, 3,3), {  3,  8,  0,  1})
        end)
      end)
    end)
  end)

  describe('slide', function()
    it('slides on overlaps', function()
      assert.same(slide(3,3,2,2, 0,0,8,8, 4, 5), { 0.5, -2, 0,-1, 4, -2})
      assert.same(slide(3,3,2,2, 0,0,8,8, 5, 4), { -2, 0.5, -1,0, -2, 4})
      assert.same(slide(3,3,2,2, 0,0,8,8, 2, 1), { 5.5, 8, 0,1, 2, 8})
      assert.same(slide(3,3,2,2, 0,0,8,8, 1, 2), { 8, 5.5, 1,0, 8, 2})
    end)

    it('slides over tunnels', function()
      assert.same(slide(10,10,2,2, 0,0,8,8, 1, 4), { 7, 8, 0, 1, 1, 8})
      assert.same(slide(10,10,2,2, 0,0,8,8, 4, 1), { 8, 7, 1, 0, 8, 1})

      -- perfect corner case:
      assert.same(slide(10,10,2,2, 0,0,8,8, 1, 1), { 8, 8, 1, 0, 8, 1})
    end)
  end)

  describe('bounce', function()
    it('bounces on overlaps', function()
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 4, 5), { 0.5, -2, 0,-1, 4, -9})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 5, 4), { -2, 0.5, -1,0, -9, 4})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 2, 1), { 5.5, 8, 0,1, 2, 15})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 1, 2), { 8, 5.5, 1,0, 15,2})
    end)

    it('bounces over tunnels', function()
      assert.same(bounce(10,10,2,2, 0,0,8,8, 1, 4), { 7, 8, 0, 1, 1, 12})
      assert.same(bounce(10,10,2,2, 0,0,8,8, 4, 1), { 8, 7, 1, 0, 12, 1})

      -- perfect corner case:
      assert.same(bounce(10,10,2,2, 0,0,8,8, 1, 1), { 8, 8, 1, 0, 15, 1})
    end)
  end)
end)


--- FILE: \lib\bump.lua\spec\World_spec.lua ---

local bump = require 'bump'

describe('World', function()
  local world

  before_each(function()
    world = bump.newWorld()
  end)

  local collect = function(t, field_name)
    local res = {}
    for i,v in ipairs(t) do res[i] = v[field_name] end
    return res
  end

  local sorted = function(array)
    table.sort(array)
    return array
  end

  describe(':add', function()
    it('requires something + 4 numbers', function()
      assert.error(function() world:add({}) end)
      assert.error(function() world:add({}, 40) end)
      assert.error(function() world:add() end)
    end)

    it('returns the added item', function()
      local item = {}
      assert.equals(item, world:add(item, 1,1,1,1))
    end)

    it('throws an error if the object was already added', function()
      local obj = world:add({}, 0,0,10,10)
      assert.error(function() world:add(obj, 0,0,10,10) end)
    end)

    describe('when the world is empty', function()
      it('creates as many cells as needed to hold the item', function()
        world:add({}, 0,0,10,10) -- adss one cell
        assert.equal(world:countCells(), 1)

        world:add({}, 100,100,10,10) -- adds a separate single cell
        assert.equal(world:countCells(), 2)

        world:add({}, 0,0,100,10) -- occupies 2 cells, but just adds one (the other is already added)
        assert.equal(world:countCells(), 3)

        world:add({}, 0,0,100,10) -- occupies 2 cells, but just adds one (the other is already added)
        assert.equal(world:countCells(), 3)

        world:add({}, 300,300,64,64) -- adds 8 new cells
        assert.equal(world:countCells(), 7)
      end)
    end)
  end)

  describe(':update', function()

    describe('when the object is not there', function()
      it('throws an error', function()
        assert.is_error(function() world:update({}, 0,0) end)
      end)
    end)

    it('updates the object', function()
      local a = world:add({}, 0,0,10,10)
      world:update(a, 40,40, 20,20)
      assert.same({world:getRect(a)}, {40,40,20,20})
    end)

    describe('when no width or height is given', function()
      it('takes width and height from its previous value', function()
        local a = world:add({}, 0,0,10,10)
        world:update(a, 5,5)
        assert.same({5,5,10,10}, {world:getRect(a)})
      end)
    end)

    describe('when the object stays in the same group of cells', function()
      it('does not invoke remove and add', function()
        local a = world:add({}, 0,0,10,10)

        spy.on(world, 'remove')
        spy.on(world, 'add')

        world:update(a, 1,1, 11,11)

        assert.spy(world.remove).was.called(0)
        assert.spy(world.add).was.called(0)
      end)
    end)
  end)

  describe(':project', function()
    it('throws an error if when not given a rect', function()
      assert.error(function() world:project() end)
    end)

    describe('when the world is empty', function()
      it('returns an empty list of collisions', function()
        assert.same(world:project({}, 1,2,3,4), {})
      end)
    end)

    describe('when the world is not empty', function()
      it('returns a list of collisions', function()
        world:add({'a'}, 0,0,10,10)
        world:add({'c'}, 14,16,10,10)
        assert.same(#world:project({}, 4,6,10,10), 1)
      end)

      describe('when next futureX & Y are passed', function()
        it('still handles intersections as before', function()
          world:add({'a'}, 0,0, 2,2)
          assert.same(#world:project({}, 1,1,2,2, 1, 1), 1)
        end)

        it('detects and tags tunneling correctly', function()
          world:add({'a'},  1,0, 2,1)
          assert.same(#world:project({}, -5,0,4,1, 5,0), 1)
        end)

        it('detects the case where an object was touching another without intersecting, and then penetrates', function()
          world:add({'b'}, 0,0,32,100)
          assert.same(#world:project({}, 32,50,20,20, 30,50), 1)
        end)

        it('returns a list of collisions sorted by ti', function()
          world:add({'b'}, 70,0, 10,10)
          world:add({'c'}, 50,0, 10,10)
          world:add({'d'}, 90,0, 10,10)

          local col = world:project({}, 110,0,10,10, 10,0)

          assert.same(collect(col, 'ti'), {0.1, 0.3, 0.5})
        end)
      end) -- when FutureX & Y are passed

      describe('the filter param', function()
        it('deactivates collisions when filter returns false', function()
          world:add({'b'}, 70,0, 10,10)
          world:add({'c'}, 50,0, 10,10)
          local d = world:add({'d'}, 90,0, 10,10)

          local cols = world:project({}, 110,0, 10,10, 10, 0, function(item, obj)
            return obj ~= d and "touch"
          end)

          assert.same(#cols, 2)
        end)
      end)
    end) -- when the world is not empty
  end) -- :project

  describe(':remove', function()
    it('throws an error if the item does not exist', function()
      assert.error(function() world:remove({}) end)
    end)
    it('makes the item disappear from the world', function()
      local a = world:add({'a'}, 0,0, 10,10)
      assert.same(#world:project({}, 5,0,1,1), 1)
      world:remove(a)
      assert.same(#world:project({}, 5,0,1,1), 0)
    end)
    it('marks empty cells & rows for deallocation', function()
      world:add({'a'}, 0,0, 10, 10)
      local b = world:add({'b'}, 200,200, 10,10)
      assert.same(world:countCells(), 2)
      world:remove(b)
      assert.same(world:countCells(), 2)
      collectgarbage('collect')
      assert.same(world:countCells(), 1)
    end)
  end)

  describe(':toCell', function()
    it('returns the coordinates of the cell containing a point', function()
      assert.same({world:toCell(0,0)}, {1,1})
      assert.same({world:toCell(63.9,63.9)}, {1,1})
      assert.same({world:toCell(64,64)}, {2,2})
      assert.same({world:toCell(-1,-1)}, {0,0})
    end)
  end)

  describe(':toWorld', function()
    it('returns the world left,top corner of the given cell', function()
      assert.same({world:toWorld(1,1)}, {0,0})
      assert.same({world:toWorld(2,2)}, {64,64})
      assert.same({world:toWorld(-1,1)}, {-128,0})
    end)
  end)

  describe(':queryRect', function()
    it('throws an error when given an invalid rect', function()
      assert.error(function() world:queryRect(0,0,-1,-1) end)
    end)
    it('returns nothing when the world is empty', function()
      assert.same(world:queryRect(0,0,1,1), {})
    end)
    describe('when the world has items', function()
      local a, b, c, d
      before_each(function()
        a = world:add('a', 10,0, 10,10)
        b = world:add('b', 70,0, 10,10)
        c = world:add('c', 50,0, 10,10)
        d = world:add('d', 90,0, 10,10)
      end)

      it('returns the items inside/partially inside the given rect', function()
        assert.same(sorted(world:queryRect(55, 5, 20, 20)), {b,c})
        assert.same(sorted(world:queryRect(0, 5, 100, 20)), {a,b,c,d})
      end)

      it('only returns the items for which filter returns true', function()
        local filter = function(other) return other == a or other == b or other == d end
        assert.same(sorted(world:queryRect(55, 5, 20, 20, filter)), {b})
        assert.same(sorted(world:queryRect(0, 5, 100, 20, filter)), {a,b,d})
      end)
    end)
  end)

  describe(':queryPoint', function()
    it('returns nothing when the world is empty', function()
      assert.same(world:queryPoint(0,0), {})
    end)
    describe('when the world has items', function()
      local a, b, c
      before_each(function()
        a = world:add('a', 10,0, 10,10)
        b = world:add('b', 15,0, 10,10)
        c = world:add('c', 20,0, 10,10)
      end)

      it('returns the items inside/partially inside the given rect', function()
        assert.same(sorted(world:queryPoint( 4,5)), {})
        assert.same(sorted(world:queryPoint(14,5)), {a})
        assert.same(sorted(world:queryPoint(16,5)), {a,b})
        assert.same(sorted(world:queryPoint(21,5)), {b,c})
        assert.same(sorted(world:queryPoint(26,5)), {c})
        assert.same(sorted(world:queryPoint(31,5)), {})
      end)

      it('the items are ignored when filter is present and returns false for them', function()
        local filter = function(other) return other ~= b end
        assert.same(sorted(world:queryPoint( 4,5, filter)), {})
        assert.same(sorted(world:queryPoint(14,5, filter)), {a})
        assert.same(sorted(world:queryPoint(16,5, filter)), {a})
        assert.same(sorted(world:queryPoint(21,5, filter)), {c})
        assert.same(sorted(world:queryPoint(26,5, filter)), {c})
        assert.same(sorted(world:queryPoint(31,5, filter)), {})
      end)
    end)
  end)

  describe(':querySegment', function()
    it('returns nothing when the world is empty', function()
      assert.same(world:querySegment(0,0,1,1), {})
    end)

    it('does not touch borders', function()
      world:add({'a'}, 10,0, 5,5)
      world:add({'c'}, 20,0, 5,5)

      assert.same(world:querySegment(0,5,  10,0),  {})
      assert.same(world:querySegment(15,5, 20,0),  {})
      assert.same(world:querySegment(26,5, 25,0),  {})
    end)

    describe("when the world has items", function()
      local a, b, c
      before_each(function()
        a = world:add('a',  5,0, 5,10)
        b = world:add('b', 15,0, 5,10)
        c = world:add('c', 25,0, 5,10)
      end)

      it('returns the items touched by the segment, sorted by touch order', function()
        assert.same(world:querySegment(0,5, 11,5),  {a})
        assert.same(world:querySegment(0,5, 17,5),  {a,b})
        assert.same(world:querySegment(0,5, 30,5),  {a,b,c})
        assert.same(world:querySegment(17,5, 26,5), {b,c})
        assert.same(world:querySegment(22,5, 26,5), {c})

        assert.same(world:querySegment(11,5, 0,5),  {a})
        assert.same(world:querySegment(17,5, 0,5),  {b,a})
        assert.same(world:querySegment(30,5, 0,5),  {c,b,a})
        assert.same(world:querySegment(26,5, 17,5), {c,b})
        assert.same(world:querySegment(26,5, 22,5), {c})
      end)

      it('filters out items when filter does not return true for them', function()
        local filter = function(other) return other ~= a and other ~= c end

        assert.same(world:querySegment(0,5, 11,5, filter),  {})
        assert.same(world:querySegment(0,5, 17,5, filter),  {b})
        assert.same(world:querySegment(0,5, 30,5, filter),  {b})
        assert.same(world:querySegment(17,5, 26,5, filter), {b})
        assert.same(world:querySegment(22,5, 26,5, filter), {})

        assert.same(world:querySegment(11,5, 0,5, filter),  {})
        assert.same(world:querySegment(17,5, 0,5, filter),  {b})
        assert.same(world:querySegment(30,5, 0,5, filter),  {b})
        assert.same(world:querySegment(26,5, 17,5, filter), {b})
        assert.same(world:querySegment(26,5, 22,5, filter), {})
      end)
    end)
  end)

  describe(":hasItem", function()
    it('returns wether the world has an item', function()
      local item = {}

      assert.is_false(world:hasItem(item))
      world:add(item, 0,0,1,1)
      assert.is_true(world:hasItem(item))
    end)
    it('does not throw errors with non-tables or nil', function()

      assert.is_false(world:hasItem(false))
      assert.is_false(world:hasItem(1))
      assert.is_false(world:hasItem("hello"))
      assert.is_false(world:hasItem())
    end)
  end)

  describe(":getItems", function()
    it('returns all the items in the world', function()
      local a,b = 'a','b'
      world:add(a, 1,1,1,1)
      world:add(b, 2,2,2,2)
      local items, len = world:getItems()
      table.sort(items)
      assert.same({'a', 'b'}, items)
      assert.equals(2, len)
    end)
  end)

  describe(":countItems", function()
    it('counts the items in the world', function()
      world:add({}, 1,1,1,1)
      world:add({}, 2,2,2,2)
      local count = world:countItems()
      assert.equals(2, count)
    end)
  end)

  describe(":move", function()
    describe('when there are no collisions', function()
      it('it moves the object, and returns zero collisions', function()
        local item = world:add({}, 0,0,1,1)
        assert.same({1,1,{},0}, {world:move(item, 1,1)})
      end)
    end)

    describe('when touching', function()
      it('returns a collision with the first item it touches', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,1)
        world:add('c', 0,3,1,1)
        local x,y,cols,len = world:move(a, 0,5, function() return 'touch' end)
        assert.same({x,y}, {0,1})
        assert.equals(1, len)
        assert.same(collect(cols, 'other'), {'b'})
        assert.same(collect(cols, 'type'),  {'touch'})
        assert.same({0,1,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when crossing', function()
      it('returns a collision with every item it crosses', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,1)
        world:add('c', 0,3,1,1)
        local x,y,cols,len = world:move(a, 0,5, function() return 'cross' end)
        assert.same({x,y}, {0,5})
        assert.equals(2, len)
        assert.same(collect(cols, 'other'), {'b', 'c'})
        assert.same(collect(cols, 'type'),  {'cross', 'cross'})
        assert.same({0,5,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when sliding', function()
      it('slides with every element', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,2)
        world:add('c', 2,1,1,1)
        local x,y,cols,len = world:move(a, 5,5, function() return 'slide' end)
        assert.same({x,y}, {1,5})
        assert.equals(1, len)
        assert.same(collect(cols, 'other'), {'c'})
        assert.same(collect(cols, 'type'),  {'slide'})
        assert.same({1,5,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when bouncing', function()
      it('bounces on each element',function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,2)
        local x,y,cols,len = world:move(a, 0,5, function() return 'bounce' end)
        assert.same({x,y}, {0,-3})
        assert.equal(1, len)
        assert.same(collect(cols, 'other'), {'b'})
        assert.same(collect(cols, 'type'),  {'bounce'})
        assert.same({0,-3,1,1}, {world:getRect(a)})
      end)
    end)
  end)
end)


--- FILE: \lib\hump\camera.lua ---

--[[
Copyright (c) 2010-2015 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local _PATH = (...):match('^(.*[%./])[^%.%/]+$') or ''
local cos, sin = math.cos, math.sin

local camera = {}
camera.__index = camera

-- Movement interpolators (for camera locking/windowing)
camera.smooth = {}

function camera.smooth.none()
	return function(dx,dy) return dx,dy end
end

function camera.smooth.linear(speed)
	assert(type(speed) == "number", "Invalid parameter: speed = "..tostring(speed))
	return function(dx,dy, s)
		-- normalize direction
		local d = math.sqrt(dx*dx+dy*dy)
		local dts = math.min((s or speed) * love.timer.getDelta(), d) -- prevent overshooting the goal
		if d > 0 then
			dx,dy = dx/d, dy/d
		end

		return dx*dts, dy*dts
	end
end

function camera.smooth.damped(stiffness)
	assert(type(stiffness) == "number", "Invalid parameter: stiffness = "..tostring(stiffness))
	return function(dx,dy, s)
		local dts = love.timer.getDelta() * (s or stiffness)
		return dx*dts, dy*dts
	end
end


local function new(x,y, zoom, rot, smoother)
	x,y  = x or love.graphics.getWidth()/2, y or love.graphics.getHeight()/2
	zoom = zoom or 1
	rot  = rot or 0
	smoother = smoother or camera.smooth.none() -- for locking, see below
	return setmetatable({x = x, y = y, scale = zoom, rot = rot, smoother = smoother}, camera)
end

function camera:lookAt(x,y)
	self.x, self.y = x, y
	return self
end

function camera:move(dx,dy)
	self.x, self.y = self.x + dx, self.y + dy
	return self
end

function camera:position()
	return self.x, self.y
end

function camera:rotate(phi)
	self.rot = self.rot + phi
	return self
end

function camera:rotateTo(phi)
	self.rot = phi
	return self
end

function camera:zoom(mul)
	self.scale = self.scale * mul
	return self
end

function camera:zoomTo(zoom)
	self.scale = zoom
	return self
end

function camera:attach(x,y,w,h, noclip)
	x,y = x or 0, y or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	self._sx,self._sy,self._sw,self._sh = love.graphics.getScissor()
	if not noclip then
		love.graphics.setScissor(x,y,w,h)
	end

	local cx,cy = x+w/2, y+h/2
	love.graphics.push()
	love.graphics.translate(cx, cy)
	love.graphics.scale(self.scale)
	love.graphics.rotate(self.rot)
	love.graphics.translate(-self.x, -self.y)
end

function camera:detach()
	love.graphics.pop()
	love.graphics.setScissor(self._sx,self._sy,self._sw,self._sh)
end

function camera:draw(...)
	local x,y,w,h,noclip,func
	local nargs = select("#", ...)
	if nargs == 1 then
		func = ...
	elseif nargs == 5 then
		x,y,w,h,func = ...
	elseif nargs == 6 then
		x,y,w,h,noclip,func = ...
	else
		error("Invalid arguments to camera:draw()")
	end

	self:attach(x,y,w,h,noclip)
	func()
	self:detach()
end

-- world coordinates to camera coordinates
function camera:cameraCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = ((x,y) - (self.x, self.y)):rotated(self.rot) * self.scale + center
	local c,s = cos(self.rot), sin(self.rot)
	x,y = x - self.x, y - self.y
	x,y = c*x - s*y, s*x + c*y
	return x*self.scale + w/2 + ox, y*self.scale + h/2 + oy
end

-- camera coordinates to world coordinates
function camera:worldCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = (((x,y) - center) / self.scale):rotated(-self.rot) + (self.x,self.y)
	local c,s = cos(-self.rot), sin(-self.rot)
	x,y = (x - w/2 - ox) / self.scale, (y - h/2 - oy) / self.scale
	x,y = c*x - s*y, s*x + c*y
	return x+self.x, y+self.y
end

function camera:mousePosition(ox,oy,w,h)
	local mx,my = love.mouse.getPosition()
	return self:worldCoords(mx,my, ox,oy,w,h)
end

-- camera scrolling utilities
function camera:lockX(x, smoother, ...)
	local dx, dy = (smoother or self.smoother)(x - self.x, self.y, ...)
	self.x = self.x + dx
	return self
end

function camera:lockY(y, smoother, ...)
	local dx, dy = (smoother or self.smoother)(self.x, y - self.y, ...)
	self.y = self.y + dy
	return self
end

function camera:lockPosition(x,y, smoother, ...)
	return self:move((smoother or self.smoother)(x - self.x, y - self.y, ...))
end

function camera:lockWindow(x, y, x_min, x_max, y_min, y_max, smoother, ...)
	-- figure out displacement in camera coordinates
	x,y = self:cameraCoords(x,y)
	local dx, dy = 0,0
	if x < x_min then
		dx = x - x_min
	elseif x > x_max then
		dx = x - x_max
	end
	if y < y_min then
		dy = y - y_min
	elseif y > y_max then
		dy = y - y_max
	end

	-- transform displacement to movement in world coordinates
	local c,s = cos(-self.rot), sin(-self.rot)
	dx,dy = (c*dx - s*dy) / self.scale, (s*dx + c*dy) / self.scale

	-- move
	self:move((smoother or self.smoother)(dx,dy,...))
end

-- the module
return setmetatable({new = new, smooth = camera.smooth},
	{__call = function(_, ...) return new(...) end})


--- FILE: \lib\hump\class.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function include_helper(to, from, seen)
	if from == nil then
		return to
	elseif type(from) ~= 'table' then
		return from
	elseif seen[from] then
		return seen[from]
	end

	seen[from] = to
	for k,v in pairs(from) do
		k = include_helper({}, k, seen) -- keys might also be tables
		if to[k] == nil then
			to[k] = include_helper({}, v, seen)
		end
	end
	return to
end

-- deeply copies `other' into `class'. keys in `other' that are already
-- defined in `class' are omitted
local function include(class, other)
	return include_helper(class, other, {})
end

-- returns a deep copy of `other'
local function clone(other)
	return setmetatable(include({}, other), getmetatable(other))
end

local function new(class)
	-- mixins
	class = class or {}  -- class can be nil
	local inc = class.__includes or {}
	if getmetatable(inc) then inc = {inc} end

	for _, other in ipairs(inc) do
		if type(other) == "string" then
			other = _G[other]
		end
		include(class, other)
	end

	-- class implementation
	class.__index = class
	class.init    = class.init    or class[1] or function() end
	class.include = class.include or include
	class.clone   = class.clone   or clone

	-- constructor call
	return setmetatable(class, {__call = function(c, ...)
		local o = setmetatable({}, c)
		o:init(...)
		return o
	end})
end

-- interface for cross class-system compatibility (see https://github.com/bartbes/Class-Commons).
if class_commons ~= false and not common then
	common = {}
	function common.class(name, prototype, parent)
		return new{__includes = {prototype, parent}}
	end
	function common.instance(class, ...)
		return class(...)
	end
end


-- the module
return setmetatable({new = new, include = include, clone = clone},
	{__call = function(_,...) return new(...) end})


--- FILE: \lib\hump\gamestate.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function __NULL__() end

 -- default gamestate produces error on every callback
local state_init = setmetatable({leave = __NULL__},
		{__index = function() error("Gamestate not initialized. Use Gamestate.switch()") end})
local stack = {state_init}
local initialized_states = setmetatable({}, {__mode = "k"})
local state_is_dirty = true

local GS = {}
function GS.new(t) return t or {} end -- constructor - deprecated!

local function change_state(stack_offset, to, ...)
	local pre = stack[#stack]

	-- initialize only on first call
	;(initialized_states[to] or to.init or __NULL__)(to)
	initialized_states[to] = __NULL__

	stack[#stack+stack_offset] = to
	state_is_dirty = true
	return (to.enter or __NULL__)(to, pre, ...)
end

function GS.switch(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call switch with colon operator")
	;(stack[#stack].leave or __NULL__)(stack[#stack])
	return change_state(0, to, ...)
end

function GS.push(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call push with colon operator")
	return change_state(1, to, ...)
end

function GS.pop(...)
	assert(#stack > 1, "No more states to pop!")
	local pre, to = stack[#stack], stack[#stack-1]
	stack[#stack] = nil
	;(pre.leave or __NULL__)(pre)
	state_is_dirty = true
	return (to.resume or __NULL__)(to, pre, ...)
end

function GS.current()
	return stack[#stack]
end

-- XXX: don't overwrite love.errorhandler by default:
--      this callback is different than the other callbacks
--      (see http://love2d.org/wiki/love.errorhandler)
--      overwriting thi callback can result in random crashes (issue #95)
local all_callbacks = { 'draw', 'update' }

-- fetch event callbacks from love.handlers
for k in pairs(love.handlers) do
	all_callbacks[#all_callbacks+1] = k
end

function GS.registerEvents(callbacks)
	local registry = {}
	callbacks = callbacks or all_callbacks
	for _, f in ipairs(callbacks) do
		registry[f] = love[f] or __NULL__
		love[f] = function(...)
			registry[f](...)
			return GS[f](...)
		end
	end
end

-- forward any undefined functions
setmetatable(GS, {__index = function(_, func)
	-- call function only if at least one 'update' was called beforehand
	-- (see issue #46)
	if not state_is_dirty or func == 'update' then
		state_is_dirty = false
		return function(...)
			return (stack[#stack][func] or __NULL__)(stack[#stack], ...)
		end
	end
	return __NULL__
end})

return GS


--- FILE: \lib\hump\signal.lua ---

--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Registry = {}
Registry.__index = function(self, key)
	return Registry[key] or (function()
		local t = {}
		rawset(self, key, t)
		return t
	end)()
end

function Registry:register(s, f)
	self[s][f] = f
	return f
end

function Registry:emit(s, ...)
	for f in pairs(self[s]) do
		f(...)
	end
end

function Registry:remove(s, ...)
	local f = {...}
	for i = 1,select('#', ...) do
		self[s][f[i]] = nil
	end
end

function Registry:clear(...)
	local s = {...}
	for i = 1,select('#', ...) do
		self[s[i]] = {}
	end
end

function Registry:emitPattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:emit(s, ...) end
	end
end

function Registry:registerPattern(p, f)
	for s in pairs(self) do
		if s:match(p) then self:register(s, f) end
	end
	return f
end

function Registry:removePattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:remove(s, ...) end
	end
end

function Registry:clearPattern(p)
	for s in pairs(self) do
		if s:match(p) then self[s] = {} end
	end
end

-- instancing
function Registry.new()
	return setmetatable({}, Registry)
end

-- default instance
local default = Registry.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Registry) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end

return setmetatable(module, {__call = Registry.new})


--- FILE: \lib\hump\timer.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Timer = {}
Timer.__index = Timer

local function _nothing_() end

local function updateTimerHandle(handle, dt)
		-- handle: {
		--   time = <number>,
		--   after = <function>,
		--   during = <function>,
		--   limit = <number>,
		--   count = <number>,
		-- }
		handle.time = handle.time + dt
		handle.during(dt, math.max(handle.limit - handle.time, 0))

		while handle.time >= handle.limit and handle.count > 0 do
			if handle.after(handle.after) == false then
				handle.count = 0
				break
			end
			handle.time = handle.time - handle.limit
			handle.count = handle.count - 1
		end
end

function Timer:update(dt)
	-- timers may create new timers, which leads to undefined behavior
	-- in pairs() - so we need to put them in a different table first
	local to_update = {}
	for handle in pairs(self.functions) do
		to_update[handle] = handle
	end

	for handle in pairs(to_update) do
		if self.functions[handle] then
			updateTimerHandle(handle, dt)
			if handle.count == 0 then
				self.functions[handle] = nil
			end
		end
	end
end

function Timer:during(delay, during, after)
	local handle = { time = 0, during = during, after = after or _nothing_, limit = delay, count = 1 }
	self.functions[handle] = true
	return handle
end

function Timer:after(delay, func)
	return self:during(delay, _nothing_, func)
end

function Timer:every(delay, after, count)
	local count = count or math.huge -- exploit below: math.huge - 1 = math.huge
	local handle = { time = 0, during = _nothing_, after = after, limit = delay, count = count }
	self.functions[handle] = true
	return handle
end

function Timer:cancel(handle)
	self.functions[handle] = nil
end

function Timer:clear()
	self.functions = {}
end

function Timer:script(f)
	local co = coroutine.wrap(f)
	co(function(t)
		self:after(t, co)
		coroutine.yield()
	end)
end

Timer.tween = setmetatable({
	-- helper functions
	out = function(f) -- 'rotates' a function
		return function(s, ...) return 1 - f(1-s, ...) end
	end,
	chain = function(f1, f2) -- concatenates two functions
		return function(s, ...) return (s < .5 and f1(2*s, ...) or 1 + f2(2*s-1, ...)) * .5 end
	end,

	-- useful tweening functions
	linear = function(s) return s end,
	quad   = function(s) return s*s end,
	cubic  = function(s) return s*s*s end,
	quart  = function(s) return s*s*s*s end,
	quint  = function(s) return s*s*s*s*s end,
	sine   = function(s) return 1-math.cos(s*math.pi/2) end,
	expo   = function(s) return 2^(10*(s-1)) end,
	circ   = function(s) return 1 - math.sqrt(1-s*s) end,

	back = function(s,bounciness)
		bounciness = bounciness or 1.70158
		return s*s*((bounciness+1)*s - bounciness)
	end,

	bounce = function(s) -- magic numbers ahead
		local a,b = 7.5625, 1/2.75
		return math.min(a*s^2, a*(s-1.5*b)^2 + .75, a*(s-2.25*b)^2 + .9375, a*(s-2.625*b)^2 + .984375)
	end,

	elastic = function(s, amp, period)
		amp, period = amp and math.max(1, amp) or 1, period or .3
		return (-amp * math.sin(2*math.pi/period * (s-1) - math.asin(1/amp))) * 2^(10*(s-1))
	end,
}, {

-- register new tween
__call = function(tween, self, len, subject, target, method, after, ...)
	-- recursively collects fields that are defined in both subject and target into a flat list
	local function tween_collect_payload(subject, target, out)
		for k,v in pairs(target) do
			local ref = subject[k]
			assert(type(v) == type(ref), 'Type mismatch in field "'..k..'".')
			if type(v) == 'table' then
				tween_collect_payload(ref, v, out)
			else
				local ok, delta = pcall(function() return (v-ref)*1 end)
				assert(ok, 'Field "'..k..'" does not support arithmetic operations')
				out[#out+1] = {subject, k, delta}
			end
		end
		return out
	end

	method = tween[method or 'linear'] -- see __index
	local payload, t, args = tween_collect_payload(subject, target, {}), 0, {...}

	local last_s = 0
	return self:during(len, function(dt)
		t = t + dt
		local s = method(math.min(1, t/len), unpack(args))
		local ds = s - last_s
		last_s = s
		for _, info in ipairs(payload) do
			local ref, key, delta = unpack(info)
			ref[key] = ref[key] + delta * ds
		end
	end, after)
end,

-- fetches function and generated compositions for method `key`
__index = function(tweens, key)
	if type(key) == 'function' then return key end

	assert(type(key) == 'string', 'Method must be function or string.')
	if rawget(tweens, key) then return rawget(tweens, key) end

	local function construct(pattern, f)
		local method = rawget(tweens, key:match(pattern))
		if method then return f(method) end
		return nil
	end

	local out, chain = rawget(tweens,'out'), rawget(tweens,'chain')
	return construct('^in%-([^-]+)$', function(...) return ... end)
	       or construct('^out%-([^-]+)$', out)
	       or construct('^in%-out%-([^-]+)$', function(f) return chain(f, out(f)) end)
	       or construct('^out%-in%-([^-]+)$', function(f) return chain(out(f), f) end)
	       or error('Unknown interpolation method: ' .. key)
end})

-- Timer instancing
function Timer.new()
	return setmetatable({functions = {}, tween = Timer.tween}, Timer)
end

-- default instance
local default = Timer.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Timer) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end
module.tween = setmetatable({}, {
	__index = Timer.tween,
	__newindex = function(k,v) Timer.tween[k] = v end,
	__call = function(t, ...) return default:tween(...) end,
})

return setmetatable(module, {__call = Timer.new})


--- FILE: \lib\hump\vector-light.lua ---

--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local function str(x,y)
	return "("..tonumber(x)..","..tonumber(y)..")"
end

local function mul(s, x,y)
	return s*x, s*y
end

local function div(s, x,y)
	return x/s, y/s
end

local function add(x1,y1, x2,y2)
	return x1+x2, y1+y2
end

local function sub(x1,y1, x2,y2)
	return x1-x2, y1-y2
end

local function permul(x1,y1, x2,y2)
	return x1*x2, y1*y2
end

local function dot(x1,y1, x2,y2)
	return x1*x2 + y1*y2
end

local function det(x1,y1, x2,y2)
	return x1*y2 - y1*x2
end

local function eq(x1,y1, x2,y2)
	return x1 == x2 and y1 == y2
end

local function lt(x1,y1, x2,y2)
	return x1 < x2 or (x1 == x2 and y1 < y2)
end

local function le(x1,y1, x2,y2)
	return x1 <= x2 and y1 <= y2
end

local function len2(x,y)
	return x*x + y*y
end

local function len(x,y)
	return sqrt(x*x + y*y)
end

local function fromPolar(angle, radius)
	radius = radius or 1
	return cos(angle)*radius, sin(angle)*radius
end

local function randomDirection(len_min, len_max)
	len_min = len_min or 1
	len_max = len_max or len_min

	assert(len_max > 0, "len_max must be greater than zero")
	assert(len_max >= len_min, "len_max must be greater than or equal to len_min")

	return fromPolar(math.random()*2*math.pi,
	                 math.random() * (len_max-len_min) + len_min)
end

local function toPolar(x, y)
	return atan2(y,x), len(x,y)
end

local function dist2(x1,y1, x2,y2)
	return len2(x1-x2, y1-y2)
end

local function dist(x1,y1, x2,y2)
	return len(x1-x2, y1-y2)
end

local function normalize(x,y)
	local l = len(x,y)
	if l > 0 then
		return x/l, y/l
	end
	return x,y
end

local function rotate(phi, x,y)
	local c, s = cos(phi), sin(phi)
	return c*x - s*y, s*x + c*y
end

local function perpendicular(x,y)
	return -y, x
end

local function project(x,y, u,v)
	local s = (x*u + y*v) / (u*u + v*v)
	return s*u, s*v
end

local function mirror(x,y, u,v)
	local s = 2 * (x*u + y*v) / (u*u + v*v)
	return s*u - x, s*v - y
end

-- ref.: http://blog.signalsondisplay.com/?p=336
local function trim(maxLen, x, y)
	local s = maxLen * maxLen / len2(x, y)
	s = s > 1 and 1 or math.sqrt(s)
	return x * s, y * s
end

local function angleTo(x,y, u,v)
	if u and v then
		return atan2(y, x) - atan2(v, u)
	end
	return atan2(y, x)
end

-- the module
return {
	str = str,

	fromPolar       = fromPolar,
	toPolar         = toPolar,
	randomDirection = randomDirection,

	-- arithmetic
	mul    = mul,
	div    = div,
	idiv   = idiv,
	add    = add,
	sub    = sub,
	permul = permul,
	dot    = dot,
	det    = det,
	cross  = det,

	-- relation
	eq = eq,
	lt = lt,
	le = le,

	-- misc operations
	len2          = len2,
	len           = len,
	dist2         = dist2,
	dist          = dist,
	normalize     = normalize,
	rotate        = rotate,
	perpendicular = perpendicular,
	project       = project,
	mirror        = mirror,
	trim          = trim,
	angleTo       = angleTo,
}


--- FILE: \lib\hump\vector.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local assert = assert
local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local vector = {}
vector.__index = vector

local function new(x,y)
	return setmetatable({x = x or 0, y = y or 0}, vector)
end
local zero = new(0,0)

local function fromPolar(angle, radius)
	radius = radius or 1
	return new(cos(angle) * radius, sin(angle) * radius)
end

local function randomDirection(len_min, len_max)
	len_min = len_min or 1
	len_max = len_max or len_min

	assert(len_max > 0, "len_max must be greater than zero")
	assert(len_max >= len_min, "len_max must be greater than or equal to len_min")
	
	return fromPolar(math.random() * 2*math.pi,
	                 math.random() * (len_max-len_min) + len_min)
end

local function isvector(v)
	return type(v) == 'table' and type(v.x) == 'number' and type(v.y) == 'number'
end

function vector:clone()
	return new(self.x, self.y)
end

function vector:unpack()
	return self.x, self.y
end

function vector:__tostring()
	return "("..tonumber(self.x)..","..tonumber(self.y)..")"
end

function vector.__unm(a)
	return new(-a.x, -a.y)
end

function vector.__add(a,b)
	assert(isvector(a) and isvector(b), "Add: wrong argument types (<vector> expected)")
	return new(a.x+b.x, a.y+b.y)
end

function vector.__sub(a,b)
	assert(isvector(a) and isvector(b), "Sub: wrong argument types (<vector> expected)")
	return new(a.x-b.x, a.y-b.y)
end

function vector.__mul(a,b)
	if type(a) == "number" then
		return new(a*b.x, a*b.y)
	elseif type(b) == "number" then
		return new(b*a.x, b*a.y)
	else
		assert(isvector(a) and isvector(b), "Mul: wrong argument types (<vector> or <number> expected)")
		return a.x*b.x + a.y*b.y
	end
end

function vector.__div(a,b)
	assert(isvector(a) and type(b) == "number", "wrong argument types (expected <vector> / <number>)")
	return new(a.x / b, a.y / b)
end

function vector.__eq(a,b)
	return a.x == b.x and a.y == b.y
end

function vector.__lt(a,b)
	return a.x < b.x or (a.x == b.x and a.y < b.y)
end

function vector.__le(a,b)
	return a.x <= b.x and a.y <= b.y
end

function vector.permul(a,b)
	assert(isvector(a) and isvector(b), "permul: wrong argument types (<vector> expected)")
	return new(a.x*b.x, a.y*b.y)
end

function vector:toPolar()
	return new(atan2(self.x, self.y), self:len())
end

function vector:len2()
	return self.x * self.x + self.y * self.y
end

function vector:len()
	return sqrt(self.x * self.x + self.y * self.y)
end

function vector.dist(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return sqrt(dx * dx + dy * dy)
end

function vector.dist2(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return (dx * dx + dy * dy)
end

function vector:normalizeInplace()
	local l = self:len()
	if l > 0 then
		self.x, self.y = self.x / l, self.y / l
	end
	return self
end

function vector:normalized()
	return self:clone():normalizeInplace()
end

function vector:rotateInplace(phi)
	local c, s = cos(phi), sin(phi)
	self.x, self.y = c * self.x - s * self.y, s * self.x + c * self.y
	return self
end

function vector:rotated(phi)
	local c, s = cos(phi), sin(phi)
	return new(c * self.x - s * self.y, s * self.x + c * self.y)
end

function vector:perpendicular()
	return new(-self.y, self.x)
end

function vector:projectOn(v)
	assert(isvector(v), "invalid argument: cannot project vector on " .. type(v))
	-- (self * v) * v / v:len2()
	local s = (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x, s * v.y)
end

function vector:mirrorOn(v)
	assert(isvector(v), "invalid argument: cannot mirror vector on " .. type(v))
	-- 2 * self:projectOn(v) - self
	local s = 2 * (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x - self.x, s * v.y - self.y)
end

function vector:cross(v)
	assert(isvector(v), "cross: wrong argument types (<vector> expected)")
	return self.x * v.y - self.y * v.x
end

-- ref.: http://blog.signalsondisplay.com/?p=336
function vector:trimInplace(maxLen)
	local s = maxLen * maxLen / self:len2()
	s = (s > 1 and 1) or math.sqrt(s)
	self.x, self.y = self.x * s, self.y * s
	return self
end

function vector:angleTo(other)
	if other then
		return atan2(self.y, self.x) - atan2(other.y, other.x)
	end
	return atan2(self.y, self.x)
end

function vector:trimmed(maxLen)
	return self:clone():trimInplace(maxLen)
end


-- the module
return setmetatable({
	new             = new,
	fromPolar       = fromPolar,
	randomDirection = randomDirection,
	isvector        = isvector,
	zero            = zero
}, {
	__call = function(_, ...) return new(...) end
})


--- FILE: \lib\hump\spec\timer_spec.lua ---

local timer = require 'timer'()

describe('hump.timer', function()
  it('runs a function during a specified time', function()
    local delta, remaining

    timer:during(10, function(...) delta, remaining = ... end)

    timer:update(2)
    assert.are.equal(delta, 2)
    assert.are.equal(8, remaining)

    timer:update(5)
    assert.are.equal(delta, 5)
    assert.are.equal(3, remaining)

    timer:update(10)
    assert.are.equal(delta, 10)
    assert.are.equal(0, remaining)
  end)

  it('runs a function after a specified time', function()
    local finished1 = false
    local finished2 = false

    timer:after(3, function(...) finished1 = true end)
    timer:after(5, function(...) finished2 = true end)

    timer:update(4)
    assert.are.equal(true, finished1)
    assert.are.equal(false, finished2)

    timer:update(4)
    assert.are.equal(true, finished1)
    assert.are.equal(true, finished2)
  end)

  it('runs a function every so often', function()
    local count = 0

    timer:every(1, function(...) count = count + 1 end)

    timer:update(3)
    assert.are.equal(3, count)

    timer:update(7)
    assert.are.equal(10, count)
  end)

  it('can script timed events', function()
    local state

    timer:script(function(wait)
      state = 'foo'
      wait(1)
      state = 'bar'
    end)

    assert.are.equal('foo', state)
    timer:update(0.5)
    assert.are.equal('foo', state)
    timer:update(1)
    assert.are.equal('bar', state)
  end)

  it('cancels and clears timer functions', function()
    pending('to be tested...')
  end)

  it('tweens', function()
    pending('to be tested...')
  end)
end)


--- FILE: \lib\Jumper\examples\annotatedPathing.lua ---

-- Tests sample for clearance metrics calculation
-- See Figure 10 at http://aigamedev.com/open/tutorial/clearance-based-pathfinding/
-- Jump Point Search still has some flaws with clearance based pathfinding

local Grid = require 'jumper.grid'
local PF = require 'jumper.pathfinder'
local map = {
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,1,0,0,0,0,0,0},
	{0,0,1,0,0,0,0,0,2,0},
	{0,0,1,1,1,0,0,2,0,0},
	{0,0,0,1,1,0,2,0,0,2},
	{0,0,0,0,1,0,0,0,0,2},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0}
}
local grid = Grid(map)
local walkable = function(v) return v~=2 end
local finder = PF(grid, 'ASTAR',walkable)
finder:annotateGrid()
local finderNames = PF:getFinders()

local sx, sy = 1,1
local ex, ey = 9,9
local agent_size = 2

for i = 1,#finderNames do
	finder:setFinder(finderNames[i])
	local path = finder:getPath(sx, sy, ex, ey, agent_size)
	print(('Algorithm used: %s - Path %s')
		:format(finder:getFinder(), path and 'found' or 'not found'))
	if path then
		for node, count in path:nodes() do
			print(('  Step %d. (%d,%d)')
				:format(count, node:getPos()))
		end
	end
end



--- FILE: \lib\Jumper\examples\customHeuristics.lua ---

--- Example of use for Heuristics

local Grid = require ("jumper.grid")
local Pathfinder = require ("jumper.pathfinder")

local map = {
  {0,0,0,0,0,0},
  {0,0,0,0,0,0},
  {0,1,1,1,1,0},
  {0,0,0,0,0,0},
  {0,0,0,0,0,0},
}

local walkable = 0
local grid = Grid(map)
local myFinder = Pathfinder(grid, 'ASTAR', walkable)

-- Use Euclidian heuristic to evaluate distance
myFinder:setHeuristic('EUCLIDIAN')
myFinder:setHeuristic('DIAGONAL')
myFinder:setHeuristic('MANHATTAN')

-- Custom
local h = function(nodeA, nodeB)
	return (0.1 * (math.abs(nodeA:getX() - nodeB:getX()))
	      + 0.9 * (math.abs(nodeA:getY() - nodeB:getY())))
end
myFinder:setHeuristic(h)

local p = myFinder:getPath(1,1, 6,5)
for node, count in p:nodes() do
  print(('%d. Node(%d,%d)'):format(count, node:getX(), node:getY()))
end
print(('Path length: %.2f'):format(p:getLength()))

-- etc ...


--- FILE: \lib\Jumper\examples\makeClearance.lua ---

-- Tests sample for clearance metrics calculation
-- See Figure 10 at http://aigamedev.com/open/tutorial/clearance-based-pathfinding/
local Grid = require 'jumper.grid'
local PF = require 'jumper.pathfinder'
local map = {
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,1,0,0,0,0,0,0},
	{0,0,1,0,0,0,0,0,2,0},
	{0,0,1,1,1,0,0,2,0,0},
	{0,0,0,1,1,0,2,0,0,2},
	{0,0,0,0,1,0,0,0,0,2},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0}
}
local grid = Grid(map)
local walkable = function(v) return v~=2 end
local finder = PF(grid, 'ASTAR',walkable)
finder:annotateGrid()

for y = 1, #map do
	local s = ''
	for x = 1, #map[y] do
	  local node = grid:getNodeAt(x,y)
		s = (s .. ' ' .. node:getClearance(walkable))
	end
	print(s)
end

-- Expected output
--  6 6 5 5 4 4 4 3 2 1
--  6 5 5 4 4 3 3 3 2 1
--  6 5 4 4 3 3 2 2 2 1
--  6 5 4 3 3 2 2 1 1 1
--  6 5 4 3 2 2 1 1 0 1
--  5 5 4 3 2 1 1 0 1 1
--  4 4 4 3 2 1 0 2 1 0
--  3 3 3 3 3 3 3 2 1 0
--  2 2 2 2 2 2 2 2 2 1
--  1 1 1 1 1 1 1 1 1 1



--- FILE: \lib\Jumper\examples\simpleExample.lua ---

--- Very minimal usage example for Jumper

-- Set up a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
-- Calls the grid class
local Grid = require ("jumper.grid")
-- Calls the pathfinder class
local Pathfinder = require ("jumper.pathfinder")

-- Creates a grid object
local grid = Grid(map)

-- Creates a pathfinder object using Jump Point Search algorithm
local myFinder = Pathfinder(grid, 'JPS', walkable)

-- Define start and goal locations coordinates
local startx, starty = 1,1
local endx, endy = 5,1

-- Calculates the path, and its length
local path = myFinder:getPath(startx, starty, endx, endy)

-- Pretty-printing the results
if path then
  print(('Path found! Length: %.2f'):format(path:getLength()))
	for node, count in path:nodes() do
	  print(('Step: %d - x: %d - y: %d'):format(count, node:getX(), node:getY()))
	end
end


--- FILE: \lib\Jumper\jumper\grid.lua ---

--- The Grid class.
-- Implementation of the `grid` class.
-- The `grid` is a implicit graph which represents the 2D
-- world map layout on which the `pathfinder` object will run.
-- During a search, the `pathfinder` object needs to save some critical values. These values are cached within each `node`
-- object, and the whole set of nodes are tight inside the `grid` object itself.

if (...) then

	-- Dependencies
  local _PATH = (...):gsub('%.grid$','')

	-- Local references
  local Utils = require (_PATH .. '.core.utils')
  local Assert = require (_PATH .. '.core.assert')
  local Node = require (_PATH .. '.core.node')

	-- Local references
  local pairs = pairs
  local assert = assert
  local next = next
	local setmetatable = setmetatable
  local floor = math.floor
	local coroutine = coroutine

  -- Offsets for straights moves
  local straightOffsets = {
    {x = 1, y = 0} --[[W]], {x = -1, y =  0}, --[[E]]
    {x = 0, y = 1} --[[S]], {x =  0, y = -1}, --[[N]]
  }

  -- Offsets for diagonal moves
  local diagonalOffsets = {
    {x = -1, y = -1} --[[NW]], {x = 1, y = -1}, --[[NE]]
    {x = -1, y =  1} --[[SW]], {x = 1, y =  1}, --[[SE]]
  }

	--- The `Grid` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Grid(...)</code> _acts as a shortcut to_ <code>Grid:new(...)</code>.
	-- @type Grid
  local Grid = {}
  Grid.__index = Grid

  -- Specialized grids
  local PreProcessGrid = setmetatable({},Grid)
  local PostProcessGrid = setmetatable({},Grid)
  PreProcessGrid.__index = PreProcessGrid
  PostProcessGrid.__index = PostProcessGrid
  PreProcessGrid.__call = function (self,x,y)
    return self:getNodeAt(x,y)
  end
  PostProcessGrid.__call = function (self,x,y,create)
    if create then return self:getNodeAt(x,y) end
    return self._nodes[y] and self._nodes[y][x]
  end

  --- Inits a new `grid`
  -- @class function
  -- @tparam table|string map A collision map - (2D array) with consecutive indices (starting at 0 or 1)
	-- or a `string` with line-break chars (<code>\n</code> or <code>\r</code>) as row delimiters.
  -- @tparam[opt] bool cacheNodeAtRuntime When __true__, returns an empty `grid` instance, so that
	-- later on, indexing a non-cached `node` will cause it to be created and cache within the `grid` on purpose (i.e, when needed).
	-- This is a __memory-safe__ option, in case your dealing with some tight memory constraints.
	-- Defaults to __false__ when omitted.
  -- @treturn grid a new `grid` instance
	-- @usage
	-- -- A simple 3x3 grid
	-- local myGrid = Grid:new({{0,0,0},{0,0,0},{0,0,0}})
	--
	-- -- A memory-safe 3x3 grid
	-- myGrid = Grid('000\n000\n000', true)
  function Grid:new(map, cacheNodeAtRuntime)
		if type(map) == 'string' then
			assert(Assert.isStrMap(map), 'Wrong argument #1. Not a valid string map')
			map = Utils.strToMap(map)
		end
    assert(Assert.isMap(map),('Bad argument #1. Not a valid map'))
    assert(Assert.isBool(cacheNodeAtRuntime) or Assert.isNil(cacheNodeAtRuntime),
      ('Bad argument #2. Expected \'boolean\', got %s.'):format(type(cacheNodeAtRuntime)))
    if cacheNodeAtRuntime then
      return PostProcessGrid:new(map,walkable)
    end
    return PreProcessGrid:new(map,walkable)
  end

  --- Checks if `node` at [x,y] is __walkable__.
	-- Will check if `node` at location [x,y] both *exists* on the collision map and *is walkable*
  -- @class function
  -- @tparam int x the x-location of the node
  -- @tparam int y the y-location of the node
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- If this parameter is a function, it should be prototyped as __f(value)__ and return a `boolean`:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise. If this parameter is not given
  -- while location [x,y] __is valid__, this actual function returns __true__.
  -- @tparam[optchain] int clearance the amount of clearance needed. Defaults to 1 (normal clearance) when not given.
  -- @treturn bool __true__ if `node` exists and is __walkable__, __false__ otherwise
	-- @usage
	-- -- Always true
	-- print(myGrid:isWalkableAt(2,3))
	--
	-- -- True if node at [2,3] collision map value is 0
	-- print(myGrid:isWalkableAt(2,3,0))
	--
	-- -- True if node at [2,3] collision map value is 0 and has a clearance higher or equal to 2
	-- print(myGrid:isWalkableAt(2,3,0,2))
	--
  function Grid:isWalkableAt(x, y, walkable, clearance)
    local nodeValue = self._map[y] and self._map[y][x]
    if nodeValue then
      if not walkable then return true end
    else
			return false
    end
		local hasEnoughClearance = not clearance and true or false
		if not hasEnoughClearance then
			if not self._isAnnotated[walkable] then return false end
			local node = self:getNodeAt(x,y)
			local nodeClearance = node:getClearance(walkable)
			hasEnoughClearance = (nodeClearance >= clearance)
		end
    if self._eval then
			return walkable(nodeValue) and hasEnoughClearance
		end
    return ((nodeValue == walkable) and hasEnoughClearance)
  end

  --- Returns the `grid` width.
  -- @class function
  -- @treturn int the `grid` width
	-- @usage print(myGrid:getWidth())
  function Grid:getWidth()
    return self._width
  end

  --- Returns the `grid` height.
  -- @class function
  -- @treturn int the `grid` height
	-- @usage print(myGrid:getHeight())
  function Grid:getHeight()
     return self._height
  end

  --- Returns the collision map.
  -- @class function
  -- @treturn map the collision map (see @{Grid:new})
	-- @usage local map = myGrid:getMap()
  function Grid:getMap()
    return self._map
  end

  --- Returns the set of nodes.
  -- @class function
  -- @treturn {{node,...},...} an array of nodes
	-- @usage local nodes = myGrid:getNodes()
  function Grid:getNodes()
    return self._nodes
  end

  --- Returns the `grid` bounds. Returned values corresponds to the upper-left
	-- and lower-right coordinates (in tile units) of the actual `grid` instance.
  -- @class function
  -- @treturn int the upper-left corner x-coordinate
  -- @treturn int the upper-left corner y-coordinate
  -- @treturn int the lower-right corner x-coordinate
  -- @treturn int the lower-right corner y-coordinate
	-- @usage local left_x, left_y, right_x, right_y = myGrid:getBounds()
	function Grid:getBounds()
		return self._min_x, self._min_y,self._max_x, self._max_y
	end

  --- Returns neighbours. The returned value is an array of __walkable__ nodes neighbouring a given `node`.
  -- @class function
  -- @tparam node node a given `node`
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool allowDiagonal when __true__, allows adjacent nodes are included (8-neighbours).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool tunnel When __true__, allows the `pathfinder` to tunnel through walls when heading diagonally.
  -- @tparam[optchain] int clearance When given, will prune for the neighbours set all nodes having a clearance value lower than the passed-in value
	-- Defaults to __false__ when omitted.
  -- @treturn {node,...} an array of nodes neighbouring a given node
	-- @usage
	-- local aNode = myGrid:getNodeAt(5,6)
	-- local neighbours = myGrid:getNeighbours(aNode, 0, true)
  function Grid:getNeighbours(node, walkable, allowDiagonal, tunnel, clearance)
		local neighbours = {}
    for i = 1,#straightOffsets do
      local n = self:getNodeAt(
        node._x + straightOffsets[i].x,
        node._y + straightOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
        neighbours[#neighbours+1] = n
      end
    end

    if not allowDiagonal then return neighbours end

		tunnel = not not tunnel
    for i = 1,#diagonalOffsets do
      local n = self:getNodeAt(
        node._x + diagonalOffsets[i].x,
        node._y + diagonalOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
				if tunnel then
					neighbours[#neighbours+1] = n
				else
					local skipThisNode = false
					local n1 = self:getNodeAt(node._x+diagonalOffsets[i].x, node._y)
					local n2 = self:getNodeAt(node._x, node._y+diagonalOffsets[i].y)
					if ((n1 and n2) and not self:isWalkableAt(n1._x, n1._y, walkable, clearance) and not self:isWalkableAt(n2._x, n2._y, walkable, clearance)) then
						skipThisNode = true
					end
					if not skipThisNode then neighbours[#neighbours+1] = n end
				end
      end
    end

    return neighbours
  end

  --- Grid iterator. Iterates on every single node
  -- in the `grid`. Passing __lx, ly, ex, ey__ arguments will iterate
  -- only on nodes inside the bounding-rectangle delimited by those given coordinates.
  -- @class function
  -- @tparam[opt] int lx the leftmost x-coordinate of the rectangle. Default to the `grid` leftmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ly the topmost y-coordinate of the rectangle. Default to the `grid` topmost y-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ex the rightmost x-coordinate of the rectangle. Default to the `grid` rightmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ey the bottom-most y-coordinate of the rectangle. Default to the `grid` bottom-most y-coordinate (see @{Grid:getBounds}).
  -- @treturn node a `node` on the collision map, upon each iteration step
  -- @treturn int the iteration count
	-- @usage
	-- for node, count in myGrid:iter() do
	--   print(node:getX(), node:getY(), count)
	-- end
  function Grid:iter(lx,ly,ex,ey)
    local min_x = lx or self._min_x
    local min_y = ly or self._min_y
    local max_x = ex or self._max_x
    local max_y = ey or self._max_y

    local x, y
    y = min_y
    return function()
      x = not x and min_x or x+1
      if x > max_x then
        x = min_x
        y = y+1
      end
      if y > max_y then
        y = nil
      end
      return self._nodes[y] and self._nodes[y][x] or self:getNodeAt(x,y)
    end
  end

	--- Grid iterator. Iterates on each node along the outline (border) of a squared area
	-- centered on the given node.
	-- @tparam node node a given `node`
	-- @tparam[opt] int radius the area radius (half-length). Defaults to __1__ when not given.
	-- @treturn node a `node` at each iteration step
	-- @usage
	-- for node in myGrid:around(node, 2) do
	--   ...
	-- end
	function Grid:around(node, radius)
		local x, y = node._x, node._y
		radius = radius or 1
		local _around = Utils.around()
		local _nodes = {}
		repeat
			local state, x, y = coroutine.resume(_around,x,y,radius)
			local nodeAt = state and self:getNodeAt(x, y)
			if nodeAt then _nodes[#_nodes+1] = nodeAt end
		until (not state)
		local _i = 0
		return function()
			_i = _i+1
			return _nodes[_i]
		end
	end

  --- Each transformation. Calls the given function on each `node` in the `grid`,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:each(printNode)
  function Grid:each(f,...)
    for node in self:iter() do f(node,...) end
		return self
  end

  --- Each (in range) transformation. Calls a function on each `node` in the range of a rectangle of cells,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:eachRange(1,1,8,8,printNode)
  function Grid:eachRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do f(node,...) end
		return self
  end

  --- Map transformation.
	-- Calls function __f(node,...)__ on each `node` in a given range, passing the `node` as the first arg to function __f__ and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(nothing)
  function Grid:imap(f,...)
    for node in self:iter() do
      node = f(node,...)
    end
		return self
  end

  --- Map in range transformation.
	-- Calls function __f(node,...)__ on each `node` in a rectangle range, passing the `node` as the first argument to the function and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
	-- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(1,1,6,6,nothing)
  function Grid:imapRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do
      node = f(node,...)
    end
		return self
  end

  -- Specialized grids
  -- Inits a preprocessed grid
  function PreProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes, newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.arrayToNodes(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}
    return setmetatable(newGrid,PreProcessGrid)
  end

  -- Inits a postprocessed grid
  function PostProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes = {}
    newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.getArrayBounds(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}		
    return setmetatable(newGrid,PostProcessGrid)
  end

  --- Returns the `node` at location [x,y].
  -- @class function
  -- @name Grid:getNodeAt
  -- @tparam int x the x-coordinate coordinate
  -- @tparam int y the y-coordinate coordinate
  -- @treturn node a `node`
	-- @usage local aNode = myGrid:getNodeAt(2,2)

  -- Gets the node at location <x,y> on a preprocessed grid
  function PreProcessGrid:getNodeAt(x,y)
    return self._nodes[y] and self._nodes[y][x] or nil
  end

  -- Gets the node at location <x,y> on a postprocessed grid
  function PostProcessGrid:getNodeAt(x,y)
    if not x or not y then return end
    if Utils.outOfRange(x,self._min_x,self._max_x) then return end
    if Utils.outOfRange(y,self._min_y,self._max_y) then return end
    if not self._nodes[y] then self._nodes[y] = {} end
    if not self._nodes[y][x] then self._nodes[y][x] = Node:new(x,y) end
    return self._nodes[y][x]
  end

  return setmetatable(Grid,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end


--- FILE: \lib\Jumper\jumper\pathfinder.lua ---

--- The Pathfinder class

--
-- Implementation of the `pathfinder` class.

local _VERSION = ""
local _RELEASEDATE = ""

if (...) then

  -- Dependencies
  local _PATH = (...):gsub('%.pathfinder$','')
	local Utils     = require (_PATH .. '.core.utils')
	local Assert    = require (_PATH .. '.core.assert')
  local Heap      = require (_PATH .. '.core.bheap')
  local Heuristic = require (_PATH .. '.core.heuristics')
  local Grid      = require (_PATH .. '.grid')
  local Path      = require (_PATH .. '.core.path')

  -- Internalization
  local t_insert, t_remove = table.insert, table.remove
	local floor = math.floor
  local pairs = pairs
  local assert = assert
	local type = type
  local setmetatable, getmetatable = setmetatable, getmetatable

	--- Finders (search algorithms implemented). Refers to the search algorithms actually implemented in Jumper.
	--
	-- <li>[A*](http://en.wikipedia.org/wiki/A*_search_algorithm)</li>
	-- <li>[Dijkstra](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)</li>
	-- <li>[Theta Astar](http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/)</li>
	-- <li>[BFS](http://en.wikipedia.org/wiki/Breadth-first_search)</li>
	-- <li>[DFS](http://en.wikipedia.org/wiki/Depth-first_search)</li>
	-- <li>[JPS](http://harablog.wordpress.com/2011/09/07/jump-point-search/)</li>
	-- @finder Finders
	-- @see Pathfinder:getFinders
  local Finders = {
    ['ASTAR']     = require (_PATH .. '.search.astar'),
    ['DIJKSTRA']  = require (_PATH .. '.search.dijkstra'),
    ['THETASTAR'] = require (_PATH .. '.search.thetastar'),
    ['BFS']       = require (_PATH .. '.search.bfs'),
    ['DFS']       = require (_PATH .. '.search.dfs'),
    ['JPS']       = require (_PATH .. '.search.jps')
  }

  -- Will keep track of all nodes expanded during the search
  -- to easily reset their properties for the next pathfinding call
  local toClear = {}

	--- Search modes. Refers to the search modes. In ORTHOGONAL mode, 4-directions are only possible when moving,
	-- including North, East, West, South. In DIAGONAL mode, 8-directions are possible when moving,
	-- including North, East, West, South and adjacent directions.
	--
	-- <li>ORTHOGONAL</li>
	-- <li>DIAGONAL</li>
	-- @mode Modes
	-- @see Pathfinder:getModes
  local searchModes = {['DIAGONAL'] = true, ['ORTHOGONAL'] = true}

  -- Performs a traceback from the goal node to the start node
  -- Only happens when the path was found

	--- The `Pathfinder` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Pathfinder(...)</code> _acts as a shortcut to_ <code>Pathfinder:new(...)</code>.
	-- @type Pathfinder
  local Pathfinder = {}
  Pathfinder.__index = Pathfinder

  --- Inits a new `pathfinder`
  -- @class function
  -- @tparam grid grid a `grid`
  -- @tparam[opt] string finderName the name of the `Finder` (search algorithm) to be used for search.
	-- Defaults to `ASTAR` when not given (see @{Pathfinder:getFinders}).
  -- @tparam[optchain] string|int|func walkable the value for __walkable__ nodes.
  -- If this parameter is a function, it should be prototyped as __f(value)__, returning a boolean:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise.
  -- @treturn pathfinder a new `pathfinder` instance
	-- @usage
	-- -- Example one
	-- local finder = Pathfinder:new(myGrid, 'ASTAR', 0)
	--
	-- -- Example two
	-- local function walkable(value)
	--   return value > 0
	-- end
	-- local finder = Pathfinder(myGrid, 'JPS', walkable)
  function Pathfinder:new(grid, finderName, walkable)
    local newPathfinder = {}
    setmetatable(newPathfinder, Pathfinder)
	  newPathfinder:setGrid(grid)
    newPathfinder:setFinder(finderName)
    newPathfinder:setWalkable(walkable)
    newPathfinder:setMode('DIAGONAL')
    newPathfinder:setHeuristic('MANHATTAN')
    newPathfinder:setTunnelling(false)
    return newPathfinder
  end

	--- Evaluates [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)
	-- for the whole `grid`. It should be called only once, unless the collision map or the
	-- __walkable__ attribute changes. The clearance values are calculated and cached within the grid nodes.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:annotateGrid()
	function Pathfinder:annotateGrid()
		assert(self._walkable, 'Finder must implement a walkable value')
		for x=self._grid._max_x,self._grid._min_x,-1 do
			for y=self._grid._max_y,self._grid._min_y,-1 do
				local node = self._grid:getNodeAt(x,y)
				if self._grid:isWalkableAt(x,y,self._walkable) then
					local nr = self._grid:getNodeAt(node._x+1, node._y)
					local nrd = self._grid:getNodeAt(node._x+1, node._y+1)
					local nd = self._grid:getNodeAt(node._x, node._y+1)
					if nr and nrd and nd then
						local m = nrd._clearance[self._walkable] or 0
						m = (nd._clearance[self._walkable] or 0)<m and (nd._clearance[self._walkable] or 0) or m
						m = (nr._clearance[self._walkable] or 0)<m and (nr._clearance[self._walkable] or 0) or m
						node._clearance[self._walkable] = m+1
					else
						node._clearance[self._walkable] = 1
					end
				else node._clearance[self._walkable] = 0
				end
			end
		end
		self._grid._isAnnotated[self._walkable] = true
		return self
	end

	--- Removes [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)values.
	-- Clears cached clearance values for the current __walkable__.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:clearAnnotations()
	function Pathfinder:clearAnnotations()
		assert(self._walkable, 'Finder must implement a walkable value')
		for node in self._grid:iter() do
			node:removeClearance(self._walkable)
		end
		self._grid._isAnnotated[self._walkable] = false
		return self
	end

  --- Sets the `grid`. Defines the given `grid` as the one on which the `pathfinder` will perform the search.
  -- @class function
  -- @tparam grid grid a `grid`
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setGrid(myGrid)
  function Pathfinder:setGrid(grid)
    assert(Assert.inherits(grid, Grid), 'Wrong argument #1. Expected a \'grid\' object')
    self._grid = grid
    self._grid._eval = self._walkable and type(self._walkable) == 'function'
    return self
  end

  --- Returns the `grid`. This is a reference to the actual `grid` used by the `pathfinder`.
  -- @class function
  -- @treturn grid the `grid`
	-- @usage local myGrid = myFinder:getGrid()
  function Pathfinder:getGrid()
    return self._grid
  end

  --- Sets the __walkable__ value or function.
  -- @class function
  -- @tparam string|int|func walkable the value for walkable nodes.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- -- Value '0' is walkable
	-- myFinder:setWalkable(0)
	--
	-- -- Any value greater than 0 is walkable
	-- myFinder:setWalkable(function(n)
	--   return n>0
	-- end
  function Pathfinder:setWalkable(walkable)
    assert(Assert.matchType(walkable,'stringintfunctionnil'),
      ('Wrong argument #1. Expected \'string\', \'number\' or \'function\', got %s.'):format(type(walkable)))
    self._walkable = walkable
    self._grid._eval = type(self._walkable) == 'function'
    return self
  end

  --- Gets the __walkable__ value or function.
  -- @class function
  -- @treturn string|int|func the `walkable` value or function
	-- @usage local walkable = myFinder:getWalkable()
  function Pathfinder:getWalkable()
    return self._walkable
  end

  --- Defines the `finder`. It refers to the search algorithm used by the `pathfinder`.
  -- Default finder is `ASTAR`. Use @{Pathfinder:getFinders} to get the list of available finders.
  -- @class function
  -- @tparam string finderName the name of the `finder` to be used for further searches.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- --To use Breadth-First-Search
	-- myFinder:setFinder('BFS')
	-- @see Pathfinder:getFinders
  function Pathfinder:setFinder(finderName)
		if not finderName then
			if not self._finder then
				finderName = 'ASTAR'
			else return
			end
		end
    assert(Finders[finderName],'Not a valid finder name!')
    self._finder = finderName
    return self
  end

  --- Returns the name of the `finder` being used.
  -- @class function
  -- @treturn string the name of the `finder` to be used for further searches.
	-- @usage local finderName = myFinder:getFinder()
  function Pathfinder:getFinder()
    return self._finder
  end

  --- Returns the list of all available finders names.
  -- @class function
  -- @treturn {string,...} array of built-in finders names.
	-- @usage
	-- local finders = myFinder:getFinders()
	-- for i, finderName in ipairs(finders) do
	--   print(i, finderName)
	-- end
  function Pathfinder:getFinders()
    return Utils.getKeys(Finders)
  end

  --- Sets a heuristic. This is a function internally used by the `pathfinder` to find the optimal path during a search.
  -- Use @{Pathfinder:getHeuristics} to get the list of all available `heuristics`. One can also define
  -- his own `heuristic` function.
  -- @class function
  -- @tparam func|string heuristic `heuristic` function, prototyped as __f(dx,dy)__ or as a `string`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getHeuristics
	-- @see core.heuristics
	-- @usage myFinder:setHeuristic('MANHATTAN')
  function Pathfinder:setHeuristic(heuristic)
    assert(Heuristic[heuristic] or (type(heuristic) == 'function'),'Not a valid heuristic!')
    self._heuristic = Heuristic[heuristic] or heuristic
    return self
  end

  --- Returns the `heuristic` used. Returns the function itself.
  -- @class function
  -- @treturn func the `heuristic` function being used by the `pathfinder`
	-- @see core.heuristics
	-- @usage local h = myFinder:getHeuristic()
  function Pathfinder:getHeuristic()
    return self._heuristic
  end

  --- Gets the list of all available `heuristics`.
  -- @class function
  -- @treturn {string,...} array of heuristic names.
	-- @see core.heuristics
	-- @usage
	-- local heur = myFinder:getHeuristic()
	-- for i, heuristicName in ipairs(heur) do
	--   ...
	-- end
  function Pathfinder:getHeuristics()
    return Utils.getKeys(Heuristic)
  end

  --- Defines the search `mode`.
  -- The default search mode is the `DIAGONAL` mode, which implies 8-possible directions when moving (north, south, east, west and diagonals).
  -- In `ORTHOGONAL` mode, only 4-directions are allowed (north, south, east and west).
  -- Use @{Pathfinder:getModes} to get the list of all available search modes.
  -- @class function
  -- @tparam string mode the new search `mode`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getModes
	-- @see Modes
	-- @usage myFinder:setMode('ORTHOGONAL')
  function Pathfinder:setMode(mode)
    assert(searchModes[mode],'Invalid mode')
    self._allowDiagonal = (mode == 'DIAGONAL')
    return self
  end

  --- Returns the search mode.
  -- @class function
  -- @treturn string the current search mode
	-- @see Modes
	-- @usage local mode = myFinder:getMode()
  function Pathfinder:getMode()
    return (self._allowDiagonal and 'DIAGONAL' or 'ORTHOGONAL')
  end

  --- Gets the list of all available search modes.
  -- @class function
  -- @treturn {string,...} array of search modes.
	-- @see Modes
	-- @usage local modes = myFinder:getModes()
	-- for modeName in ipairs(modes) do
	--   ...
	-- end
  function Pathfinder:getModes()
    return Utils.getKeys(searchModes)
  end

  --- Enables tunnelling. Defines the ability for the `pathfinder` to tunnel through walls when heading diagonally.
	-- This feature __is not compatible__ with Jump Point Search algorithm (i.e. enabling it will not affect Jump Point Search)
  -- @class function
  -- @tparam bool bool a boolean
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setTunnelling(true)
  function Pathfinder:setTunnelling(bool)
    assert(Assert.isBool(bool), ('Wrong argument #1. Expected boolean, got %s'):format(type(bool)))
		self._tunnel = bool
		return self
  end

  --- Returns tunnelling feature state.
  -- @class function
	-- @treturn bool tunnelling feature actual state
	-- @usage local isTunnellingEnabled = myFinder:getTunnelling()
  function Pathfinder:getTunnelling()
		return self._tunnel
  end

  --- Calculates a `path`. Returns the `path` from location __[startX, startY]__ to location __[endX, endY]__.
  -- Both locations must exist on the collision map. The starting location can be unwalkable.
  -- @class function
  -- @tparam int startX the x-coordinate for the starting location
  -- @tparam int startY the y-coordinate for the starting location
  -- @tparam int endX the x-coordinate for the goal location
  -- @tparam int endY the y-coordinate for the goal location
  -- @tparam int clearance the amount of clearance (i.e the pathing agent size) to consider
  -- @treturn path a path (array of nodes) when found, otherwise nil
	-- @usage local path = myFinder:getPath(1,1,5,5)
  function Pathfinder:getPath(startX, startY, endX, endY, clearance)
		self:reset()
    local startNode = self._grid:getNodeAt(startX, startY)
    local endNode = self._grid:getNodeAt(endX, endY)
    assert(startNode, ('Invalid location [%d, %d]'):format(startX, startY))
    assert(endNode and self._grid:isWalkableAt(endX, endY),
      ('Invalid or unreachable location [%d, %d]'):format(endX, endY))
    local _endNode = Finders[self._finder](self, startNode, endNode, clearance, toClear)
    if _endNode then
			return Utils.traceBackPath(self, _endNode, startNode)
    end
    return nil
  end

  --- Resets the `pathfinder`. This function is called internally between successive pathfinding calls, so you should not
	-- use it explicitely, unless under specific circumstances.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage local path, len = myFinder:getPath(1,1,5,5)
	function Pathfinder:reset()
    for node in pairs(toClear) do node:reset() end
    toClear = {}
		return self
	end


  -- Returns Pathfinder class
	Pathfinder._VERSION = _VERSION
	Pathfinder._RELEASEDATE = _RELEASEDATE
  return setmetatable(Pathfinder,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end


--- FILE: \lib\Jumper\jumper\core\assert.lua ---

-- Various assertion function for API methods argument-checking

if (...) then
	
	-- Dependancies
	local _PATH = (...):gsub('%.core.assert$','')
	local Utils = require (_PATH .. '.core.utils')
	
	-- Local references
	local lua_type = type
	local floor = math.floor
	local concat = table.concat
	local next = next
	local pairs = pairs
	local getmetatable = getmetatable
	
	-- Is I an integer ?
	local function isInteger(i)
		return lua_type(i) ==('number') and (floor(i)==i)
	end
	
	-- Override lua_type to return integers
	local function type(v)
		return isInteger(v) and 'int' or lua_type(v)
	end
	
	-- Does the given array contents match a predicate type ?
	local function arrayContentsMatch(t,...)
		local n_count = Utils.arraySize(t)
		if n_count < 1 then return false end
		local init_count = t[0] and 0 or 1
		local n_count = (t[0] and n_count-1 or n_count)
		local types = {...}
		if types then types = concat(types) end
		for i=init_count,n_count,1 do
			if not t[i] then return false end
			if types then
				if not types:match(type(t[i])) then return false end
			end
		end
		return true
	end	
	
	-- Checks if arg is a valid array map
  local function isMap(m)
		if not arrayContentsMatch(m, 'table') then return false end
		local lsize = Utils.arraySize(m[next(m)])
		for k,v in pairs(m) do
			if not arrayContentsMatch(m[k], 'string', 'int') then return false end
			if Utils.arraySize(v)~=lsize then return false end
		end
		return true
  end	
	
	-- Checks if s is a valid string map
  local function isStringMap(s)
    if lua_type(s) ~= 'string' then return false end
    local w
    for row in s:gmatch('[^\n\r]+') do
      if not row then return false end
      w = w or #row
      if w ~= #row then return false end
    end
    return true
  end

	-- Does instance derive straight from class
	local function derives(instance, class)
		return getmetatable(instance) == class
	end
	
	-- Does instance inherits from class	
	local function inherits(instance, class)
		return (getmetatable(getmetatable(instance)) == class)
	end
	
	-- Is arg a boolean
	local function isBoolean(b) 
		return (b==true or b==false)
	end
	
	-- Is arg nil ?
	local function isNil(n)
		return (n==nil)
	end
	
	local function matchType(value, types)
		return types:match(type(value))	
	end
	
	return {
		arrayContentsMatch = arrayContentsMatch,
		derives = derives,
		inherits = inherits,
		isInteger = isInteger,
		isBool = isBoolean,
		isMap = isMap,
		isStrMap = isStringMap,
		isOutOfRange = isOutOfRange,
		isNil = isNil,
		type = type,
		matchType = matchType
	}

end




--- FILE: \lib\Jumper\jumper\core\bheap.lua ---

--- A light implementation of Binary heaps data structure.
-- While running a search, some search algorithms (Astar, Dijkstra, Jump Point Search) have to maintains
-- a list of nodes called __open list__. Retrieve from this list the lowest cost node can be quite slow, 
-- as it normally requires to skim through the full set of nodes stored in this list. This becomes a real 
-- problem especially when dozens of nodes are being processed (on large maps). 
--
-- The current module implements a <a href="http://www.policyalmanac.org/games/binaryHeaps.htm">binary heap</a>
-- data structure, from which the search algorithm will instantiate an open list, and cache the nodes being 
-- examined during a search. As such, retrieving the lower-cost node is faster and globally makes the search end 
-- up quickly.
-- 
-- This module is internally used by the library on purpose.
-- It should normally not be used explicitely, yet it remains fully accessible.
--

--[[
  Notes:
  This lighter implementation of binary heaps, based on :
    https://github.com/Yonaba/Binary-Heaps
--]]

if (...) then

	-- Dependency
	local Utils = require((...):gsub('%.bheap$','.utils'))
	
	-- Local reference
	local floor = math.floor

	-- Default comparison function
	local function f_min(a,b) return a < b end

	-- Percolates up
	local function percolate_up(heap, index)
		if index == 1 then return end
		local pIndex
		if index <= 1 then return end
		if index%2 == 0 then
			pIndex =  index/2
		else pIndex = (index-1)/2
		end
		if not heap._sort(heap._heap[pIndex], heap._heap[index]) then
			heap._heap[pIndex], heap._heap[index] = 
				heap._heap[index], heap._heap[pIndex]
			percolate_up(heap, pIndex)
		end
	end

	-- Percolates down
	local function percolate_down(heap,index)
		local lfIndex,rtIndex,minIndex
		lfIndex = 2*index
		rtIndex = lfIndex + 1
		if rtIndex > heap._size then
			if lfIndex > heap._size then return
			else minIndex = lfIndex  end
		else
			if heap._sort(heap._heap[lfIndex],heap._heap[rtIndex]) then
				minIndex = lfIndex
			else
				minIndex = rtIndex
			end
		end
		if not heap._sort(heap._heap[index],heap._heap[minIndex]) then
			heap._heap[index],heap._heap[minIndex] = heap._heap[minIndex],heap._heap[index]
			percolate_down(heap,minIndex)
		end
	end

	-- Produces a new heap
	local function newHeap(template,comp)
		return setmetatable({_heap = {},
			_sort = comp or f_min, _size = 0},
		template)
	end


	--- The `heap` class.<br/>
	-- This class is callable.
	-- _Therefore,_ <code>heap(...)</code> _is used to instantiate new heaps_.
	-- @type heap
	local heap = setmetatable({},
		{__call = function(self,...)
			return newHeap(self,...)
		end})
	heap.__index = heap

	--- Checks if a `heap` is empty
	-- @class function
	-- @treturn bool __true__ of no item is queued in the heap, __false__ otherwise
	-- @usage
	-- if myHeap:empty() then 
	--   print('Heap is empty!')
	-- end
	function heap:empty()
		return (self._size==0)
	end

	--- Clears the `heap` (removes all items queued in the heap)
	-- @class function
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage myHeap:clear()
	function heap:clear()
		self._heap = {}
		self._size = 0
		self._sort = self._sort or f_min
		return self
	end

	--- Adds a new item in the `heap`
	-- @class function
	-- @tparam value item a new value to be queued in the heap
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage
	-- myHeap:push(1)
	-- -- or, with chaining
	-- myHeap:push(1):push(2):push(4)
	function heap:push(item)
		if item then
			self._size = self._size + 1
			self._heap[self._size] = item
			percolate_up(self, self._size)
		end
		return self
	end

	--- Pops from the `heap`.
	-- Removes and returns the lowest cost item (with respect to the comparison function being used) from the `heap`.
	-- @class function
	-- @treturn value a value previously pushed into the heap
	-- @usage
	-- while not myHeap:empty() do 
	--   local lowestValue = myHeap:pop()
	--   ...
	-- end
	function heap:pop()
		local root
		if self._size > 0 then
			root = self._heap[1]
			self._heap[1] = self._heap[self._size]
			self._heap[self._size] = nil
			self._size = self._size-1
			if self._size>1 then
				percolate_down(self, 1)
			end
		end
		return root
	end

	--- Restores the `heap` property.
	-- Reorders the `heap` with respect to the comparison function being used. 
	-- When given argument __item__ (a value existing in the `heap`), will sort from that very item in the `heap`. 
	-- Otherwise, the whole `heap` will be cheacked. 
	-- @class function
	-- @tparam[opt] value item the modified value
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage myHeap:heapify() 
	function heap:heapify(item)
		if self._size == 0 then return end
		if item then
			local i = Utils.indexOf(self._heap,item)
			if i then 
				percolate_down(self, i)
				percolate_up(self, i)
			end
			return
		end
		for i = floor(self._size/2),1,-1 do
			percolate_down(self,i)
		end
		return self
	end

	return heap
end


--- FILE: \lib\Jumper\jumper\core\heuristics.lua ---

--- Heuristic functions for search algorithms.
-- A <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">distance heuristic</a> 
-- provides an *estimate of the optimal distance cost* from a given location to a target. 
-- As such, it guides the pathfinder to the goal, helping it to decide which route is the best.
--
-- This script holds the definition of some built-in heuristics available through jumper.
--
-- Distance functions are internally used by the `pathfinder` to evaluate the optimal path
-- from the start location to the goal. These functions share the same prototype:
--     local function myHeuristic(nodeA, nodeB)
--       -- function body
--     end
-- Jumper features some built-in distance heuristics, namely `MANHATTAN`, `EUCLIDIAN`, `DIAGONAL`, `CARDINTCARD`.
-- You can also supply your own heuristic function, following the same template as above.


local abs = math.abs
local sqrt = math.sqrt
local sqrt2 = sqrt(2)
local max, min = math.max, math.min

local Heuristics = {}
  --- Manhattan distance.
  -- <br/>This heuristic is the default one being used by the `pathfinder` object.
  -- <br/>Evaluates as <code>distance = |dx|+|dy|</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('MANHATTAN')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.MANHATTAN)
  function Heuristics.MANHATTAN(nodeA, nodeB) 
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)
		return (dx + dy) 
	end
  
  --- Euclidian distance.
  -- <br/>Evaluates as <code>distance = squareRoot(dx*dx+dy*dy)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('EUCLIDIAN')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.EUCLIDIAN) 
  function Heuristics.EUCLIDIAN(nodeA, nodeB)
		local dx = nodeA._x - nodeB._x
		local dy = nodeA._y - nodeB._y
		return sqrt(dx*dx+dy*dy) 
	end
  
  --- Diagonal distance.
  -- <br/>Evaluates as <code>distance = max(|dx|, abs|dy|)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('DIAGONAL')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.DIAGONAL)
  function Heuristics.DIAGONAL(nodeA, nodeB)
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)	
		return max(dx,dy) 
	end
  
  --- Cardinal/Intercardinal distance.
  -- <br/>Evaluates as <code>distance = min(dx, dy)*squareRoot(2) + max(dx, dy) - min(dx, dy)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('CARDINTCARD')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.CARDINTCARD)
  function Heuristics.CARDINTCARD(nodeA, nodeB)
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)	
    return min(dx,dy) * sqrt2 + max(dx,dy) - min(dx,dy)
  end

return Heuristics


--- FILE: \lib\Jumper\jumper\core\lookuptable.lua ---

local addNode(self, node, nextNode, ed)
	if not self._pathDB[node] then self._pathDB[node] = {} end
	self._pathDB[node][ed] = (nextNode == ed and node or nextNode)
end

-- Path lookupTable
local lookupTable = {}
lookupTable.__index = lookupTable

function lookupTable:new()
	local lut = {_pathDB = {}}
	return setmetatable(lut, lookupTable)
end

function lookupTable:addPath(path)
	local st, ed = path._nodes[1], path._nodes[#path._nodes]
	for node, count in path:nodes() do
		local nextNode = path._nodes[count+1]
		if nextNode then addNode(self, node, nextNode, ed) end
	end
end

function lookupTable:hasPath(nodeA, nodeB)
	local found
	found = self._pathDB[nodeA] and self._path[nodeA][nodeB]
	if found then return true, true end
	found = self._pathDB[nodeB] and self._path[nodeB][nodeA]
	if found then return true, false end
	return false
end

return lookupTable


--- FILE: \lib\Jumper\jumper\core\node.lua ---

--- The Node class.
-- The `node` represents a cell (or a tile) on a collision map. Basically, for each single cell (tile)
-- in the collision map passed-in upon initialization, a `node` object will be generated
-- and then cached within the `grid`.
--
-- In the following implementation, nodes can be compared using the `<` operator. The comparison is
-- made with regards of their `f` cost. From a given node being examined, the `pathfinder` will expand the search 
-- to the next neighbouring node having the lowest `f` cost. See `core.bheap` for more details.
-- 

if (...) then

	local assert = assert
	
	--- The `Node` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Node(...)</code> _acts as a shortcut to_ <code>Node:new(...)</code>.
	-- @type Node
  local Node = {}
  Node.__index = Node

  --- Inits a new `node`
  -- @class function
  -- @tparam int x the x-coordinate of the node on the collision map
  -- @tparam int y the y-coordinate of the node on the collision map
  -- @treturn node a new `node`
	-- @usage local node = Node(3,4)
  function Node:new(x,y)
    return setmetatable({_x = x, _y = y, _clearance = {}}, Node)
  end

  -- Enables the use of operator '<' to compare nodes.
  -- Will be used to sort a collection of nodes in a binary heap on the basis of their F-cost
  function Node.__lt(A,B) return (A._f < B._f) end

  --- Returns x-coordinate of a `node`
  -- @class function
  -- @treturn number the x-coordinate of the `node`
	-- @usage local x = node:getX()	
	function Node:getX() return self._x end
	
  --- Returns y-coordinate of a `node`
  -- @class function
  -- @treturn number the y-coordinate of the `node`	
	-- @usage local y = node:getY()		
	function Node:getY() return self._y end
	
  --- Returns x and y coordinates of a `node`
  -- @class function
  -- @treturn number the x-coordinate of the `node`
  -- @treturn number the y-coordinate of the `node`
	-- @usage local x, y = node:getPos()		
	function Node:getPos() return self._x, self._y end
	
  --- Returns the amount of true [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric) 
	-- for a given `node`
  -- @class function
  -- @tparam string|int|func walkable the value for walkable locations in the collision map array.
  -- @treturn int the clearance of the `node`
	-- @usage
	--  -- Assuming walkable was 0	
	-- local clearance = node:getClearance(0)		
	function Node:getClearance(walkable)
		return self._clearance[walkable]
	end
	
  --- Removes the clearance value for a given walkable.
  -- @class function
  -- @tparam string|int|func walkable the value for walkable locations in the collision map array.
	-- @treturn node self (the calling `node` itself, can be chained)
	-- @usage
	--  -- Assuming walkable is defined	
	-- node:removeClearance(walkable)	
	function Node:removeClearance(walkable)
		self._clearance[walkable] = nil
		return self
	end
	
	--- Clears temporary cached attributes of a `node`.
	-- Deletes the attributes cached within a given node after a pathfinding call.
	-- This function is internally used by the search algorithms, so you should not use it explicitely.
	-- @class function
	-- @treturn node self (the calling `node` itself, can be chained)
	-- @usage
	-- local thisNode = Node(1,2)
	-- thisNode:reset()
	function Node:reset()
		self._g, self._h, self._f = nil, nil, nil
		self._opened, self._closed, self._parent = nil, nil, nil
		return self
	end
	
  return setmetatable(Node,
		{__call = function(self,...) 
			return Node:new(...) 
		end}
	)
end


--- FILE: \lib\Jumper\jumper\core\path.lua ---

--- The Path class.
-- The `path` class is a structure which represents a path (ordered set of nodes) from a start location to a goal.
-- An instance from this class would be a result of a request addressed to `Pathfinder:getPath`.
--
-- This module is internally used by the library on purpose.
-- It should normally not be used explicitely, yet it remains fully accessible.
--


if (...) then
	
  -- Dependencies
	local _PATH = (...):match('(.+)%.path$')
  local Heuristic = require (_PATH .. '.heuristics')
	
	 -- Local references
  local abs, max = math.abs, math.max
	local t_insert, t_remove = table.insert, table.remove
	
	--- The `Path` class.<br/>
	-- This class is callable.
	-- Therefore, <em><code>Path(...)</code></em> acts as a shortcut to <em><code>Path:new(...)</code></em>.
	-- @type Path
  local Path = {}
  Path.__index = Path

  --- Inits a new `path`.
  -- @class function
  -- @treturn path a `path`
	-- @usage local p = Path()
  function Path:new()
    return setmetatable({_nodes = {}}, Path)
  end

  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns the `node` plus a count value. Aliased as @{Path:nodes}
  -- @class function
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see Path:nodes
	-- @usage
	-- for node, count in p:iter() do
	--   ...
	-- end
  function Path:iter()
    local i,pathLen = 1,#self._nodes
    return function()
      if self._nodes[i] then
        i = i+1
        return self._nodes[i-1],i-1
      end
    end
  end
  
  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns a `node` plus a count value. Alias for @{Path:iter}
  -- @class function
	-- @name Path:nodes
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see Path:iter	
	-- @usage
	-- for node, count in p:nodes() do
	--   ...
	-- end	
	Path.nodes = Path.iter
	
  --- Evaluates the `path` length
  -- @class function
  -- @treturn number the `path` length
	-- @usage local len = p:getLength()
  function Path:getLength()
    local len = 0
    for i = 2,#self._nodes do
      len = len + Heuristic.EUCLIDIAN(self._nodes[i], self._nodes[i-1])
    end
    return len
  end
	
	--- Counts the number of steps.
	-- Returns the number of waypoints (nodes) in the current path.
	-- @class function
	-- @tparam node node a node to be added to the path
	-- @tparam[opt] int index the index at which the node will be inserted. If omitted, the node will be appended after the last node in the path.
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage local nSteps = p:countSteps()
	function Path:addNode(node, index)
		index = index or #self._nodes+1
		t_insert(self._nodes, index, node)
		return self
	end
	
	
  --- `Path` filling modifier. Interpolates between non contiguous nodes along a `path`
  -- to build a fully continuous `path`. This maybe useful when using search algorithms such as Jump Point Search.
  -- Does the opposite of @{Path:filter}
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)	
  -- @see Path:filter
	-- @usage p:fill()
  function Path:fill()
    local i = 2
    local xi,yi,dx,dy
    local N = #self._nodes
    local incrX, incrY
    while true do
      xi,yi = self._nodes[i]._x,self._nodes[i]._y
      dx,dy = xi-self._nodes[i-1]._x,yi-self._nodes[i-1]._y
      if (abs(dx) > 1 or abs(dy) > 1) then
        incrX = dx/max(abs(dx),1)
        incrY = dy/max(abs(dy),1)
        t_insert(self._nodes, i, self._grid:getNodeAt(self._nodes[i-1]._x + incrX, self._nodes[i-1]._y +incrY))
        N = N+1
      else i=i+1
      end
      if i>N then break end
    end
		return self
  end

  --- `Path` compression modifier. Given a `path`, eliminates useless nodes to return a lighter `path` 
	-- consisting of straight moves. Does the opposite of @{Path:fill}
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)	
  -- @see Path:fill
	-- @usage p:filter()
  function Path:filter()
    local i = 2
    local xi,yi,dx,dy, olddx, olddy
    xi,yi = self._nodes[i]._x, self._nodes[i]._y
    dx, dy = xi - self._nodes[i-1]._x, yi-self._nodes[i-1]._y
    while true do
      olddx, olddy = dx, dy
      if self._nodes[i+1] then
        i = i+1
        xi, yi = self._nodes[i]._x, self._nodes[i]._y
        dx, dy = xi - self._nodes[i-1]._x, yi - self._nodes[i-1]._y
        if olddx == dx and olddy == dy then
          t_remove(self._nodes, i-1)
          i = i - 1
        end
      else break end
    end
		return self
  end
	
  --- Clones a `path`.
  -- @class function
  -- @treturn path a `path`
	-- @usage local p = path:clone()	
	function Path:clone()
		local p = Path:new()
		for node in self:nodes() do p:addNode(node) end
		return p
	end
	
  --- Checks if a `path` is equal to another. It also supports *filtered paths* (see @{Path:filter}).
  -- @class function
	-- @tparam path p2 a path
  -- @treturn boolean a boolean
	-- @usage print(myPath:isEqualTo(anotherPath))
	function Path:isEqualTo(p2)
		local p1 = self:clone():filter()
		local p2 = p2:clone():filter()
		for node, count in p1:nodes() do
			if not p2._nodes[count] then return false end
			local n = p2._nodes[count]
			if n._x~=node._x or n._y~=node._y then return false end
		end	
		return true
	end
	
  --- Reverses a `path`.
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage myPath:reverse()	
	function Path:reverse()
		local _nodes = {}
		for i = #self._nodes,1,-1 do
			_nodes[#_nodes+1] = self._nodes[i]		
		end
		self._nodes = _nodes
		return self
	end	

  --- Appends a given `path` to self.
  -- @class function
	-- @tparam path p a path
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage myPath:append(anotherPath)		
	function Path:append(p)
		for node in p:nodes() do self:addNode(node)	end
		return self
	end
	
  return setmetatable(Path,
    {__call = function(self,...)
      return Path:new(...)
    end
  })
end


--- FILE: \lib\Jumper\jumper\core\utils.lua ---

-- Various utilities for Jumper top-level modules

if (...) then

	-- Dependencies
	local _PATH = (...):gsub('%.utils$','')
	local Path = require (_PATH .. '.path')
	local Node = require (_PATH .. '.node')

	-- Local references
	local pairs = pairs
	local type = type
	local t_insert = table.insert
	local assert = assert
	local coroutine = coroutine

	-- Raw array items count
	local function arraySize(t)
		local count = 0
		for k,v in pairs(t) do
			count = count+1
		end
		return count
	end

	-- Parses a string map and builds an array map
  local function stringMapToArray(str)
		local map = {}
		local w, h
    for line in str:gmatch('[^\n\r]+') do
      if line then
        w = not w and #line or w
        assert(#line == w, 'Error parsing map, rows must have the same size!')
        h = (h or 0) + 1
        map[h] = {}
        for char in line:gmatch('.') do
					map[h][#map[h]+1] = char
				end
      end
    end
    return map
  end

	-- Collects and returns the keys of a given array
  local function getKeys(t)
    local keys = {}
    for k,v in pairs(t) do keys[#keys+1] = k end
    return keys
  end

	-- Calculates the bounds of a 2d array
  local function getArrayBounds(map)
    local min_x, max_x
    local min_y, max_y
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
        end
      end
    return min_x,max_x,min_y,max_y
  end

  -- Converts an array to a set of nodes
  local function arrayToNodes(map)
    local min_x, max_x
    local min_y, max_y
    local nodes = {}
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        nodes[y] = {}
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
          nodes[y][x] = Node:new(x,y)
        end
      end
    return nodes,
			 (min_x or 0), (max_x or 0),
			 (min_y or 0), (max_y or 0)
  end

	-- Iterator, wrapped within a coroutine
	-- Iterates around a given position following the outline of a square
	local function around()
		local iterf = function(x0, y0, s)
			local x, y = x0-s, y0-s
			coroutine.yield(x, y)
			repeat
				x = x + 1
				coroutine.yield(x,y)
			until x == x0+s
			repeat
				y = y + 1
				coroutine.yield(x,y)
			until y == y0 + s
			repeat
				x = x - 1
				coroutine.yield(x, y)
			until x == x0-s
			repeat
				y = y - 1
				coroutine.yield(x,y)
			until y == y0-s+1
		end
		return coroutine.create(iterf)
	end

	-- Extract a path from a given start/end position
  local function traceBackPath(finder, node, startNode)
    local path = Path:new()
    path._grid = finder._grid
    while true do
      if node._parent then
        t_insert(path._nodes,1,node)
        node = node._parent
      else
        t_insert(path._nodes,1,startNode)
        return path
      end
    end
  end

	-- Lookup for value in a table
	local indexOf = function(t,v)
		for i = 1,#t do
			if t[i] == v then return i end
		end
		return nil
	end

	-- Is i out of range
  local function outOfRange(i,low,up)
    return (i< low or i > up)
  end
	
	return {
		arraySize = arraySize,
		getKeys = getKeys,
		indexOf = indexOf,
		outOfRange = outOfRange,
		getArrayBounds = getArrayBounds,
		arrayToNodes = arrayToNodes,
		strToMap = stringMapToArray,
		around = around,
		drAround = drAround,
		traceBackPath = traceBackPath
	}

end


--- FILE: \lib\Jumper\jumper\search\astar.lua ---

-- Astar algorithm
-- This actual implementation of A-star is based on
-- [Nash A. & al. pseudocode](http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/)

if (...) then

	-- Internalization
	local ipairs = ipairs
	local huge = math.huge

	-- Dependancies
	local _PATH = (...):match('(.+)%.search.astar$')
	local Heuristics = require (_PATH .. '.core.heuristics')
	local Heap = require (_PATH.. '.core.bheap')

	-- Updates G-cost
	local function computeCost(node, neighbour, finder, clearance)
		local mCost = Heuristics.EUCLIDIAN(neighbour, node)
		if node._g + mCost < neighbour._g then
			neighbour._parent = node
			neighbour._g = node._g + mCost
		end
	end

	-- Updates vertex node-neighbour
	local function updateVertex(finder, openList, node, neighbour, endNode, clearance, heuristic, overrideCostEval)
		local oldG = neighbour._g
		local cmpCost = overrideCostEval or computeCost
		cmpCost(node, neighbour, finder, clearance)
		if neighbour._g < oldG then
			local nClearance = neighbour._clearance[finder._walkable]
			local pushThisNode = clearance and nClearance and (nClearance >= clearance)
			if (clearance and pushThisNode) or (not clearance) then
				if neighbour._opened then neighbour._opened = false end				
				neighbour._h = heuristic(endNode, neighbour)
				neighbour._f = neighbour._g + neighbour._h
				openList:push(neighbour)
				neighbour._opened = true
			end
		end
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear, overrideHeuristic, overrideCostEval)
		
		local heuristic = overrideHeuristic or finder._heuristic
		local openList = Heap()
		startNode._g = 0
		startNode._h = heuristic(endNode, startNode)
		startNode._f = startNode._g + startNode._h
		openList:push(startNode)
		toClear[startNode] = true
		startNode._opened = true

		while not openList:empty() do
			local node = openList:pop()
			node._closed = true
			if node == endNode then return node end
			local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
			for i = 1,#neighbours do
				local neighbour = neighbours[i]
				if not neighbour._closed then
					toClear[neighbour] = true
					if not neighbour._opened then
						neighbour._g = huge
						neighbour._parent = nil	
					end
					updateVertex(finder, openList, node, neighbour, endNode, clearance, heuristic, overrideCostEval)
				end	
			end	
		end
		
		return nil 
	end

end


--- FILE: \lib\Jumper\jumper\search\bfs.lua ---

-- Breadth-First search algorithm

if (...) then
  -- Internalization
  local t_remove = table.remove

  local function breadth_first_search(finder, openList, node, endNode, clearance, toClear)
    local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if not neighbour._closed and not neighbour._opened then
				local nClearance = neighbour._clearance[finder._walkable]
				local pushThisNode = clearance and nClearance and (nClearance >= clearance)			
        if (clearance and pushThisNode) or (not clearance) then
					openList[#openList+1] = neighbour
					neighbour._opened = true
					neighbour._parent = node
					toClear[neighbour] = true
				end
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)

    local openList = {} -- We'll use a FIFO queue (simple array)
    openList[1] = startNode
    startNode._opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[1]
      t_remove(openList,1)
      node._closed = true
      if node == endNode then return node end
      breadth_first_search(finder, openList, node, endNode, clearance, toClear)
    end

    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\dfs.lua ---

-- Depth-First search algorithm.

if (...) then
  -- Internalization
  local t_remove = table.remove

  local function depth_first_search(finder, openList, node, endNode, clearance, toClear)
    local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if (not neighbour._closed and not neighbour._opened) then
				local nClearance = neighbour._clearance[finder._walkable]
				local pushThisNode = clearance and nClearance and (nClearance >= clearance)
				if (clearance and pushThisNode) or (not clearance) then			
					openList[#openList+1] = neighbour
					neighbour._opened = true
					neighbour._parent = node
					toClear[neighbour] = true
				end
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)

    local openList = {} -- We'll use a LIFO queue (simple array)
    openList[1] = startNode
    startNode._opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[#openList]
      t_remove(openList)
      node._closed = true
      if node == endNode then return node end
      depth_first_search(finder, openList, node, endNode, clearance, toClear)
    end

    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\dijkstra.lua ---

-- Dijkstra algorithm (Uses Astar implementation)

if (...) then

  local astar_search = require ((...):gsub('%.dijkstra$','.astar'))
  -- Dijkstra is similar to aStar, with no heuristic
  local dijkstraHeuristic = function() return 0 end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)
    return astar_search(finder, startNode, endNode, clearance, toClear, dijkstraHeuristic)
  end

end


--- FILE: \lib\Jumper\jumper\search\jps.lua ---

-- Jump Point search algorithm

if (...) then

  -- Dependancies
  local _PATH = (...):match('(.+)%.search.jps$')
  local Heuristics = require (_PATH .. '.core.heuristics')
	local Heap = require (_PATH.. '.core.bheap')

  -- Internalization
  local max, abs = math.max, math.abs

  -- Local helpers, these routines will stay private
  -- As they are internally used by the public interface

  -- Resets properties of nodes expanded during a search
  -- This is a lot faster than resetting all nodes
  -- between consecutive pathfinding requests

  --[[
    Looks for the neighbours of a given node.
    Returns its natural neighbours plus forced neighbours when the given
    node has no parent (generally occurs with the starting node).
    Otherwise, based on the direction of move from the parent, returns
    neighbours while pruning directions which will lead to symmetric paths.

    In case diagonal moves are forbidden, when the given node has no
    parent, we return straight neighbours (up, down, left and right).
    Otherwise, we add left and right node (perpendicular to the direction
    of move) in the neighbours list.
  --]]
  local function findNeighbours(finder, node, clearance)

    if node._parent then
      local neighbours = {}
      local x,y = node._x, node._y
      -- Node have a parent, we will prune some neighbours
      -- Gets the direction of move
      local dx = (x-node._parent._x)/max(abs(x-node._parent._x),1)
      local dy = (y-node._parent._y)/max(abs(y-node._parent._y),1)

        -- Diagonal move case
      if dx~=0 and dy~=0 then
        local walkY, walkX

        -- Natural neighbours
        if finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+dy)
          walkY = true
        end
        if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y)
          walkX = true
        end
        if walkX or walkY then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y+dy)
        end

        -- Forced neighbours
        if (not finder._grid:isWalkableAt(x-dx,y,finder._walkable, clearance)) and walkY then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x-dx,y+dy)
        end
        if (not finder._grid:isWalkableAt(x,y-dy,finder._walkable, clearance)) and walkX then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y-dy)
        end

      else
        -- Move along Y-axis case
        if dx==0 then
          local walkY
          if finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
            neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+dy)

            -- Forced neighbours are left and right ahead along Y
            if (not finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+1,y+dy)
            end
            if (not finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x-1,y+dy)
            end
          end
          -- In case diagonal moves are forbidden : Needs to be optimized
          if not finder._allowDiagonal then
            if finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+1,y)
            end
            if finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance)
              then neighbours[#neighbours+1] = finder._grid:getNodeAt(x-1,y)
            end
          end
        else
        -- Move along X-axis case
          if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) then
            neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y)

            -- Forced neighbours are up and down ahead along X
            if (not finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y+1)
            end
            if (not finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y-1)
            end
          end
          -- : In case diagonal moves are forbidden
          if not finder._allowDiagonal then
            if finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+1)
            end
            if finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y-1)
            end
          end
        end
      end
      return neighbours
    end

    -- Node do not have parent, we return all neighbouring nodes
    return finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel, clearance)
  end

  --[[
    Searches for a jump point (or a turning point) in a specific direction.
    This is a generic translation of the algorithm 2 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf
    The current expanded node is a jump point if near a forced node

    In case diagonal moves are forbidden, when lateral nodes (perpendicular to
    the direction of moves are walkable, we force them to be turning points in other
    to perform a straight move.
  --]]
  local function jump(finder, node, parent, endNode, clearance)
	if not node then return end

    local x,y = node._x, node._y
    local dx, dy = x - parent._x,y - parent._y

    -- If the node to be examined is unwalkable, return nil
    if not finder._grid:isWalkableAt(x,y,finder._walkable, clearance) then return end
		
    -- If the node to be examined is the endNode, return this node
    if node == endNode then return node end
    -- Diagonal search case
    if dx~=0 and dy~=0 then
      -- Current node is a jump point if one of his leftside/rightside neighbours ahead is forced
      if (finder._grid:isWalkableAt(x-dx,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x-dx,y,finder._walkable, clearance))) or
         (finder._grid:isWalkableAt(x+dx,y-dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y-dy,finder._walkable, clearance))) then
        return node
      end
    else
      -- Search along X-axis case
      if dx~=0 then
        if finder._allowDiagonal then
          -- Current node is a jump point if one of his upside/downside neighbours is forced
          if (finder._grid:isWalkableAt(x+dx,y+1,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance))) or
             (finder._grid:isWalkableAt(x+dx,y-1,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance) or finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance) then return node end
        end
      else
      -- Search along Y-axis case
        -- Current node is a jump point if one of his leftside/rightside neighbours is forced
        if finder._allowDiagonal then
          if (finder._grid:isWalkableAt(x+1,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance))) or
             (finder._grid:isWalkableAt(x-1,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance) or finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance) then return node end
        end
      end
    end

    -- Recursive horizontal/vertical search
    if dx~=0 and dy~=0 then
      if jump(finder,finder._grid:getNodeAt(x+dx,y),node,endNode, clearance) then return node end
      if jump(finder,finder._grid:getNodeAt(x,y+dy),node,endNode, clearance) then return node end
    end

    -- Recursive diagonal search
    if finder._allowDiagonal then
      if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) or finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
        return jump(finder,finder._grid:getNodeAt(x+dx,y+dy),node,endNode, clearance)
      end
    end
end

  --[[
    Searches for successors of a given node in the direction of each of its neighbours.
    This is a generic translation of the algorithm 1 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf

    Also, we notice that processing neighbours in a reverse order producing a natural
    looking path, as the pathfinder tends to keep heading in the same direction.
    In case a jump point was found, and this node happened to be diagonal to the
    node currently expanded in a straight mode search, we skip this jump point.
  --]]
  local function identifySuccessors(finder, openList, node, endNode, clearance, toClear)

    -- Gets the valid neighbours of the given node
    -- Looks for a jump point in the direction of each neighbour
    local neighbours = findNeighbours(finder,node, clearance)
    for i = #neighbours,1,-1 do

      local skip = false
      local neighbour = neighbours[i]
      local jumpNode = jump(finder,neighbour,node,endNode, clearance)
		
      -- : in case a diagonal jump point was found in straight mode, skip it.
      if jumpNode and not finder._allowDiagonal then
        if ((jumpNode._x ~= node._x) and (jumpNode._y ~= node._y)) then skip = true end
      end
		
      -- Performs regular A-star on a set of jump points
      if jumpNode and not skip then
        -- Update the jump node and move it in the closed list if it wasn't there
        if not jumpNode._closed then			
					local extraG = Heuristics.EUCLIDIAN(jumpNode, node)
					local newG = node._g + extraG
					if not jumpNode._opened or newG < jumpNode._g then
						toClear[jumpNode] = true -- Records this node to reset its properties later.
						jumpNode._g = newG
						jumpNode._h = jumpNode._h or
							(finder._heuristic(jumpNode, endNode))
						jumpNode._f = jumpNode._g+jumpNode._h
						jumpNode._parent = node
						if not jumpNode._opened then
							openList:push(jumpNode)
							jumpNode._opened = true
						else
							openList:heapify(jumpNode)
						end
					end					
				end
      end
    end
  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function(finder, startNode, endNode, clearance, toClear)

    startNode._g, startNode._f, startNode._h = 0,0,0
		local openList = Heap()
    openList:push(startNode)
    startNode._opened = true
    toClear[startNode] = true

    local node
    while not openList:empty() do
      -- Pops the lowest F-cost node, moves it in the closed list
      node = openList:pop()
      node._closed = true
        -- If the popped node is the endNode, return it
        if node == endNode then
          return node
        end
      -- otherwise, identify successors of the popped node
      identifySuccessors(finder, openList, node, endNode, clearance, toClear)
    end

    -- No path found, return nil
    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\thetastar.lua ---

-- ThetaStar implementation
-- See: http://aigamedev.com/open/tutorials/theta-star-any-angle-paths for reference

if (...) then
	
	local _PATH = (...):gsub('%.search.thetastar$','')

	-- Depandancies
	local Heuristics   = require (_PATH .. '.core.heuristics')
	local astar_search = require (_PATH .. '.search.astar')

	-- Internalization
	local ipairs = ipairs
	local huge, abs = math._huge, math.abs
	
	-- Line Of Sight (Bresenham's line marching algorithm)
	-- http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
	local lineOfSight = function (node, neighbour, finder, clearance)
		local x0, y0 = node._x, node._y
		local x1, y1 = neighbour._x, neighbour._y
		local dx = abs(x1-x0)
		local dy = abs(y1-y0)
		local err = dx - dy
		local sx = (x0 < x1) and 1 or -1
		local sy = (y0 < y1) and 1 or -1		

		while true do
			if not finder._grid:isWalkableAt(x0, y0, finder._walkable, finder._tunnel, clearance) then 
				return false 
			end
			if x0 == x1 and y0 == y1 then
				break
			end
			local e2 = 2*err
			if e2 > -dy then
				err = err - dy
				x0 = x0 + sx
			end
			if e2 < dx then
				err = err + dx
				y0 = y0 + sy
			end
		end
		return true
	end
	
	-- Theta star cost evaluation
	local function computeCost(node, neighbour, finder, clearance)
		local parent = node._parent or node
		local mpCost = Heuristics.EUCLIDIAN(neighbour, parent)
		if lineOfSight(parent, neighbour, finder, clearance) then
			if parent._g + mpCost < neighbour._g then
				neighbour._parent = parent
				neighbour._g = parent._g + mpCost
			end
		else
			local mCost = Heuristics.EUCLIDIAN(neighbour, node)
			if node._g + mCost < neighbour._g then
				neighbour._parent = node
				neighbour._g = node._g + mCost
			end
		end
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear, overrideHeuristic)
    return astar_search(finder, startNode, endNode, clearance, toClear, overrideHeuristic, computeCost)
	end

end


--- FILE: \lib\Jumper\specs\bheap_specs.lua ---

context('Module BHeap', function()	
	local BHeap 
	
	before(function()
		BHeap = require ('jumper.core.bheap')
	end)
	
	context('BHeap class', function()
	
		test('BHeap() instantiates a new heap object', function()
			assert_equal(getmetatable(BHeap()), BHeap)
		end)
		
		test('the new heap is empty', function()
			assert_true((BHeap()):empty())
		end)
		
		test('items can be pushed inside', function()
			local h = BHeap()
			h:push(1):push(2):push(3)
			assert_equal(h._size, 3)
		end)
		
		test('popping returns the lowest element by default (< operator)', function()
			local h = BHeap()
			h:push(1):push(2):push(0)
			
			assert_equal(h:pop(),0)
			assert_equal(h:pop(),1)
			assert_equal(h:pop(),2)
			assert_nil(h:pop())
		end)
		
		test('a heap can be cleared', function()
			local h = BHeap()
			assert_true(h:empty())
			
			h:push(1):push(2):push(3)
			assert_false(h:empty())
			
			h:clear()
			assert_true(h:empty())			
		end)
		
		test('one can define a custom sort function', function()
			local sort = function(a,b) return a>b end
			local h = BHeap(sort)
			h:push(1):push(2):push(3)
			
			assert_equal(h:pop(),3)
			assert_equal(h:pop(),2)
			assert_equal(h:pop(),1)
			assert_nil(h:pop())
		end)		

		test('items pushed can be objects, with a custom sort function', function()
			local sortNode = function(a, b) return a.cost < b.cost end
			local makeObj = function(cost) return {cost = cost} end
			local h = BHeap(sortNode)
			h:push(makeObj(1)):push(makeObj(2)):push(makeObj(3))
			
			assert_equal(h:pop().cost,1)
			assert_equal(h:pop().cost,2)
			assert_equal(h:pop().cost,3)
			assert_nil(h:pop())					
		end)
		
		test('pushing a alue that cannot be compared to the previous ones raises an error', function()
			local h = BHeap()
			h:push(false)
			assert_error(pcall(h.push, h, false))
			assert_error(pcall(h.push, h, true))		
			assert_error(pcall(h.push, h, {}))		
			assert_error(pcall(h.push, h, function() end))		
		end)
		
		test('pushing nil does nothing', function()
			local h = BHeap()
			h:push()
			
			assert_true(h:empty())
			h:push(1):push()
			
			assert_false(h:empty())
			assert_equal(h._size,1)
		end)
		
		test('popping an empty heap returns nil', function()
			local h = BHeap()
			assert_nil(h:pop())		
		end)
		
		test('BHeap:heapify() forces a sort of the heap', function()
		
			local h = BHeap()
			local sort = function(a,b) return a.value < b.value end
			local function makeObj(v) return {value = v} end
			local h = BHeap(sort)
			local A, B, C = makeObj(1), makeObj(2), makeObj(3)
			
			h:push(A):push(B):push(C)
			C.value = 0
			h:heapify(C)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,0)
			
			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,1)

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			h:push(A):push(B):push(C)
			C.value, B.value, A.value = 3, 2, 100
			h:heapify()

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,3)

			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,100)
		
		end)
		
		
	end)
	
end)


--- FILE: \lib\Jumper\specs\grid_specs.lua ---

context('Module Grid', function()
	local Grid, Node
	
	before(function()
		Grid = require ('jumper.grid')
		Node = require ('jumper.core.node')
  end)
	
  context('Grid:new() or Grid() returns a new Grid object', function()
		
		test('Grid:new() or Grid() returns a new Grid object', function()
			assert_equal(getmetatable(getmetatable(Grid:new({{0}}))),Grid)
			assert_equal(getmetatable(getmetatable(Grid({{0}}))),Grid)
		end)
			
		test('Grid:new() requires a collision map upon initialization', function()
			local map = {{0,0},{0,0}}
			assert_not_nil(Grid:new(map))
		end)
			
		test('The passed-in map can be a string', function()
			local map = '00\n00'
			assert_not_nil(Grid:new(map))
		end)
			
		test('passing nil to Grid:new() or Grid() causes an error', function()
			assert_error(pcall(Grid, Grid))
			assert_error(pcall(Grid.new, Grid))
		end)			
			
		test('Grid and map should have the same width', function()
			local map = '00\n00'
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map)
			assert_equal(grid:getWidth(), 2)
			assert_equal(grid2:getWidth(), 2)	
		end)	
		
		test('Grid and map should have the same height', function()
			local map = '00\n00\n00'
			local map2 = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map2)
			assert_equal(grid:getHeight(), 3)
			assert_equal(grid2:getHeight(), 4)	
		end)
		
		test('Grid:getBounds() returns the grid corners coordinates', function()
			local map = {{0,0,0},{0,0,0},{0,0,0},{0,0,0}}
			local grid = Grid(map)
			local lx,ly,rx,ry = grid:getBounds()
			assert_equal(lx,1)
			assert_equal(ly,1)
			assert_equal(rx,3)
			assert_equal(ry,4)
			
			local map = {}
			for y = 0,2 do map[y] = {}
				for x = 0,2 do map[y][x] = 0 end
			end
			grid = Grid(map)
			local lx,ly,rx,ry = grid:getBounds()
			assert_equal(lx,0)
			assert_equal(ly,0)
			assert_equal(rx,2)
			assert_equal(ry,2)			
		end)
		
		test('Each value on the map matches a node on the grid', function()
			local map = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			
			for y in pairs(map) do
				for x in pairs(map[y]) do
					local node = grid:getNodeAt(x,y)
					assert_not_nil(node)
					assert_equal(getmetatable(node), Node)
				end
			end
		end)
		
		test('the passed-in map should have a width greather than 0',function()
			assert_error(pcall(Grid, Grid, {{},{}}))
			assert_error(pcall(Grid, Grid, '\n\n'))
		end)

		test('the passed-in map should have a height greather than 0',function()
			assert_error(pcall(Grid, Grid, {}))
			assert_error(pcall(Grid, Grid, ''))
		end)
		
		test('the passed-in map should have rows with the same width',function()
			assert_error(pcall(Grid, Grid, {{0},{0,0}}))
			assert_error(pcall(Grid, Grid, '00\n000'))
		end)

		test('values in the map should only be integers or strings',function()
			assert_error(pcall(Grid, Grid, {{0.1,0,0},{0,0,0}}))
			assert_error(pcall(Grid, Grid, {{0,function() end,0},{0,0,0}}))
		end)
		
	end)
	
	context('Grid types', function()
		
		test('passing a 2nd arg to Grid:new() or Grid() returns a safe-memory grid', function()
			local grid = Grid({{0}})
			local pgrid = Grid({{0}},true)
			assert_not_equal(getmetatable(grid), getmetatable(pgrid))
			assert_equal(getmetatable(getmetatable(grid)), getmetatable(getmetatable(pgrid)))
		end)
		
		test('those grids are memory safe, as nodes are cached on purpose', function()
			local map = {{0,0,0},{0,0,0},{0,0,0}}
			local pgrid = Grid(map, true)
			
			assert_equal(#pgrid:getNodes(), 0)
			local count = 0
			for node in pgrid:iter() do
				assert_equal(getmetatable(node), Node)
				count = count+1
			end
			assert_equal(count, pgrid:getWidth()*pgrid:getHeight())
		end)
		
	end)
	
	context('Grid:isWalkablkeAt', function()
		
			test('returns whether or not a node is walkable',function()
				local map = {{0,0},{0,0},{0,1},{0,0}}
				local grid = Grid(map)			
				local walkable = 1
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						if map[y][x] == walkable then
							assert_true(grid:isWalkableAt(x,y,walkable))
						else
							assert_false(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
				map = 'WXW\nWWW\n'
				grid = Grid(map)			
				walkable = 'W'
				
				for y = 1,2 do
					for x = 1,3 do
						if x==2 and y==1 then
							assert_false(grid:isWalkableAt(x,y,walkable))
						else
							assert_true(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
			end)

			test('All nodes are walkable when no walkability rule was set', function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						assert_true(grid:isWalkableAt(x,y,walkable))
					end
				end
			end)
	
	end)
		
	context('Grid:getMap()', function()
		
			test('returns the collision map',function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				assert_equal(grid:getMap(), map)
			end)
		
			test('returns the array parsed from a given string',function()
				local map = '00\n00'
				local grid = Grid(map)
				assert_equal(type(grid:getMap()), 'table')
				assert_not_equal(grid:getMap(), map)
			end)
		
	end)
	
	context('Grid:getNodeAt()', function()
			local map, grid
			before(function()
				map = {
					{0,0,0,0},
					{0,0,0,0},
				}
				grid = Grid(map)
      end)
			
			test('returns the node at a given position', function()
				local node = grid:getNodeAt(1,1)
				assert_equal(getmetatable(node),Node)
				assert_equal(node._x,1)
				assert_equal(node._y,1)
			end)
			
			test('returns nil if the node does not exist', function()
				assert_nil(grid:getNodeAt(0,0))
				assert_nil(grid:getNodeAt(5,1))
			end)

			test('returns nil if one of its args is missing', function()
				assert_nil(grid:getNodeAt(0))
				assert_nil(grid:getNodeAt())
			end)			
		
	end)
		
	context('Grid:getNodes()', function()
	
		test('returns the array of nodes', function()
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local nodes = grid:getNodes()
			
			assert_equal(type(nodes), 'table')	
			for y in pairs(nodes) do
				for x in pairs(nodes[y]) do
					assert_equal(getmetatable(nodes[y][x]),Node)
				end
			end 
		end)
	
	end)
	
	context('grid:getNeighbours()', function()
		
			test('returns neighbours of a given node', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable = 0
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 2)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
			end)
			
			test('passing true as a third arg includes ajacent nodes', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable, allowDiag = 0, true
				
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable, allowDiag)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 3)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
				assert_equal(nb[3], grid:getNodeAt(2,2))
			end)

			test('passing arg tunnel includes adjacent nodes that cannot be reached diagonnally', function()
				local map = {{0,0,0},{1,0,0},{0,2,0}}
				local grid = Grid(map)
				local walkable, allowDiag, tunnel = 0, true, true
				
				local node = grid:getNodeAt(1,3)
				local nb = grid:getNeighbours(node, walkable, allowDiag, tunnel)
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 1)
				assert_equal(nb[1], grid:getNodeAt(2,2))				
			end)
			
	end)
		
	context('Grid:iter()', function()
			
			test('iterates on all nodes in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
			
			test('can iterate only on a rectangle of nodes', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter(2,2,3,3) do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])					
					assert_gte(n._x, 2)
					assert_gte(n._y, 2)
					assert_lte(n._x, 3)
					assert_lte(n._y, 3)
					assert_nil(record[n])
					record[n] = true
				end
			end)			
			
	end)
	
	context('Grid:around()', function()
			
			test('iterates on nodes following a square outline pattern', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(2,2),1) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)
			
			test('arg spacing defaults to 1 when not given', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(2,2)) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)

			test('skips unexisting nodes', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{2,1},{2,2},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(1,1)) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)				
		
	end)	
		
	context('Grid:each()', function()
			
			test('calls a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:each(f, 3)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n.value,3)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)
		
	context('Grid:eachRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:eachRange(1,1,2,2,f,3)
				for n in grid:iter() do
					if n._x <= 2 and n._y <= 2 then
						assert_equal(n.value,3)
					else
						assert_nil(n.value)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
		
	context('Grid:imap()', function()
			
			test('Maps a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imap(f, 5)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n.v,5)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)

	context('Grid:imapRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}				
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imapRange(3,3,4,4,f,7)
				for n in grid:iter() do
					if n._x >= 3 and n._y >= 3 then
						assert_equal(n.v,7)
					else
						assert_nil(n.v)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
	
end)


--- FILE: \lib\Jumper\specs\heuristics_specs.lua ---

context('Module Heuristics', function()
	local H, Node
	
	before(function()
		H = require ('jumper.core.heuristics')
		Node = require ('jumper.core.node')
  end)
	
  context('MANHATTAN distance', function()
	
    test('is a function',function()
			assert_type(H.MANHATTAN, 'function')
    end)
	
		test('evaluates as |dx|+|dy|', function()
			assert_equal(H.MANHATTAN(Node(0,0), Node(0,0)), 0)
			assert_equal(H.MANHATTAN(Node(1,1), Node(1,3)), 2)
			assert_equal(H.MANHATTAN(Node(0,0), Node(2,1)), 3)
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.MANHATTAN,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.MANHATTAN))
		end)		
		
  end)

  context('EUCLIDIAN distance', function()
	
    test('is a function',function()
			assert_type(H.EUCLIDIAN, 'function')
    end)
	
		test('evaluates as SQUAREROOT(dx*dx + dy*dy)', function()
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(0,0)), 0)
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(2,2)), math.sqrt(8))
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(5,3)), math.sqrt(34))		
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.EUCLIDIAN,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.EUCLIDIAN))
		end)		
		
  end)
  
	context('DIAGONAL distance', function()
	
    test('is a function',function()
			assert_type(H.DIAGONAL, 'function')
    end)
	
		test('evaluates as MAX(|dx|+|dy|)', function()
			assert_equal(H.DIAGONAL(Node(0,0), Node(0,0)), 0)
			assert_equal(H.DIAGONAL(Node(0,0), Node(2,2)), 2)
			assert_equal(H.DIAGONAL(Node(0,0), Node(1,2)), 2)
			assert_equal(H.DIAGONAL(Node(0,0), Node(3,1)), 3)	
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.DIAGONAL,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.DIAGONAL))
		end)		
		
  end)

	context('CARDINTCARD distance', function()
	
    test('is a function',function()
			assert_type(H.CARDINTCARD, 'function')
    end)
		
		test('evaluates as (SQRT(2)-1)*MIN(|dx|+|dy|)+MAX(|dx|+|dy|)', function()
			assert_equal(H.CARDINTCARD(Node(0,0), Node(0,0)), 0)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(1,1))-(math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(1,2))-(1+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(-3,1))-(2+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(2,2))-(2*math.sqrt(2)),1e-6)
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.CARDINTCARD,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.CARDINTCARD))
		end)		
		
  end)
	
end)


--- FILE: \lib\Jumper\specs\node_specs.lua ---

context('Module Node', function()
	local Node
	
	before(function()
		Node = require ('jumper.core.node')
  end)
	
  context('The Node Class', function()
	
    test('Node:new() or Node() returns a Node object',function()
			assert_equal(getmetatable(Node:new(0,0)),Node)
			assert_equal(getmetatable(Node(0,0)),Node)
    end)
	
		test('A Node has x and y attributes', function()
			local node = Node:new(1,3)
			assert_equal(node._x, 1)
			assert_equal(node._y, 3)
		end)
		
		test('x and y attributes can be retrieved through methods', function()
			local node = Node:new(5,6)
			assert_equal(node:getX(), 5)
			assert_equal(node:getY(), 6)
			
			local x, y = node:getPos()
			assert_equal(x, 5)
			assert_equal(y, 6)
		end)		
		
		test('Nodes can be compared, if they both have an F-cost', function()
		  local nodeA, nodeB = Node(1,2), Node(1,2)
			nodeA._f, nodeB._f = 1, 2
			assert_less_than(nodeA, nodeB)
			
			nodeA._f = 3
			assert_less_than(nodeB, nodeA)
		end)	
		
  end)

end)


--- FILE: \lib\Jumper\specs\pathfinder_specs.lua ---

context('Module Pathfinder', function()
	local PF, H, Grid, Path, map, grid
	
	before(function()
		PF = require ('jumper.pathfinder')
		Grid = require ('jumper.grid')
		H = require ('jumper.core.heuristics')
		Path = require ('jumper.core.path')
		map = {{0,0,0},{0,0,0},{0,0,0}}
		grid = Grid(map)
  end)
	
  context('Pathfinder:new() or Pathfinder()', function()
		
		test('Inits a new Pathfinder object', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR')), PF)
			assert_equal(getmetatable(PF:new(grid, 'ASTAR')), PF)
		end)
		
		test('First arg is a grid object', function()
			assert_error(pcall(PF, PF))
			assert_error(pcall(PF, PF, map))
			assert_equal(getmetatable(PF(grid)), PF)
		end)
		
		test('Second arg, when given must be a valid finderName', function()
			assert_error(pcall(PF, PF, grid, 'finder'))
			for i, finder in ipairs(PF:getFinders()) do
				assert_equal(getmetatable(PF(grid, finder)), PF)
			end
		end)
		
		test('Defaults to \'ASTAR\' when not given', function()
			local pf = PF(grid)
			assert_equal(getmetatable(pf), PF)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Third arg walkable can be a string, function, int or nil', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR', 'A')), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', function() end)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', 1)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', nil)), PF)
			assert_error(pcall(PF, PF, grid, 'ASTAR', 2.2))
			assert_error(pcall(PF, PF, grid, 'ASTAR', {}))
		end)
		
	end)
	
	context('Pathfinder:getGrid()', function()
		
		test('returns the grid object used by the Pathfinder', function()
			local pf = PF(grid)
			assert_equal(pf:getGrid(), grid)
		end)
		
	end)
	
	context('Pathfinder:setGrid()', function()
	
		test('Sets the grid object on which the Pathfinder performs', function()
			local pf = PF(grid)
			local newGrid = Grid('00000\n00000')
			
			assert_equal(pf:getGrid(), grid)
			pf:setGrid(newGrid)
			assert_equal(pf:getGrid(), newGrid)
		end)
		
		test('passing nil raises an error', function()
			local pf = PF(grid)
			assert_error(pcall(pf.setGrid, pf, nil))
		end)
		
	end)
	
	context('Pathfinder:getWalkable()', function()
	
		test('returns the walkable parameter', function()
			local pf = PF(grid, 'ASTAR', 1)
			assert_equal(pf:getWalkable(), 1)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
	end)
	
	context('Pathfinder:setWalkable()', function()
	
		test('sets the string, function, nil or int walkable value', function()
			local pf = PF(grid, 'ASTAR')
			assert_nil(pf:getWalkable())
			
			pf:setWalkable('A')
			assert_equal(pf:getWalkable(), 'A')
			
			pf:setWalkable(2)
			assert_equal(pf:getWalkable(), 2)
			
			local f = function() end
			pf:setWalkable(f)
			assert_equal(pf:getWalkable(), f)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
		test('raises an error when passed-in value is not a string, int, nil or function', function()
			local pf = PF(grid)			
			assert_error(pcall(pf.setWalkable, pf, {}))
			assert_error(pcall(pf.setWalkable, pf, 0.4))
		end)
		
	end)	
	
	context('Pathfinder:getFinder()', function()
		
		test('returns the finder name used', function()
			local pf = PF(grid, 'JPS')
			assert_equal(pf:getFinder(), 'JPS')
		end)
		
	end)
	
	context('Pathfinder:setFinder()', function()

		test('sets the finder to be used', function()
			local pf = PF(grid)
			pf:setFinder('DFS')
			assert_equal(pf:getFinder(), 'DFS')
		end)
		
		test('Upon init, the default finder, when not given, is \'ASTAR\'', function()
			local pf = PF(grid)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)

		test('Passing nil sets \'ASTAR\` as the finder if no previous finder was set, is \'ASTAR\'', function()
			local pf = PF(grid)
			pf:setFinder()
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Passing nil has no effect if a finder was set previously', function()
			local pf = PF(grid, 'JPS')
			pf:setFinder()
			assert_equal(pf:getFinder(), 'JPS')
		end)			
	
	end)
	
	context('Pathfinder:getFinders()', function()
		
		test('returns the list of all existing finders', function()
			local fs = PF:getFinders()
			local pf = PF(grid)
			
			assert_greater_than(#fs, 0)
			for i,finder in ipairs(fs) do
				pf:setFinder(finder)
				assert_equal(pf:getFinder(), finder)
			end
		end)
		
	end)
	
	context('Pathfinder:getHeuristic()', function()
		
		test('returns the heuristic function used', function()
			local pf = PF(grid)
			assert_not_nil(pf:getHeuristic())
		end)
		
		test('default heuristic is \'MANHATTAN\'', function()
			local pf = PF(grid)
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
	end)
	
	context('Pathfinder:setHeuristic()', function()
		
		test('sets the heuristic function to be used', function()
			local pf = PF(grid)
			pf:setHeuristic('MANHATTAN')
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
		test('handles custom heuristic functions', function()
			local pf = PF(grid)
			local f = function() end
			pf:setHeuristic(f)
			assert_equal(pf:getHeuristic(),f)
		end)
		
		test('passing nil produces an error',function()
			local pf = PF(grid)
			assert_error(pcall(pf.setHeuristic, pf))
		end)
		
	end)

	context('Pathfinder:getHeuristics()', function()
		
		test('returns all available heuristics', function()
			local hs = PF:getHeuristics()
			assert_greater_than(#hs, 0)
			local pf = PF(grid)
			for i, heur in ipairs(hs) do
				pf:setHeuristic(heur)
				assert_equal(pf:getHeuristic(), H[heur])
			end
		end)
		
	end)
	
	context('Pathfinder:getMode()', function()
	
		test('returns the actual search mode', function()
			local pf = PF(grid)
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(),'DIAGONAL')
		end)

		test('default search mode is  \'DIAGONAL\'', function()
			local pf = PF(grid)
			assert_equal(pf:getMode(),'DIAGONAL')
		end)
		
	end)
	
	context('Pathfinder:setMode()', function()
		
		test('sets the search mode', function()
			local pf = PF(grid)		
			pf:setMode('ORTHOGONAL')
			assert_equal(pf:getMode(), 'ORTHOGONAL')
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(), 'DIAGONAL')	
		end)
		
		test('passing nil or any other invalid arg causes an error', function()
			local pf = PF(grid)		
			
			assert_error(pcall(pf.setMode, pf))		
			assert_error(pcall(pf.setMode, pf, 'ORTHO'))		
			assert_error(pcall(pf.setMode, pf, function() end))	
		end)
		
	end)
	
	context('Pathfinder:getModes()', function()
		
		test('returns all available modes', function()
			local ms = PF:getModes()
			assert_equal(#ms, 2)
			local pf = PF(grid)
			
			for i, mode in ipairs(ms) do
				pf:setMode(mode)
				assert_equal(pf:getMode(),mode)
			end
		end)
		
	end)
		
	context('Pathfinder:setTunnelling()', function()
		
		test('Enables or disables tunnelling feature', function()
			PF:setTunnelling(true)
			assert_true(PF:getTunnelling())
			PF:setTunnelling(false)
			assert_false(PF:getTunnelling())
		end)
		
		test('Enables or disables tunnelling feature', function()
			PF:setTunnelling(true)
			assert_true(PF:getTunnelling())
			PF:setTunnelling(false)
			assert_false(PF:getTunnelling())
		end)
		
		test('When on, finder goes through walls heading diagonally', function()
			local map = {{0,0,0},{1,0,0},{0,2,0}}
			local grid = Grid(map)
			local finder = PF(grid, 'ASTAR',0)
			finder:setTunnelling(true)
			local path = finder:getPath(1,3,3,1)
			assert_equal(path._nodes[1]._x,1)
			assert_equal(path._nodes[1]._y,3)
			assert_equal(path._nodes[2]._x,2)
			assert_equal(path._nodes[2]._y,2)
			assert_equal(path._nodes[3]._x,3)
			assert_equal(path._nodes[3]._y,1)			
		end)
		
	end)
	
	context('Pathfinder:getTunnelling()', function()
		
		test('Returns the actual state of tunnelling feature', function()
			assert_false(PF:getTunnelling())
		end)
		
	end)

	context('Pathfinder:annotateGrid()', function()
		
		test('Calculates clearance for the entire grid', function()
			local map = {
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,1,0,0,0,0,0,0},
			{0,0,1,0,0,0,0,0,2,0},
			{0,0,1,1,1,0,0,2,0,0},
			{0,0,0,1,1,0,2,0,0,2},
			{0,0,0,0,1,0,0,0,0,2},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0}
		}
		local clearances = {
			{6,6,5,5,4,4,4,3,2,1},
			{6,5,5,4,4,3,3,3,2,1},
			{6,5,4,4,3,3,2,2,2,1},
			{6,5,4,3,3,2,2,1,1,1},
			{6,5,4,3,2,2,1,1,0,1},
			{5,5,4,3,2,1,1,0,1,1},
			{4,4,4,3,2,1,0,2,1,0},
			{3,3,3,3,3,3,3,2,1,0},
			{2,2,2,2,2,2,2,2,2,1},
			{1,1,1,1,1,1,1,1,1,1}
		}
		local grid = Grid(map)
		local walkable = function(v) return v~=2 end
		local finder = PF(grid, 'ASTAR', walkable)
		finder:annotateGrid()
		for node in grid:iter() do
			assert_equal(node:getClearance(walkable), clearances[node._y][node._x])
		end			
		end)
		
	end)

	context('Pathfinder:clearAnnotations()', function()
		
		test('Clears cached clearance values for the entire grid', function()
			local map = {{0,1,0},{0,0,0},{1,1,0}}
			local grid = Grid(map)
			local walkable = 0
			local finder = PF(grid, 'ASTAR', walkable)
			finder:annotateGrid()
			finder:clearAnnotations()
			for node in grid:iter() do
				assert_nil(node:getClearance(walkable))
			end			
		end)
		
	end)
	
	context('Pathfinder:getPath()', function()
		
		test('returns a path', function()
			local pf = PF(grid, 'ASTAR', 0)
			local path = pf:getPath(1,1,3,3)
			assert_equal(getmetatable(path), Path)
		end)
		
		test('start and end locations must exist on the map', function()
			local pf = PF(grid, 'ASTAR', 0)
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
			assert_error(pcall(pf.getPath, pf, 1, 1, 4, 4))
			assert_error(pcall(pf.getPath, pf, 0,0, 4, 4))
		end)
		
		test('goal location must be walkable', function()
			local pf = PF(grid, 'ASTAR', 0)
			map[3][3] = 1
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
		end)
		
	end)	
	
end)


--- FILE: \lib\Jumper\specs\path_specs.lua ---

context('Module Path', function()
	local Path, Node
	
	before(function()
		Path = require ('jumper.core.path')
		Node = require ('jumper.core.node')
  end)
	
  context('The Path Class', function()
	
    test('Path:new() or Path() returns a Path object',function()
			assert_equal(getmetatable(Path:new()),Path)
			assert_equal(getmetatable(Path()),Path)
    end)
		
    test('Path:iter() iterates on nodes forming the path',function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(getmetatable(node), Node)
				assert_equal(node._x, i)
				assert_equal(node._y, i)
				assert_equal(count, i)
			end
    end)		
		
		test('Path:iter() is aliased as Path:nodes()',function()
			assert_equal(Path.iter, Path.nodes)
		end)
		
		test('Path:getLength() returns the length of the path', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,0) end
			assert_equal(p:getLength(),9)
			
			p = Path()
			for j = 1,10 do p._nodes[#p._nodes+1] = Node(0,j) end
			assert_equal(p:getLength(),9)

			p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			assert_less_than(p:getLength()-9*math.sqrt(2),1e-6)			
		end)
		
		test('Path:fill() interpolates a path', function()
			local p = Path()
			for i = 1,9,2 do p._nodes[#p._nodes+1] = Node(i,i) end
			p._grid = {getNodeAt = function(self,x,y) return {_x = x, _y = y} end}
			p:fill()
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(node._x, i)
				assert_equal(node._y, i)
				assert_equal(count, i)
			end			
			
		end)
		
		test('Interpolation does not affect the total path length', function()
			local p = Path()
			for i = 1,10,3 do p._nodes[#p._nodes+1] = Node(i,i) end
			local len = p:getLength()
			p._grid = {getNodeAt = function(self,x,y) return {_x = x, _y = y} end}			
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		

		test('Path:filter() compresses a path', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			p:filter()
			
			assert_equal(p._nodes[1]._x,1)
			assert_equal(p._nodes[1]._y,1)
			assert_equal(p._nodes[2]._x,10)
			assert_equal(p._nodes[2]._y,10)
			for i = 3,10 do
				assert_nil(p._nodes[i])
			end
			
		end)

		test('Compression does not affect the total path length', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			local len = p:getLength()
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		
		
  end)

end)


--- FILE: \src\main_game.lua ---

-- src/main_game.lua
local Gamestate = require "lib.hump.gamestate"

function love.load()
    Gamestate.registerEvents()
    Gamestate.switch(require("src.states.MenuState"))
end


--- FILE: \src\entities\Ally.lua ---

---Modulos
local Sprite = require("src.systems.Sprite")
local animation = require("src.systems.animation")

local allyTypes = {
    ["soldado"] = {
        speed = 50, health = 100, cost = 10, damage = 10, color = {0, 0.8, 0},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"1/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"1/Attack.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"1/Preattack.png", 48, 48, 1)
        -- )
    },
    ["tank"]    = {
        speed = 30, health = 300, cost = 30, damage = 25, color = {0.8, 0, 0},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"2/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"2/Attack.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"2/Preattack.png", 48, 48, 1)
        -- )
    },
    ["ninja"]   = {
        speed = 80, health = 70,  cost = 15, damage = 5,  color = {0, 0, 0.8},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"3/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"3/Attack.png", 72, 48, 1),
        -- animation:newAnimation(spritePath+"3/Preattack.png", 48, 48, 1)
        -- )
    },
}

---Início do módulo de aliados
local Ally = {
}
Ally.__index = Ally

-- Define os tipos de aliados com seus atributos


-- Construtor do Ally
function Ally.create(type, x, y)
    local stats = allyTypes[type]
    assert(stats, "Tipo de aliado inválido: " .. tostring(type))

    local allySpritePath = string.format("assets/allies/defenders/%s/", type)
    local ally = {
        type = type,
        x = x,
        y = y,
        speed = stats.speed,
        health = stats.health,
        maxHealth = stats.health,
        damage = stats.damage,
        cost = stats.cost,
        color = stats.color,
        alive = true,
        attackCooldown = 1,  -- 1 segundo entre ataques
        timeSinceAttack = 0,
        sprite = Sprite:newSprite(
            animation:newAnimation(allySpritePath.."Idle.png", 48, 48, 1),
            animation:newAnimation(allySpritePath.."Attack.png", 48, 48, 1),
            animation:newAnimation(allySpritePath.."Preattack.png", 48, 48, 1),
            true
        ),
    }

    return setmetatable(ally, Ally)
end

-- Atualiza posição e ataque
function Ally:update(dt, enemies)
    if not self.alive then return end

    self.sprite:update(dt)
    self.timeSinceAttack = self.timeSinceAttack + dt

    -- Verifica se há inimigos próximos para atacar
    local attacked = false
    for _, enemy in ipairs(enemies) do
        if enemy.alive and math.abs(self.x - enemy.x) < 25 then
            -- Atacar se estiver perto o suficiente
            if self.timeSinceAttack >= self.attackCooldown then
                -- self.sprite:setState(Sprite.attack)
                enemy:takeDamage(self.damage)
                self.timeSinceAttack = 0
            end
            else
                self.sprite:setState(Sprite.attack)
                attacked = true
            break
        end
    end

    -- Se não atacou, continua andando
    if not attacked then
        self.x = self.x + self.speed * dt
        self.sprite:setState(Sprite.idle)
    end
end

-- Desenha aliado e barra de vida
function Ally:draw()
    if not self.alive then return end

    -- Corpo
    -- love.graphics.setColor(self.color)
    -- love.graphics.rectangle("fill", self.x, self.y, 20, 20)
    self.sprite:draw(self.x, self.y)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", self.x, self.y - 5, 20, 3)

    love.graphics.setColor(0, 1, 0)
    local lifeWidth = (self.health / self.maxHealth) * 20
    love.graphics.rectangle("fill", self.x, self.y - 5, lifeWidth, 3)

    -- Reset cor
    love.graphics.setColor(1, 1, 1)
end

-- Sofrer dano
function Ally:takeDamage(dmg)
    self.health = self.health - dmg
    if self.health <= 0 then
        self.alive = false
    end
end

-- Retorna o custo do tipo
function Ally.getCost(type)
    return type and allyTypes[type].cost or math.huge
end

return Ally


--- FILE: \src\entities\Enemy.lua ---

-- src/entities/Enemy.lua

-- 1. Importa a classe base Unit
local Unit = require("src.entities.Unit")

-- 2. Cria a classe Enemy e a faz herdar de Unit
local Enemy = {}
setmetatable(Enemy, {__index = Unit})
Enemy.__index = Enemy

-- Tabela de atributos com o valor da recompensa ('reward')
local enemyTypes = {
    ["soldado"] = { speed = 50, health = 100, cost = 10, damage = 10, color = {0.8, 0.5, 0}, reward = 5 },
    ["tank"]    = { speed = 30, health = 300, cost = 30, damage = 25, color = {0.5, 0.2, 0.2}, reward = 15 },
    ["ninja"]   = { speed = 80, health = 70,  cost = 15, damage = 5,  color = {0.3, 0.3, 0.3}, reward = 10 },
}

-- Construtor do Enemy
function Enemy.create(type, x, y)
    local stats = enemyTypes[type]
    assert(stats, "Tipo de inimigo inválido: " .. tostring(type))

    local config = {
        x = x, y = y,
        speed = stats.speed,
        health = stats.health,
        damage = stats.damage,
        cost = stats.cost,
        color = stats.color
    }

    local enemy = Unit:new(config)
    setmetatable(enemy, Enemy)
    enemy.type = type
    
    -- Garante que a recompensa seja armazenada na instância do inimigo
    enemy.reward = stats.reward or 0
    
    return enemy
end

-- Atualiza a lógica do Enemy
function Enemy:update(dt, allies, structure)
    if not self.alive then return end

    self.timeSinceAttack = self.timeSinceAttack + dt
    local attacked = false

    -- Prioridade 1: Atacar aliados próximos
    for _, ally in ipairs(allies) do
        if ally.alive and math.abs(self.x - ally.x) < 25 then
            if self.timeSinceAttack >= self.attackCooldown then
                ally:takeDamage(self.damage)
                self.timeSinceAttack = 0
            end
            attacked = true
            break
        end
    end

    -- Prioridade 2: Se não atacou um aliado, verifica se pode atacar a estrutura
    if not attacked and structure and structure.alive and math.abs(self.x - structure.x) < 40 then
        if self.timeSinceAttack >= self.attackCooldown then
            structure:takeDamage(self.damage)
            self.timeSinceAttack = 0
        end
        attacked = true
    end

    -- Se não atacou ninguém, continua andando para a esquerda
    if not attacked then
        self.x = self.x - self.speed * dt
    end
end

-- Função estática para obter o custo
function Enemy.getCost(type)
    return enemyTypes[type] and enemyTypes[type].cost or math.huge
end

-- ######################################################################
-- A LINHA MAIS IMPORTANTE DO ARQUIVO!
-- Garante que o 'require' receba a tabela 'Enemy' e não 'true'.
-- ######################################################################
return Enemy


--- FILE: \src\entities\Projectile.lua ---

-- Conceito para Projectile.lua
local Projectile = {}

function Projectile.create(x, y, target, damage)
    -- ...
    -- Calcula a velocidade em direção ao alvo
    local angle = math.atan2(target.y - y, target.x - x)
    proj.velocityX = math.cos(angle) * speed
    proj.velocityY = math.sin(angle) * speed
    -- ...
end

function Projectile:update(dt)
    self.x = self.x + self.velocityX * dt
    self.y = self.y + self.velocityY * dt
    -- Lógica de colisão com alvos
end


--- FILE: \src\entities\Structure.lua ---

-- Structure.lua
local Sprite = require("src.systems.Sprite")
local animation = require("src.systems.animation")

local Structure = {}
Structure.__index = Structure

-- Tipos de estruturas pré-definidas (pode expandir depois)
local StructureTypes = {
    ["base"] = { width = 32, height = 128, health = 200, cost = 50, attackDamage = 0, attackRange = 0, attackSpeed = 0, color = {1, 1, 1} },
    -- Você pode adicionar mais tipos aqui no futuro
}

-- Construtor
function Structure.create(type, x, y)
    local stats = StructureTypes[type]
    assert(stats, "Tipo de estrutura inválido: " .. tostring(type))

    local structurePath = "assets/allies/tower/"
    local structure = {
        type = type,
        x = x,
        y = y,
        width = stats.width,
        height = stats.height,
        health = stats.health,
        maxHealth = stats.health,
        cost = stats.cost,
        alive = true,
        attackDamage = stats.attackDamage,
        attackRange = stats.attackRange,
        attackSpeed = stats.attackSpeed,
        timeSinceLastAttack = 0,
        color = stats.color,
        sprite = Sprite:newSprite(
        animation:newAnimation(structurePath.."1.png", 70, 130, 1),
        animation:newAnimation(structurePath.."2.png", 70, 130, 1),
        animation:newAnimation(structurePath.."3.png", 70, 130, 1),
        true
    )
    }

    return setmetatable(structure, Structure)
end

-- Atualiza estrutura
function Structure:update(dt)
    if not self.alive then return end

    self.sprite:update(dt)

    if self.attackDamage > 0 and self.attackRange > 0 then
        self.timeSinceLastAttack = self.timeSinceLastAttack + dt
        if self.timeSinceLastAttack >= (1 / self.attackSpeed) then
            self:performAttack()
            self.timeSinceLastAttack = 0
        end
    end

    if self.health <= 0 then
        self.health = 0
        self.alive = false
        self:onDeath()
    end
end

-- Desenha estrutura e vida
function Structure:draw()
    if not self.alive then return end

    self.sprite:draw(self.x, self.y)

    -- Barra de vida
    local barWidth = 40
    local barHeight = 5
    local currentWidth = (self.health / self.maxHealth) * barWidth
    love.graphics.setColor(0.2, 0.2, 0.2, 0.8)
    love.graphics.rectangle("fill", self.x - barWidth / 2, self.y - 5 / 2 - 10, barWidth, barHeight)
    love.graphics.setColor(0, 1, 0)
    love.graphics.rectangle("fill", self.x - barWidth / 2, self.y - 5 / 2 - 10, currentWidth, barHeight)

    love.graphics.setColor(1, 1, 1) -- Reset cor
end

-- Recebe dano
function Structure:takeDamage(amount)
    if not self.alive then return end

    self.health = self.health - amount
    if self.health <= 0 then
        self.health = 0
        self.alive = false
        self:onDeath()
    end
end

-- Ataque (placeholder)
function Structure:performAttack()
    -- Implementação futura se quiser ataque automático
end

-- Ao morrer
function Structure:onDeath()
    print(self.type .. " at (" .. self.x .. ", " .. self.y .. ") has been destroyed!")
end

-- Custo
function Structure.getCost(type)
    return StructureTypes[type] and StructureTypes[type].cost or math.huge
end

return Structure


--- FILE: \src\entities\Unit.lua ---

-- src/entities/Unit.lua
local Unit = {}
Unit.__index = Unit

function Unit:new(config)
    local unit = {}
    
    unit.x = config.x or 0
    unit.y = config.y or 0
    unit.speed = config.speed or 50
    unit.health = config.health or 100
    unit.maxHealth = config.health or 100
    unit.damage = config.damage or 10
    unit.cost = config.cost or 0
    unit.color = config.color or {1, 1, 1}
    unit.alive = true
    unit.attackCooldown = 1
    unit.timeSinceAttack = 0

    return setmetatable(unit, self)
end

function Unit:takeDamage(dmg)
    self.health = self.health - dmg
    if self.health <= 0 then
        self.health = 0
        self.alive = false
    end
end

function Unit:draw()
    if not self.alive then return end

    -- Corpo
    love.graphics.setColor(self.color)
    love.graphics.rectangle("fill", self.x, self.y, 20, 20)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", self.x, self.y - 5, 20, 3)

    love.graphics.setColor(0, 1, 0)
    local lifeWidth = (self.health / self.maxHealth) * 20
    love.graphics.rectangle("fill", self.x, self.y - 5, lifeWidth, 3)

    love.graphics.setColor(1, 1, 1)
end

-- Outras funções que são comuns a Ally e Enemy podem vir aqui.

return Unit


--- FILE: \src\states\BaseState.lua ---



--- FILE: \src\states\GameOverState.lua ---

local Gamestate = require "lib.hump.gamestate"

local gameover = {}

function gameover:load()
end

function gameover:draw()
    love.graphics.printf("GAME OVER - Pressione Espaço para Voltar ao Menu", 0, 300, love.graphics.getWidth(), "center")
end

function gameover:keypressed(key)
    if key == "space" then
        Gamestate.switch(require("src.states.MenuState"))
    end
end

return gameover


--- FILE: \src\states\MenuState.lua ---

local Gamestate = require "lib.hump.gamestate"
local menu = {}
menu.__index = menu


function menu:loadAssets()
    Background = love.graphics.newImage("assets/background/menu_1.png")
end

function menu:load()
    menu:loadAssets()
    return menu
end

function menu:draw()
    love.graphics.draw(Background, 0, 0)
    love.graphics.printf("MENU - Pressione Enter para Jogar", 0, 300, love.graphics.getWidth(), "center")
end

function menu:keypressed(key)
    if key == "return" then
        Gamestate.switch(require("src.states.PlayState"):load())
    end
end

return menu:load()


--- FILE: \src\states\PlayState.lua ---

-- src/states/PlayState.lua
local Gamestate = require "lib.hump.gamestate"

local Ally = require("src.entities.Ally")
local Enemy = require("src.entities.Enemy")
local Structure = require("src.entities.Structure")
local Button = require("src.ui.Button")

local PlayState = {}
PlayState.__index = PlayState

-- ############### NOVA FUNÇÃO AUXILIAR ###############
-- Esta função cria/recria os botões do painel de upgrade.
-- Ela será chamada apenas quando precisarmos atualizar a UI dos upgrades.
function PlayState:rebuildUpgradeUI()
    self.uiUpgradeElements = {} -- Limpa a lista antiga
    if not self.isUpgradePanelOpen then return end -- Se o painel está fechado, não faz nada

    local yPos = 120
    for key, upgrade in pairs(self.upgrades) do
        local cost = math.floor(upgrade.baseCost * (upgrade.costMultiplier ^ upgrade.level))
        local text = upgrade.name .. " (Lvl " .. upgrade.level .. ")\nCusto: $" .. cost
        
        local currentKey = key
        local btn = Button.create(200, yPos, love.graphics.getWidth() - 400, 60, text, function()
            self:purchaseUpgrade(currentKey)
        end)
        
        table.insert(self.uiUpgradeElements, btn)
        yPos = yPos + 80
    end
end
-- ######################################################

function PlayState:load()
    local state = {
        allies = {},
        enemies = {},
        structures = {},
        uiSpawnElements = {},
        uiUpgradeElements = {}, -- Começa vazia
        isUpgradePanelOpen = false,
        money = 150,
        enemySpawnTimer = 0,
        enemySpawnInterval = 5
    }
    setmetatable(state, PlayState)

    state.upgrades = {
        soldierDamage = { name = "Dano Soldado", level = 0, baseCost = 50, costMultiplier = 1.6, value = 5 },
        income = { name = "Renda Passiva", level = 0, baseCost = 100, costMultiplier = 2, value = 2 },
        baseHealth = { name = "Vida da Base", level = 0, baseCost = 75, costMultiplier = 1.8, value = 250 }
    }

    local playerStructure = Structure.create("base", 80, love.graphics.getHeight() - 198)
    table.insert(state.structures, playerStructure)

    local function spawnAlly(allyType)
        local bonusDamage = state.upgrades.soldierDamage.level * state.upgrades.soldierDamage.value
        local bonusHealth = 0
        local allyCost = Ally.getCost(allyType)
        if state.money >= allyCost then
            table.insert(state.allies, Ally.create(allyType, 120, love.graphics.getHeight() - 100, bonusDamage, bonusHealth))
            state.money = state.money - allyCost
        end
    end

    table.insert(state.uiSpawnElements, Button.create(10, 100, 120, 40, "Soldado", function() spawnAlly("soldado") end))
    table.insert(state.uiSpawnElements, Button.create(10, 150, 120, 40, "Tank", function() spawnAlly("tank") end))
    table.insert(state.uiSpawnElements, Button.create(10, 200, 120, 40, "Ninja", function() spawnAlly("ninja") end))
    
    -- ############### MUDANÇA NA LÓGICA DO BOTÃO ###############
    -- Agora, além de mudar a flag, ele chama a função para construir a UI.
    table.insert(state.uiSpawnElements, Button.create(10, 280, 120, 50, "UPGRADES", function()
        state.isUpgradePanelOpen = not state.isUpgradePanelOpen
        state:rebuildUpgradeUI()
    end))

    return state
end

function PlayState:purchaseUpgrade(upgradeType)
    local upgrade = self.upgrades[upgradeType]
    if not upgrade then return end
    local cost = math.floor(upgrade.baseCost * (upgrade.costMultiplier ^ upgrade.level))

    if self.money >= cost then
        self.money = self.money - cost
        upgrade.level = upgrade.level + 1

        if upgradeType == "baseHealth" then
            local structure = self.structures[1]
            structure.maxHealth = structure.maxHealth + upgrade.value
            structure.health = structure.health + upgrade.value
        end
        print("Upgrade '" .. upgrade.name .. "' comprado! Nível: " .. upgrade.level)
        
        -- ############### ATUALIZA A UI APÓS A COMPRA ###############
        self:rebuildUpgradeUI()
    else
        print("Dinheiro insuficiente para o upgrade: " .. upgrade.name)
    end
end

function PlayState:update(dt)
    -- print("No início do update, o tipo de Enemy é: " .. type(Enemy)) -- <<< ADICIONE ESTA LINHA

    local playerStructure = self.structures[1]
    if not playerStructure.alive then
        Gamestate.switch(require("src.states.GameOverState"))
        return
    end

    if not self.isUpgradePanelOpen then
        playerStructure:update(dt)

        -- Atualiza aliados
        for i = #self.allies, 1, -1 do
            local ally = self.allies[i]
            ally:update(dt, self.enemies)
            if not ally.alive or ally.x > love.graphics.getWidth() then
                table.remove(self.allies, i)
            end
        end

        -- Atualiza inimigos
        for i = #self.enemies, 1, -1 do
            local enemy = self.enemies[i] -- Note o 'e' minúsculo, que é o correto.
            enemy:update(dt, self.allies, playerStructure)

            -- Verifica se o inimigo morreu ou saiu da tela
            if not enemy.alive or enemy.x < 0 then
                -- Se o inimigo foi derrotado (e não apenas saiu da tela), dá a recompensa.
                if not enemy.alive then
                    self.money = self.money + (enemy.reward or 0)
                end
                -- Remove o inimigo do jogo
                table.remove(self.enemies, i)
            end
        end

        -- Lógica de economia e spawn
        local incomeValue = 5 + (self.upgrades.income.level * self.upgrades.income.value)
        self.money = self.money + incomeValue * dt
        
        self.enemySpawnTimer = self.enemySpawnTimer + dt
        if self.enemySpawnTimer >= self.enemySpawnInterval then
            self:spawnEnemy()
            self.enemySpawnTimer = 0
        end
    end
    
    -- Atualiza UI
    for _, element in ipairs(self.uiSpawnElements) do element:update(dt) end
    if self.isUpgradePanelOpen then
        for _, element in ipairs(self.uiUpgradeElements) do element:update(dt) end
    end
end

function PlayState:draw()
    love.graphics.clear(0.4, 0.5, 0.6)

    for _, s in ipairs(self.structures) do s:draw() end
    for _, a in ipairs(self.allies) do a:draw() end
    for _, e in ipairs(self.enemies) do e:draw() end

    local incomeValue = 5 + (self.upgrades.income.level * self.upgrades.income.value)
    love.graphics.print("Dinheiro: $" .. math.floor(self.money), 10, 10)
    love.graphics.print("Renda: $" .. incomeValue .. "/s", 10, 30)
    for _, element in ipairs(self.uiSpawnElements) do element:draw() end
    
    -- ############### FUNÇÃO DRAW SIMPLIFICADA ###############
    -- Agora ela apenas desenha, sem criar nada.
    if self.isUpgradePanelOpen then
        love.graphics.setColor(0, 0, 0, 0.7)
        love.graphics.rectangle("fill", 150, 50, love.graphics.getWidth() - 300, love.graphics.getHeight() - 100)
        love.graphics.setColor(1, 1, 1)
        love.graphics.printf("Painel de Upgrades", 150, 60, love.graphics.getWidth() - 300, "center")
        
        for _, element in ipairs(self.uiUpgradeElements) do element:draw() end
    end

    love.graphics.setColor(1, 1, 1)
end

function PlayState:mousepressed(x, y, button)
    if button ~= 1 then return end

    if self.isUpgradePanelOpen then
        for _, element in ipairs(self.uiUpgradeElements) do element:mousepressed(x, y, button) end
    end
    for _, element in ipairs(self.uiSpawnElements) do element:mousepressed(x, y, button) end
end

function PlayState:keypressed(key)
    if key == "escape" then
        Gamestate.switch(require("src.states.MenuState"))
    end
end

function PlayState:spawnEnemy()
    print("No início do spawnEnemy, o tipo de Enemy é: " .. type(Enemy)) -- <<< ADICIONE ESTA LINHA

    local enemyTypes = {"soldado", "tank", "ninja"}
    local randomType = enemyTypes[love.math.random(#enemyTypes)]
    local x = love.graphics.getWidth() + 20
    local y = love.graphics.getHeight() - 100
    
    -- Esta linha usa 'Enemy' (maiúsculo), que é a referência correta ao módulo.
    table.insert(self.enemies, Enemy.create(randomType, x, y))
end

return PlayState


--- FILE: \src\systems\animation.lua ---

---@class Animation
---@field spriteSheet love.Image
---@field quads table
---@field duration number
---@field currentTime number
local Animation = {}
Animation.__index = Animation


---@param imagePath string
---@param width integer
---@param height integer
---@param duration integer
---@return Animation obj
function Animation:newAnimation(imagePath, width, height, duration)
    local image = love.graphics.newImage(imagePath)
    local obj = {
        spriteSheet = image,
        quads = {}
    }
    setmetatable(obj, Animation)
    for y = 0, image:getHeight() - height, height do
        for x = 0, image:getWidth() - width, width do
            table.insert(obj.quads, love.graphics.newQuad(x, y, width, height, image:getDimensions()))
        end
    end

    obj.duration = duration or 1
    obj.currentTime = 0
    return obj
end

function Animation:_draw(x, y, flipped)
    local spriteNum = math.floor(self.currentTime / self.duration * #self.quads) + 1
    if spriteNum > #self.quads then spriteNum = #self.quads end
    local quad = self.quads[spriteNum]
    local sx = flipped and -1 or 1
    local ox = 0
    if flipped then
        local _, _, w, _ = quad:getViewport()
        ox = w
    end
    love.graphics.draw(self.spriteSheet, quad, x + ox, y, 0, sx, 1)
end


function Animation:_update(dt)
    self.currentTime = self.currentTime + dt
    if self.currentTime >= self.duration then
        self.currentTime = self.currentTime - self.duration
    end
end

function Animation:reset() self.currentTime = 0 end

return Animation


--- FILE: \src\systems\CollisionHandler.lua ---



--- FILE: \src\systems\Sprite.lua ---

---@class Sprite
---@field currentState number
---@field flipped boolean
local Sprite = {
    idle = 1, attack = 2, preAttack = 3
}
Sprite.__index = Sprite


---@param idle Animation
---@param attack Animation
---@param preAttack Animation
---@param flipped boolean
---@return Sprite
function Sprite:newSprite(idle, attack, preAttack, flipped)
    local obj = {
        idle,
        attack,
        preAttack,
        currentState = Sprite.idle,
        flipped = flipped
    }
    setmetatable(obj, Sprite)
    return obj
end

---@param state integer
function Sprite:setState(state)
    if self.currentState ~= state then
        self[self.currentState]:reset()
        self.currentState = state
    end
end

function Sprite:draw(x, y)
    self[self.currentState]:_draw(x, y, self.flipped)
end

function Sprite:update(dt)
    self[self.currentState]:_update(dt)
end

return Sprite


--- FILE: \src\systems\WaveManager.lua ---

-- Conceito para WaveManager.lua
local WaveManager = {}
-- ... (código do construtor)

function WaveManager:update(dt, enemies)
    if self.waveInProgress then
        -- Lógica de spawnar inimigos da wave atual
    elseif #enemies == 0 then
        -- Todos os inimigos morreram, inicia timer para próxima wave
        self.timer = self.timer + dt
        if self.timer > self.timeBetweenWaves then
            self:startNextWave()
        end
    end
end

function WaveManager:startNextWave()
    self.waveNumber = self.waveNumber + 1
    -- Aumenta a dificuldade: mais inimigos, inimigos mais fortes, etc.
end


--- FILE: \src\ui\Button.lua ---

-- src/ui/Button.lua
local Button = {}
Button.__index = Button

function Button.create(x, y, width, height, text, onClick)
    local btn = {
        x = x, y = y,
        width = width, height = height,
        text = text or "",
        onClick = onClick or function() end,
        isHovered = false
    }
    return setmetatable(btn, Button)
end

function Button:update(dt)
    local mx, my = love.mouse.getPosition()
    self.isHovered = mx > self.x and mx < self.x + self.width and
                     my > self.y and my < self.y + self.height
end

function Button:draw()
    if self.isHovered then
        love.graphics.setColor(0.5, 0.5, 0.5) -- Cinza quando hover
    else
        love.graphics.setColor(0.3, 0.3, 0.3) -- Cinza escuro normal
    end
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    
    love.graphics.setColor(1, 1, 1)
    love.graphics.printf(self.text, self.x, self.y + self.height / 4, self.width, "center")
end

function Button:mousepressed(x, y, button)
    if button == 1 and self.isHovered then
        self.onClick()
    end
end

return Button


--- FILE: \src\ui\Shop.lua ---



--- FILE: \src\utils\math.lua ---



--- FILE: \conf.lua ---

function love.conf(t)
	t.title = "Archer vs Mage"
	t.window.icon = "assets/icon.png"
	t.version = "11.5"
	t.window.width = 800
	t.window.height = 600
	t.console = true


	-- t.window.minheight = 500
	-- t.window.minwidth = 500
	-- t.window.resizable = true
	-- t.window.borderless = true
	-- t.window.vsync = 1
	-- t.window.display = 2
	-- t.window.fullscreen = true
end


--- FILE: \main.lua ---

local game = require("src/main_game")


--- FILE: \lib\bump.lua ---



--- FILE: \lib\anim8\anim8.lua ---

local anim8 = {
  _VERSION     = 'anim8 v2.3.1',
  _DESCRIPTION = 'An animation library for LÖVE',
  _URL         = 'https://github.com/kikito/anim8',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique García Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local Grid = {}

local _frames = {}

local function assertPositiveInteger(value, name)
  if type(value) ~= 'number' then error(("%s should be a number, was %q"):format(name, tostring(value))) end
  if value < 1 then error(("%s should be a positive number, was %d"):format(name, value)) end
  if value ~= math.floor(value) then error(("%s should be an integer, was %f"):format(name, value)) end
end

local function createFrame(self, x, y)
  local fw, fh = self.frameWidth, self.frameHeight
  return love.graphics.newQuad(
    self.left + (x-1) * fw + x * self.border,
    self.top  + (y-1) * fh + y * self.border,
    fw,
    fh,
    self.imageWidth,
    self.imageHeight
  )
end

local function getGridKey(...)
  return table.concat( {...} ,'-' )
end

local function getOrCreateFrame(self, x, y)
  if x < 1 or x > self.width or y < 1 or y > self.height then
    error(("There is no frame for x=%d, y=%d"):format(x, y))
  end
  local key = self._key
  _frames[key]       = _frames[key]       or {}
  _frames[key][x]    = _frames[key][x]    or {}
  _frames[key][x][y] = _frames[key][x][y] or createFrame(self, x, y)
  return _frames[key][x][y]
end

local function parseInterval(str)
  if type(str) == "number" then return str,str,1 end
  str = str:gsub('%s', '') -- remove spaces
  local min, max = str:match("^(%d+)-(%d+)$")
  assert(min and max, ("Could not parse interval from %q"):format(str))
  min, max = tonumber(min), tonumber(max)
  local step = min <= max and 1 or -1
  return min, max, step
end

function Grid:getFrames(...)
  local result, args = {}, {...}
  local minx, maxx, stepx, miny, maxy, stepy

  for i=1, #args, 2 do
    minx, maxx, stepx = parseInterval(args[i])
    miny, maxy, stepy = parseInterval(args[i+1])
    for y = miny, maxy, stepy do
      for x = minx, maxx, stepx do
        result[#result+1] = getOrCreateFrame(self,x,y)
      end
    end
  end

  return result
end

local Gridmt = {
  __index = Grid,
  __call  = Grid.getFrames
}

local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)
  assertPositiveInteger(frameWidth,  "frameWidth")
  assertPositiveInteger(frameHeight, "frameHeight")
  assertPositiveInteger(imageWidth,  "imageWidth")
  assertPositiveInteger(imageHeight, "imageHeight")

  left   = left   or 0
  top    = top    or 0
  border = border or 0

  local key  = getGridKey(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)

  local grid = setmetatable(
    { frameWidth  = frameWidth,
      frameHeight = frameHeight,
      imageWidth  = imageWidth,
      imageHeight = imageHeight,
      left        = left,
      top         = top,
      border      = border,
      width       = math.floor(imageWidth/frameWidth),
      height      = math.floor(imageHeight/frameHeight),
      _key        = key
    },
    Gridmt
  )
  return grid
end

-----------------------------------------------------------

local Animation = {}

local function cloneArray(arr)
  local result = {}
  for i=1,#arr do result[i] = arr[i] end
  return result
end

local function parseDurations(durations, frameCount)
  local result = {}
  if type(durations) == 'number' then
    for i=1,frameCount do result[i] = durations end
  else
    local min, max, step
    for key,duration in pairs(durations) do
      assert(type(duration) == 'number', "The value [" .. tostring(duration) .. "] should be a number")
      min, max, step = parseInterval(key)
      for i = min,max,step do result[i] = duration end
    end
  end

  if #result < frameCount then
    error("The durations table has length of " .. tostring(#result) .. ", but it should be >= " .. tostring(frameCount))
  end

  return result
end

local function parseIntervals(durations)
  local result, time = {0},0
  for i=1,#durations do
    time = time + durations[i]
    result[i+1] = time
  end
  return result, time
end

local Animationmt = { __index = Animation }
local nop = function() end

local function newAnimation(frames, durations, onLoop)
  local td = type(durations);
  if (td ~= 'number' or durations <= 0) and td ~= 'table' then
    error("durations must be a positive number. Was " .. tostring(durations) )
  end
  onLoop = onLoop or nop
  durations = parseDurations(durations, #frames)
  local intervals, totalDuration = parseIntervals(durations)
  return setmetatable({
      frames         = cloneArray(frames),
      durations      = durations,
      intervals      = intervals,
      totalDuration  = totalDuration,
      onLoop         = onLoop,
      timer          = 0,
      position       = 1,
      status         = "playing",
      flippedH       = false,
      flippedV       = false
    },
    Animationmt
  )
end

function Animation:clone()
  local newAnim = newAnimation(self.frames, self.durations, self.onLoop)
  newAnim.flippedH, newAnim.flippedV = self.flippedH, self.flippedV
  return newAnim
end

function Animation:flipH()
  self.flippedH = not self.flippedH
  return self
end

function Animation:flipV()
  self.flippedV = not self.flippedV
  return self
end

local function seekFrameIndex(intervals, timer)
  local high, low, i = #intervals-1, 1, 1

  while(low <= high) do
    i = math.floor((low + high) / 2)
    if     timer >= intervals[i+1] then low  = i + 1
    elseif timer <  intervals[i]   then high = i - 1
    else
      return i
    end
  end

  return i
end

function Animation:update(dt)
  if self.status ~= "playing" then return end

  self.timer = self.timer + dt
  local loops = math.floor(self.timer / self.totalDuration)
  if loops ~= 0 then
    self.timer = self.timer - self.totalDuration * loops
    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]
    f(self, loops)
  end

  self.position = seekFrameIndex(self.intervals, self.timer)
end

function Animation:pause()
  self.status = "paused"
end

function Animation:gotoFrame(position)
  self.position = position
  self.timer = self.intervals[self.position]
end

function Animation:pauseAtEnd()
  self.position = #self.frames
  self.timer = self.totalDuration
  self:pause()
end

function Animation:pauseAtStart()
  self.position = 1
  self.timer = 0
  self:pause()
end

function Animation:resume()
  self.status = "playing"
end

function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)
  love.graphics.draw(image, self:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky))
end

function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)
  local frame = self.frames[self.position]
  if self.flippedH or self.flippedV then
    r,sx,sy,ox,oy,kx,ky = r or 0, sx or 1, sy or 1, ox or 0, oy or 0, kx or 0, ky or 0
    local _,_,w,h = frame:getViewport()

    if self.flippedH then
      sx = sx * -1
      ox = w - ox
      kx = kx * -1
      ky = ky * -1
    end

    if self.flippedV then
      sy = sy * -1
      oy = h - oy
      kx = kx * -1
      ky = ky * -1
    end
  end
  return frame, x, y, r, sx, sy, ox, oy, kx, ky
end

function Animation:getDimensions()
  local _,_,w,h = self.frames[self.position]:getViewport()
  return w,h
end

-----------------------------------------------------------

anim8.newGrid       = newGrid
anim8.newAnimation  = newAnimation

return anim8


--- FILE: \lib\anim8\spec\love-mocks.lua ---

-- mocks for LÖVE functions
local unpack = _G.unpack or table.unpack

local Quadmt = {
  __eq = function(a,b)
    if #a ~= #b then return false end
    for i,v in ipairs(a) do
      if b[i] ~= v then return false end
    end
    return true
  end,
  __tostring = function(self)
    local buffer = {}
    for i,v in ipairs(self) do
      buffer[i] = tostring(v)
    end
    return "quad: {" .. table.concat(buffer, ",") .. "}"
  end,
  getViewport = function(self)
    return unpack(self)
  end
}

Quadmt.__index = Quadmt

_G.love = {
  graphics = {
    newQuad = function(...)
      return setmetatable({...}, Quadmt)
    end,
    draw = function()
    end,
    getLastDrawq = function()
    end
  }
}


--- FILE: \lib\anim8\spec\anim8\animation_spec.lua ---

require 'spec.love-mocks'

local anim8        = require 'anim8'
local newAnimation = anim8.newAnimation

describe("anim8", function()
  describe("newAnimation", function()

    it("Throws an error if durations is not a positive number or a table", function()
      assert.error(function() newAnimation({}, 'foo') end)
      assert.error(function() newAnimation({}, -1)    end)
      assert.error(function() newAnimation({}, 0)     end)
    end)

    it("sets the basic stuff", function()
      local a = newAnimation({1,2,3}, 4)
      assert.equal(0,         a.timer)
      assert.equal(1,         a.position)
      assert.equal("playing", a.status)
      assert.same({1,2,3}, a.frames)
      assert.same({4,4,4}, a.durations)
      assert.same({0,4,8,12}, a.intervals)
      assert.equal(12, a.totalDuration)
    end)
    it("makes a clone of the frame table", function()
      local frames = {1,2,3}
      local a = newAnimation(frames, 4)
      assert.same(frames, a.frames)
      assert.not_equal (frames, a.frames)
    end)

    describe("when parsing the durations", function()
      it("reads a simple array", function()
        local a = newAnimation({1,2,3,4}, {5,6,7,8})
        assert.same({5,6,7,8}, a.durations)
      end)
      it("reads a hash with strings or numbers", function()
        local a = newAnimation({1,2,3,4}, {['1-3']=1, [4]=4})
        assert.same({1,1,1,4}, a.durations)
      end)
      it("reads mixed-up durations", function()
        local a = newAnimation({1,2,3,4}, {5, ['2-4']=2})
        assert.same({5,2,2,2}, a.durations)
      end)
      describe("when given erroneous imput", function()
        it("throws errors for keys that are not integers or strings", function()
          assert.error(function() newAnimation({1}, {[{}]=1}) end)
          assert.error(function() newAnimation({1}, {[print]=1}) end)
          assert.error(function() newAnimation({1}, {print}) end)
        end)
        it("throws errors when frames are missing durations", function()
          assert.error(function() newAnimation({1,2,3,4,5}, {["1-3"]=1}) end)
          assert.error(function() newAnimation({1,2,3,4,5}, {1,2,3,4}) end)
        end)
      end)
    end)
  end)

  describe("Animation", function()
    describe(":update", function()
      it("moves to the next frame #focus", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(0.5)
        assert.equal(1, a.position)
        a:update(0.5)
        assert.equal(2, a.position)
      end)
      it("moves several frames if needed", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(2.1)
        assert.equal(3, a.position)
      end)

      describe("When the last frame is spent", function()
        it("goes back to the first frame in animations", function()
          local a = newAnimation({1,2,3,4}, 1)
          a:update(4.1)
          assert.equal(1, a.position)
        end)
      end)

      describe("When there are different durations per frame", function()
        it("moves the frame correctly", function()
          local a = newAnimation({1,2,3,4}, {1,2,1,1})
          a:update(1.1)
          assert.equal(2, a.position)
          a:update(1.1)
          assert.equal(2, a.position)
          a:update(1.1)
          assert.equal(3, a.position)
        end)
      end)

      describe("When the animation loops", function()
        it("invokes the onloop callback", function()
          local looped = false;
          local a = newAnimation({1,2,3}, 1, function() looped = true end)
          assert.False(looped)
          a:update(4)
          assert.True(looped)
        end)
        it("accepts the callback as a string", function()
          local a = newAnimation({1,2,3}, 1, 'foo')
          a.foo = function(self) self.looped = true end
          assert.Nil(a.looped)
          a:update(4)
          assert.True(a.looped)

        end)
        it("counts the loops", function()
          local count = 0;
          local a = newAnimation({1,2,3}, 1, function(_, x) count = count + x end)
          a:update(4)
          assert.equals(count, 1)
          a:update(7)
          assert.equals(count, 3)
        end)
        it("counts negative loops", function()
          local count = 0;
          local a = newAnimation({1,2,3}, 1, function(_, x) count = count + x end)
          a:update(-2)
          assert.equals(count, -1)
          a:update(-6)
          assert.equals(count, -3)
        end)
      end)
    end)

    describe(":pause", function()
      it("stops animations from happening", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:pause()
        a:update(1)
        assert.equal(2, a.position)
      end)
    end)

    describe(":resume", function()
      it("reanudates paused animations", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:pause()
        a:resume()
        a:update(1)
        assert.equal(3, a.position)
      end)
    end)

    describe(":gotoFrame", function()
      it("moves the position and time to the frame specified", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:gotoFrame(1)
        assert.equal(1, a.position)
        assert.equal(0, a.timer)
      end)
    end)

    describe(":pauseAtEnd", function()
      it("goes to the last frame, and pauses", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:pauseAtEnd()
        assert.equal(4, a.position)
        assert.equal(4, a.timer)
        assert.equal('paused', a.status)
      end)
    end)

    describe(":pauseAtStart", function()
      it("goes to the first frame, and pauses", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:pauseAtStart()
        assert.equal(1, a.position)
        assert.equal(0, a.timer)
        assert.equal('paused', a.status)
      end)
    end)

    describe(":draw", function()
      it("invokes love.graphics.draw with the expected parameters", function()
        spy.on(love.graphics, 'draw')
        local img, frame1, frame2, frame3 = {},{},{},{}
        local a   = newAnimation({frame1, frame2, frame3}, 1)
        a:draw(img, 1,2,3,4,5,6,7,8,9)
        assert.spy(love.graphics.draw).was.called_with(img, frame1, 1,2,3,4,5,6,7,8,9)
      end)
    end)

    describe(":clone", function()
      it("returns a new animation with the same properties - but reset to the initial frame", function()
        local frames = {1,2,3,4}
        local a = newAnimation(frames, 1)
        a:update(1)
        a:pause()
        local b = a:clone()
        assert.not_equal(frames, b.frames)
        assert.same(frames, b.frames)
        assert.same(a.durations, b.durations)
        assert.equal(0, b.timer)
        assert.equal(1, b.position)
        assert.equal("playing", b.status )

        assert.False(b.flippedH)
        assert.False(b.flippedV)

        a:flipV()
        assert.True(a:clone().flippedV)

        a:flipH()
        assert.True(a:clone().flippedH)

      end)
    end)

    describe(":getDimensions", function()
      it("returns the width and height of the current frame", function()
        local frame1 = love.graphics.newQuad(0,0,10,10)
        local frame2 = love.graphics.newQuad(0,0,20,30)
        local frame3 = love.graphics.newQuad(0,0,5,15)

        local a = newAnimation({frame1, frame2, frame3}, 1)

        assert.same({10,10}, {a:getDimensions()})
        a:update(1.1)
        assert.same({20,30}, {a:getDimensions()})
        a:update(1)
        assert.same({5,15}, {a:getDimensions()})
        a:update(1)
        assert.same({10,10}, {a:getDimensions()})
      end)
    end)

    describe(":flipH and :flipV", function()
      local img, frame, a
      before_each(function()
        spy.on(love.graphics, 'draw')
        img = {}
        frame = love.graphics.newQuad(1,2,3,4) -- x,y,width, height
        a     = newAnimation({frame}, 1)
      end)
      it("defaults to non-flipped", function()
        assert.False(a.flippedH)
        assert.False(a.flippedV)
      end)

      it("Flips the animation horizontally (does not create a clone)", function()
        a:flipH()
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, -5,6,3-7,8,-9,-10)

        assert.equal(a, a:flipH())
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,6,7,8,9,10)
      end)

      it("Flips the animation vertically (does not create a clone)", function()
        a:flipV()
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,-6,7,4-8,-9,-10)

        assert.equal(a, a:flipV())
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,6,7,8,9,10)
      end)
    end)
  end)
end)


--- FILE: \lib\anim8\spec\anim8\grid_spec.lua ---

require 'spec.love-mocks'

local anim8 = require 'anim8'

local newQuad   = love.graphics.newQuad
local newGrid   = anim8.newGrid

describe("anim8", function()

  describe("newGrid", function()
    it("throws error if any of its parameters is not a positive integer", function()
      assert.error(function() newGrid() end)
      assert.error(function() newGrid(1) end)
      assert.error(function() newGrid(1,1,1,-1) end)
      assert.error(function() newGrid(0,1,1,1) end)
      assert.error(function() newGrid(1,1,'a',1) end)
    end)

    it("preserves the values", function()
      local g = newGrid(1,2,3,4,5,6,7)
      assert.equal(1, g.frameWidth)
      assert.equal(2, g.frameHeight)
      assert.equal(3, g.imageWidth)
      assert.equal(4, g.imageHeight)
      assert.equal(5, g.left)
      assert.equal(6, g.top)
      assert.equal(7, g.border)
    end)

    it("calculates width and height", function()
      local g = newGrid(32,32,64,256)
      assert.equal(2, g.width)
      assert.equal(8, g.height)
    end)

    it("presets border and offsets to 0", function()
      local g = newGrid(32,32,64,256)
      assert.equal(0, g.left)
      assert.equal(0, g.top)
      assert.equal(0, g.border)
    end)
  end)

  describe("Grid", function()
    describe("getFrames", function()
      local g, nq
      before_each(function()
        g = newGrid(16,16,64,64)
        nq = function(x,y) return newQuad(x,y, 16,16, 64,64) end
      end)

      describe("with 2 integers", function()
        it("returns a single frame", function()
          assert.equal(nq(0,0), g:getFrames(1,1)[1])
        end)
        it("returns another single frame", function()
          assert.equal(nq(32,16), g:getFrames(3,2)[1])
        end)
        it("throws an error if the frame does not exist", function()
          assert.error(function() g:getFrames(10,10) end)
        end)
      end)

      describe("with several pairs of integers", function()
        it("returns a list of frames", function()
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(0,32), nq(16,16), nq(32,0)}, frames)
        end)
        it("takes into account border widths", function()
          g = newGrid(16,16,64,64,0,0,1)
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(1,35), nq(18,18), nq(35,1)}, frames)
        end)
        it("takes into account left and top", function()
          g = newGrid(16,16,64,64,10,20)
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(10,52), nq(26,36), nq(42,20)}, frames)
        end)
      end)

      describe("with a string and a integer", function()
        it("returns a list of frames", function()
          local frames = g:getFrames('1-2', 2)
          assert.equal(nq(0,16) , frames[1])
          assert.equal(nq(16,16), frames[2])
        end)
        it("throws an error for invalid strings", function()
          assert.error(function() g:getFrames('foo', 1) end)
          assert.error(function() g:getFrames('foo-bar', 1) end)
          assert.error(function() g:getFrames('1-foo', 1) end)
        end)
        it("throws an error for valid strings representing too big indexes", function()
          assert.error(function() g:getFrames('1000-1') end)
        end)
      end)

      describe("with several strings", function()
        it("returns a list of frames", function()
          local frames = g:getFrames('1-2',2, 3,2)
          assert.same({nq(0,16), nq(16,16), nq(32,16)}, frames)
        end)
        it("parses rows first, then columns", function()
          local frames = g:getFrames('1-3','1-3')
          assert.same({ nq(0,0),  nq(16,0),  nq(32,0),
                        nq(0,16), nq(16,16), nq(32,16),
                        nq(0,32), nq(16,32), nq(32,32)
                      },
                      frames)
        end)
        it("counts backwards if the first number in the string is greater than the second one", function()
          local frames = g:getFrames('3-1',2)
          assert.same({nq(32,16), nq(16,16), nq(0,16)}, frames)
        end)
      end)


      describe("with a non-number or string", function()
        it("throws an error", function()
          assert.error(function() g:getFrames({1,10}) end)
        end)
      end)

      describe("When two similar grids are requested for the same quad", function()
        it("is not created twice", function()
          local g2 = newGrid(16,16,64,64)
          local q1 = setmetatable(g:getFrames(1,1)[1], nil)
          local q2 = setmetatable(g2:getFrames(1,1)[1], nil)
          assert.equal(q1, q2)
        end)
      end)

    end)

    describe("()", function()
      it("is a shortcut to :getFrames", function()
        local g = newGrid(16,16,64,64)
        assert.equal(g:getFrames(1,1)[1], g(1,1)[1])
      end)
    end)
  end)
end)


--- FILE: \lib\bump.lua\bump.lua ---

local bump = {
  _VERSION     = 'bump v3.1.7',
  _URL         = 'https://github.com/kikito/bump.lua',
  _DESCRIPTION = 'A collision detection library for Lua',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2014 Enrique García Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

------------------------------------------
-- Auxiliary functions
------------------------------------------
local DELTA = 1e-10 -- floating-point margin of error

local abs, floor, ceil, min, max = math.abs, math.floor, math.ceil, math.min, math.max

local function sign(x)
  if x > 0 then return 1 end
  if x == 0 then return 0 end
  return -1
end

local function nearest(x, a, b)
  if abs(a - x) < abs(b - x) then return a else return b end
end

local function assertType(desiredType, value, name)
  if type(value) ~= desiredType then
    error(name .. ' must be a ' .. desiredType .. ', but was ' .. tostring(value) .. '(a ' .. type(value) .. ')')
  end
end

local function assertIsPositiveNumber(value, name)
  if type(value) ~= 'number' or value <= 0 then
    error(name .. ' must be a positive integer, but was ' .. tostring(value) .. '(' .. type(value) .. ')')
  end
end

local function assertIsRect(x,y,w,h)
  assertType('number', x, 'x')
  assertType('number', y, 'y')
  assertIsPositiveNumber(w, 'w')
  assertIsPositiveNumber(h, 'h')
end

local defaultFilter = function()
  return 'slide'
end

------------------------------------------
-- Rectangle functions
------------------------------------------

local function rect_getNearestCorner(x,y,w,h, px, py)
  return nearest(px, x, x+w), nearest(py, y, y+h)
end

-- This is a generalized implementation of the liang-barsky algorithm, which also returns
-- the normals of the sides where the segment intersects.
-- Returns nil if the segment never touches the rect
-- Notice that normals are only guaranteed to be accurate when initially ti1, ti2 == -math.huge, math.huge
local function rect_getSegmentIntersectionIndices(x,y,w,h, x1,y1,x2,y2, ti1,ti2)
  ti1, ti2 = ti1 or 0, ti2 or 1
  local dx, dy = x2-x1, y2-y1
  local nx, ny
  local nx1, ny1, nx2, ny2 = 0,0,0,0
  local p, q, r

  for side = 1,4 do
    if     side == 1 then nx,ny,p,q = -1,  0, -dx, x1 - x     -- left
    elseif side == 2 then nx,ny,p,q =  1,  0,  dx, x + w - x1 -- right
    elseif side == 3 then nx,ny,p,q =  0, -1, -dy, y1 - y     -- top
    else                  nx,ny,p,q =  0,  1,  dy, y + h - y1 -- bottom
    end

    if p == 0 then
      if q <= 0 then return nil end
    else
      r = q / p
      if p < 0 then
        if     r > ti2 then return nil
        elseif r > ti1 then ti1,nx1,ny1 = r,nx,ny
        end
      else -- p > 0
        if     r < ti1 then return nil
        elseif r < ti2 then ti2,nx2,ny2 = r,nx,ny
        end
      end
    end
  end

  return ti1,ti2, nx1,ny1, nx2,ny2
end

-- Calculates the minkowsky difference between 2 rects, which is another rect
local function rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)
  return x2 - x1 - w1,
         y2 - y1 - h1,
         w1 + w2,
         h1 + h2
end

local function rect_containsPoint(x,y,w,h, px,py)
  return px - x > DELTA      and py - y > DELTA and
         x + w - px > DELTA  and y + h - py > DELTA
end

local function rect_isIntersecting(x1,y1,w1,h1, x2,y2,w2,h2)
  return x1 < x2+w2 and x2 < x1+w1 and
         y1 < y2+h2 and y2 < y1+h1
end

local function rect_getSquareDistance(x1,y1,w1,h1, x2,y2,w2,h2)
  local dx = x1 - x2 + (w1 - w2)/2
  local dy = y1 - y2 + (h1 - h2)/2
  return dx*dx + dy*dy
end

local function rect_detectCollision(x1,y1,w1,h1, x2,y2,w2,h2, goalX, goalY)
  goalX = goalX or x1
  goalY = goalY or y1

  local dx, dy      = goalX - x1, goalY - y1
  local x,y,w,h     = rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)

  local overlaps, ti, nx, ny

  if rect_containsPoint(x,y,w,h, 0,0) then -- item was intersecting other
    local px, py    = rect_getNearestCorner(x,y,w,h, 0, 0)
    local wi, hi    = min(w1, abs(px)), min(h1, abs(py)) -- area of intersection
    ti              = -wi * hi -- ti is the negative area of intersection
    overlaps = true
  else
    local ti1,ti2,nx1,ny1 = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, math.huge)

    -- item tunnels into other
    if ti1
    and ti1 < 1
    and (abs(ti1 - ti2) >= DELTA) -- special case for rect going through another rect's corner
    and (0 < ti1 + DELTA
      or 0 == ti1 and ti2 > 0)
    then
      ti, nx, ny = ti1, nx1, ny1
      overlaps   = false
    end
  end

  if not ti then return end

  local tx, ty

  if overlaps then
    if dx == 0 and dy == 0 then
      -- intersecting and not moving - use minimum displacement vector
      local px, py = rect_getNearestCorner(x,y,w,h, 0,0)
      if abs(px) < abs(py) then py = 0 else px = 0 end
      nx, ny = sign(px), sign(py)
      tx, ty = x1 + px, y1 + py
    else
      -- intersecting and moving - move in the opposite direction
      local ti1, _
      ti1,_,nx,ny = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, 1)
      if not ti1 then return end
      tx, ty = x1 + dx * ti1, y1 + dy * ti1
    end
  else -- tunnel
    tx, ty = x1 + dx * ti, y1 + dy * ti
  end

  return {
    overlaps  = overlaps,
    ti        = ti,
    move      = {x = dx, y = dy},
    normal    = {x = nx, y = ny},
    touch     = {x = tx, y = ty},
    itemRect  = {x = x1, y = y1, w = w1, h = h1},
    otherRect = {x = x2, y = y2, w = w2, h = h2}
  }
end

------------------------------------------
-- Grid functions
------------------------------------------

local function grid_toWorld(cellSize, cx, cy)
  return (cx - 1)*cellSize, (cy-1)*cellSize
end

local function grid_toCell(cellSize, x, y)
  return floor(x / cellSize) + 1, floor(y / cellSize) + 1
end

-- grid_traverse* functions are based on "A Fast Voxel Traversal Algorithm for Ray Tracing",
-- by John Amanides and Andrew Woo - http://www.cse.yorku.ca/~amana/research/grid.pdf
-- It has been modified to include both cells when the ray "touches a grid corner",
-- and with a different exit condition

local function grid_traverse_initStep(cellSize, ct, t1, t2)
  local v = t2 - t1
  if     v > 0 then
    return  1,  cellSize / v, ((ct + v) * cellSize - t1) / v
  elseif v < 0 then
    return -1, -cellSize / v, ((ct + v - 1) * cellSize - t1) / v
  else
    return 0, math.huge, math.huge
  end
end

local function grid_traverse(cellSize, x1,y1,x2,y2, f)
  local cx1,cy1        = grid_toCell(cellSize, x1,y1)
  local cx2,cy2        = grid_toCell(cellSize, x2,y2)
  local stepX, dx, tx  = grid_traverse_initStep(cellSize, cx1, x1, x2)
  local stepY, dy, ty  = grid_traverse_initStep(cellSize, cy1, y1, y2)
  local cx,cy          = cx1,cy1

  f(cx, cy)

  -- The default implementation had an infinite loop problem when
  -- approaching the last cell in some occassions. We finish iterating
  -- when we are *next* to the last cell
  while abs(cx - cx2) + abs(cy - cy2) > 1 do
    if tx < ty then
      tx, cx = tx + dx, cx + stepX
      f(cx, cy)
    else
      -- Addition: include both cells when going through corners
      if tx == ty then f(cx + stepX, cy) end
      ty, cy = ty + dy, cy + stepY
      f(cx, cy)
    end
  end

  -- If we have not arrived to the last cell, use it
  if cx ~= cx2 or cy ~= cy2 then f(cx2, cy2) end

end

local function grid_toCellRect(cellSize, x,y,w,h)
  local cx,cy = grid_toCell(cellSize, x, y)
  local cr,cb = ceil((x+w) / cellSize), ceil((y+h) / cellSize)
  return cx, cy, cr - cx + 1, cb - cy + 1
end

------------------------------------------
-- Responses
------------------------------------------

local touch = function(world, col, x,y,w,h, goalX, goalY, filter)
  return col.touch.x, col.touch.y, {}, 0
end

local cross = function(world, col, x,y,w,h, goalX, goalY, filter)
  local cols, len = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local slide = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move  = col.touch, col.move
  if move.x ~= 0 or move.y ~= 0 then
    if col.normal.x ~= 0 then
      goalX = tch.x
    else
      goalY = tch.y
    end
  end

  col.slide = {x = goalX, y = goalY}

  x,y = tch.x, tch.y
  local cols, len  = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local bounce = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move = col.touch, col.move
  local tx, ty = tch.x, tch.y

  local bx, by = tx, ty

  if move.x ~= 0 or move.y ~= 0 then
    local bnx, bny = goalX - tx, goalY - ty
    if col.normal.x == 0 then bny = -bny else bnx = -bnx end
    bx, by = tx + bnx, ty + bny
  end

  col.bounce   = {x = bx,  y = by}
  x,y          = tch.x, tch.y
  goalX, goalY = bx, by

  local cols, len    = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

------------------------------------------
-- World
------------------------------------------

local World = {}
local World_mt = {__index = World}

-- Private functions and methods

local function sortByWeight(a,b) return a.weight < b.weight end

local function sortByTiAndDistance(a,b)
  if a.ti == b.ti then
    local ir, ar, br = a.itemRect, a.otherRect, b.otherRect
    local ad = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, ar.x,ar.y,ar.w,ar.h)
    local bd = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, br.x,br.y,br.w,br.h)
    return ad < bd
  end
  return a.ti < b.ti
end

local function addItemToCell(self, item, cx, cy)
  self.rows[cy] = self.rows[cy] or setmetatable({}, {__mode = 'v'})
  local row = self.rows[cy]
  row[cx] = row[cx] or {itemCount = 0, x = cx, y = cy, items = setmetatable({}, {__mode = 'k'})}
  local cell = row[cx]
  self.nonEmptyCells[cell] = true
  if not cell.items[item] then
    cell.items[item] = true
    cell.itemCount = cell.itemCount + 1
  end
end

local function removeItemFromCell(self, item, cx, cy)
  local row = self.rows[cy]
  if not row or not row[cx] or not row[cx].items[item] then return false end

  local cell = row[cx]
  cell.items[item] = nil
  cell.itemCount = cell.itemCount - 1
  if cell.itemCount == 0 then
    self.nonEmptyCells[cell] = nil
  end
  return true
end

local function getDictItemsInCellRect(self, cl,ct,cw,ch)
  local items_dict = {}
  for cy=ct,ct+ch-1 do
    local row = self.rows[cy]
    if row then
      for cx=cl,cl+cw-1 do
        local cell = row[cx]
        if cell and cell.itemCount > 0 then -- no cell.itemCount > 1 because tunneling
          for item,_ in pairs(cell.items) do
            items_dict[item] = true
          end
        end
      end
    end
  end

  return items_dict
end

local function getCellsTouchedBySegment(self, x1,y1,x2,y2)

  local cells, cellsLen, visited = {}, 0, {}

  grid_traverse(self.cellSize, x1,y1,x2,y2, function(cx, cy)
    local row  = self.rows[cy]
    if not row then return end
    local cell = row[cx]
    if not cell or visited[cell] then return end

    visited[cell] = true
    cellsLen = cellsLen + 1
    cells[cellsLen] = cell
  end)

  return cells, cellsLen
end

local function getInfoAboutItemsTouchedBySegment(self, x1,y1, x2,y2, filter)
  local cells, len = getCellsTouchedBySegment(self, x1,y1,x2,y2)
  local cell, rect, l,t,w,h, ti1,ti2, tii0,tii1
  local visited, itemInfo, itemInfoLen = {},{},0
  for i=1,len do
    cell = cells[i]
    for item in pairs(cell.items) do
      if not visited[item] then
        visited[item]  = true
        if (not filter or filter(item)) then
          rect           = self.rects[item]
          l,t,w,h        = rect.x,rect.y,rect.w,rect.h

          ti1,ti2 = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, 0, 1)
          if ti1 and ((0 < ti1 and ti1 < 1) or (0 < ti2 and ti2 < 1)) then
            -- the sorting is according to the t of an infinite line, not the segment
            tii0,tii1    = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, -math.huge, math.huge)
            itemInfoLen  = itemInfoLen + 1
            itemInfo[itemInfoLen] = {item = item, ti1 = ti1, ti2 = ti2, weight = min(tii0,tii1)}
          end
        end
      end
    end
  end
  table.sort(itemInfo, sortByWeight)
  return itemInfo, itemInfoLen
end

local function getResponseByName(self, name)
  local response = self.responses[name]
  if not response then
    error(('Unknown collision type: %s (%s)'):format(name, type(name)))
  end
  return response
end


-- Misc Public Methods

function World:addResponse(name, response)
  self.responses[name] = response
end

function World:project(item, x,y,w,h, goalX, goalY, filter)
  assertIsRect(x,y,w,h)

  goalX = goalX or x
  goalY = goalY or y
  filter  = filter  or defaultFilter

  local collisions, len = {}, 0

  local visited = {}
  if item ~= nil then visited[item] = true end

  -- This could probably be done with less cells using a polygon raster over the cells instead of a
  -- bounding rect of the whole movement. Conditional to building a queryPolygon method
  local tl, tt = min(goalX, x),       min(goalY, y)
  local tr, tb = max(goalX + w, x+w), max(goalY + h, y+h)
  local tw, th = tr-tl, tb-tt

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, tl,tt,tw,th)

  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  for other,_ in pairs(dictItemsInCellRect) do
    if not visited[other] then
      visited[other] = true

      local responseName = filter(item, other)
      if responseName then
        local ox,oy,ow,oh   = self:getRect(other)
        local col           = rect_detectCollision(x,y,w,h, ox,oy,ow,oh, goalX, goalY)

        if col then
          col.other    = other
          col.item     = item
          col.type     = responseName

          len = len + 1
          collisions[len] = col
        end
      end
    end
  end

  table.sort(collisions, sortByTiAndDistance)

  return collisions, len
end

function World:countCells()
  local count = 0
  for _,row in pairs(self.rows) do
    for _,_ in pairs(row) do
      count = count + 1
    end
  end
  return count
end

function World:hasItem(item)
  return not not self.rects[item]
end

function World:getItems()
  local items, len = {}, 0
  for item,_ in pairs(self.rects) do
    len = len + 1
    items[len] = item
  end
  return items, len
end

function World:countItems()
  local len = 0
  for _ in pairs(self.rects) do len = len + 1 end
  return len
end

function World:getRect(item)
  local rect = self.rects[item]
  if not rect then
    error('Item ' .. tostring(item) .. ' must be added to the world before getting its rect. Use world:add(item, x,y,w,h) to add it first.')
  end
  return rect.x, rect.y, rect.w, rect.h
end

function World:toWorld(cx, cy)
  return grid_toWorld(self.cellSize, cx, cy)
end

function World:toCell(x,y)
  return grid_toCell(self.cellSize, x, y)
end


--- Query methods

function World:queryRect(x,y,w,h, filter)

  assertIsRect(x,y,w,h)

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_isIntersecting(x,y,w,h, rect.x, rect.y, rect.w, rect.h)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:queryPoint(x,y, filter)
  local cx,cy = self:toCell(x,y)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cx,cy,1,1)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_containsPoint(rect.x, rect.y, rect.w, rect.h, x, y)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:querySegment(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local items = {}
  for i=1, len do
    items[i] = itemInfo[i].item
  end
  return items, len
end

function World:querySegmentWithCoords(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local dx, dy        = x2-x1, y2-y1
  local info, ti1, ti2
  for i=1, len do
    info  = itemInfo[i]
    ti1   = info.ti1
    ti2   = info.ti2

    info.weight  = nil
    info.x1      = x1 + dx * ti1
    info.y1      = y1 + dy * ti1
    info.x2      = x1 + dx * ti2
    info.y2      = y1 + dy * ti2
  end
  return itemInfo, len
end


--- Main methods

function World:add(item, x,y,w,h)
  local rect = self.rects[item]
  if rect then
    error('Item ' .. tostring(item) .. ' added to the world twice.')
  end
  assertIsRect(x,y,w,h)

  self.rects[item] = {x=x,y=y,w=w,h=h}

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      addItemToCell(self, item, cx, cy)
    end
  end

  return item
end

function World:remove(item)
  local x,y,w,h = self:getRect(item)

  self.rects[item] = nil
  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      removeItemFromCell(self, item, cx, cy)
    end
  end
end

function World:update(item, x2,y2,w2,h2)
  local x1,y1,w1,h1 = self:getRect(item)
  w2,h2 = w2 or w1, h2 or h1
  assertIsRect(x2,y2,w2,h2)

  if x1 ~= x2 or y1 ~= y2 or w1 ~= w2 or h1 ~= h2 then

    local cellSize = self.cellSize
    local cl1,ct1,cw1,ch1 = grid_toCellRect(cellSize, x1,y1,w1,h1)
    local cl2,ct2,cw2,ch2 = grid_toCellRect(cellSize, x2,y2,w2,h2)

    if cl1 ~= cl2 or ct1 ~= ct2 or cw1 ~= cw2 or ch1 ~= ch2 then

      local cr1, cb1 = cl1+cw1-1, ct1+ch1-1
      local cr2, cb2 = cl2+cw2-1, ct2+ch2-1
      local cyOut

      for cy = ct1, cb1 do
        cyOut = cy < ct2 or cy > cb2
        for cx = cl1, cr1 do
          if cyOut or cx < cl2 or cx > cr2 then
            removeItemFromCell(self, item, cx, cy)
          end
        end
      end

      for cy = ct2, cb2 do
        cyOut = cy < ct1 or cy > cb1
        for cx = cl2, cr2 do
          if cyOut or cx < cl1 or cx > cr1 then
            addItemToCell(self, item, cx, cy)
          end
        end
      end

    end

    local rect = self.rects[item]
    rect.x, rect.y, rect.w, rect.h = x2,y2,w2,h2

  end
end

function World:move(item, goalX, goalY, filter)
  local actualX, actualY, cols, len = self:check(item, goalX, goalY, filter)

  self:update(item, actualX, actualY)

  return actualX, actualY, cols, len
end

function World:check(item, goalX, goalY, filter)
  filter = filter or defaultFilter

  local visited = {[item] = true}
  local visitedFilter = function(itm, other)
    if visited[other] then return false end
    return filter(itm, other)
  end

  local cols, len = {}, 0

  local x,y,w,h = self:getRect(item)

  local projected_cols, projected_len = self:project(item, x,y,w,h, goalX,goalY, visitedFilter)

  while projected_len > 0 do
    local col = projected_cols[1]
    len       = len + 1
    cols[len] = col

    visited[col.other] = true

    local response = getResponseByName(self, col.type)

    goalX, goalY, projected_cols, projected_len = response(
      self,
      col,
      x, y, w, h,
      goalX, goalY,
      visitedFilter
    )
  end

  return goalX, goalY, cols, len
end


-- Public library functions

bump.newWorld = function(cellSize)
  cellSize = cellSize or 64
  assertIsPositiveNumber(cellSize, 'cellSize')
  local world = setmetatable({
    cellSize       = cellSize,
    rects          = {},
    rows           = {},
    nonEmptyCells  = {},
    responses = {}
  }, World_mt)

  world:addResponse('touch', touch)
  world:addResponse('cross', cross)
  world:addResponse('slide', slide)
  world:addResponse('bounce', bounce)

  return world
end

bump.rect = {
  getNearestCorner              = rect_getNearestCorner,
  getSegmentIntersectionIndices = rect_getSegmentIntersectionIndices,
  getDiff                       = rect_getDiff,
  containsPoint                 = rect_containsPoint,
  isIntersecting                = rect_isIntersecting,
  getSquareDistance             = rect_getSquareDistance,
  detectCollision               = rect_detectCollision
}

bump.responses = {
  touch  = touch,
  cross  = cross,
  slide  = slide,
  bounce = bounce
}

return bump


--- FILE: \lib\bump.lua\spec\bump_spec.lua ---

local bump = require 'bump'

describe('bump', function()

  describe('newWorld', function()
    it('creates a world', function()
      assert.truthy(bump.newWorld())
    end)

    it('defaults the cellSize to 64', function()
      assert.equal(bump.newWorld().cellSize, 64)
    end)

    it('can set the cellSize', function()
      assert.equal(bump.newWorld(32).cellSize, 32)
    end)

    it('throws an error if cellsize is not a positive number', function()
      assert.error(function() bump.newWorld(-10) end)
      assert.error(function() bump.newWorld("") end)
    end)
  end)

end)


--- FILE: \lib\bump.lua\spec\rect_spec.lua ---

local rect = require('bump').rect

describe('bump.rect', function()

  describe('detectCollision', function()
    local detect = rect.detectCollision
    describe('when item is static', function()

      describe('when itemRect does not intersect otherRect', function()
        it('returns nil', function()
          local c = detect(0,0,1,1, 5,5,1,1, 0,0)
          assert.is_nil(c)
        end)
      end)

      describe('when itemRect overlaps otherRect', function()
        it('returns overlaps, normal, move, ti, diff, itemRect, otherRect', function()
          local c = detect(0,0,7,6, 5,5,1,1, 0, 0)

          assert.is_true(c.overlaps)
          assert.equals(c.ti, -2)
          assert.same(c.move, {x = 0, y = 0})
          assert.same(c.itemRect, {x=0,y=0,w=7,h=6})
          assert.same(c.otherRect, {x=5,y=5,w=1,h=1})
          assert.same(c.normal, {x=0, y=-1})

        end)
      end)

    end)

    describe('when item is moving', function()
      describe('when itemRect does not intersect otherRect', function()
        it('returns nil', function()
          local c = detect(0,0,1,1, 5,5,1,1, 0,1)
          assert.is_nil(c)
        end)
      end)
      describe('when itemRect intersects otherRect', function()
        it('detects collisions from the left', function()
          local c = detect(1,1,1,1, 5,0,1,1, 6,0)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=-1, y=0})
        end)
        it('detects collisions from the right', function()
          local c = detect(6,0,1,1, 1,0,1,1, 1,1)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.8)
          assert.same(c.normal, {x=1, y=0})
        end)
        it('detects collisions from the top', function()
          local c = detect(0,0,1,1, 0,4,1,1, 0,5)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=0, y=-1})
        end)
        it('detects collisions from the bottom', function()
          local c = detect(0,4,1,1, 0,0,1,1, 0,-1)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=0, y=1})
        end)
      end)
      it('does not get caught by nasty corner cases', function()
        assert.is_nil(detect( 0,16,16,16, 16,0,16,16, -1,15))
      end)
    end)
  end)
end)



--- FILE: \lib\bump.lua\spec\responses_spec.lua ---

local bump            = require('bump')
local detect          = bump.rect.detectCollision
local responses  = bump.responses

local world = bump.newWorld()

local touch = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y}
end

local slide = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  responses.slide(world, col, x, y, w, h, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y, col.slide.x, col.slide.y}
end

local bounce = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  responses.bounce(world, col, x, y, w, h, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y, col.bounce.x, col.bounce.y }
end

describe('bump.responses', function()
  describe('touch', function()
    describe('when resolving collisions', function()
      describe('on overlaps', function()
        describe('when there is no movement', function()
          it('returns the left,top coordinates of the minimum displacement on static items', function()

            --                                          -2-1 0 1 2 3 4 5 6 7 8 9 10
            --      -2 -1 0 1 2 3 4 5 6 7 8 9           -2 · ┌–––┐ · ┌–––┐ · ┌–––┐ ·
            --      -1  ┌–––┐ · ┌–––┐ · ┌–––┐           -1 · │0-1│ · │0-1│ · │0-1│ ·
            --       0  │ ┌–––––––––––––––┐ │ 1  2  3    0 · └–┌–––––––––––––––┐–┘ ·
            --       1  └–│–┘ · └–––┘ · └–│–┘            1 · · │ · · · · · · · │ · ·
            --       2  · │ · · · · · · · │ ·            2 · · │ · · · · · · · │ · ·
            --       3  ┌–│–┐ · ┌–––┐ · ┌–│–┐            3 ┌–––│ · · · · · · · │–––┐
            --       4  │ │ │ · │ · │ · │ │ │ 4  5  6    4 -1 0│ · · · · · · · │1 0│
            --       5  └–│–┘ · └–––┘ · └–│–┘            5 └–––│ · · · · · · · │–––┘
            --       6  · │ · · · · · · · │ ·            6 · · │ · · · · · · · │ · ·
            --       7  ┌–│–┐ · ┌–––┐ · ┌–│–┐            7 · · │ · · · · · · · │ · ·
            --       8  │ └–––––––––––––––┘ │ 7  8  9    8 · ┌–└–––––––––––––––┘–┐ ·
            --       9  └–––┘ · └–––┘ · └–––┘            9 · │0 1│ · ╎0 1╎ · │0 1│ ·
            --      10                                  10 · └–––┘ · └╌╌╌┘ · └–––┘ ·

            assert.same(touch(-1,-1,2,2, 0,0,8,8), {-1,-2, 0, -1}) -- 1
            assert.same(touch( 3,-1,2,2, 0,0,8,8), { 3,-2, 0, -1}) -- 2
            assert.same(touch( 7,-1,2,2, 0,0,8,8), { 7,-2, 0, -1}) -- 3

            assert.same(touch(-1, 3,2,2, 0,0,8,8), {-2, 3, -1, 0}) -- 4
            assert.same(touch( 3, 3,2,2, 0,0,8,8), { 3, 8,  0, 1}) -- 5
            assert.same(touch( 7, 3,2,2, 0,0,8,8), { 8, 3,  1, 0}) -- 6

            assert.same(touch(-1, 7,2,2, 0,0,8,8), {-1, 8,  0, 1}) -- 7
            assert.same(touch( 3, 7,2,2, 0,0,8,8), { 3, 8,  0, 1}) -- 8
            assert.same(touch( 7, 7,2,2, 0,0,8,8), { 7, 8,  0, 1}) -- 9

          end)
        end)

        describe('when the item is moving', function()
          it('returns the left,top coordinates of the overlaps with the movement line, opposite direction', function()
            assert.same(touch(3,3,2,2, 0,0,8,8, 4, 3), { -2,  3, -1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 2, 3), {  8,  3,  1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 2, 3), {  8,  3,  1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 3, 4), {  3, -2,  0, -1})
            assert.same(touch(3,3,2,2, 0,0,8,8, 3, 2), {  3,  8,  0,  1})
          end)
        end)
      end)

      describe('on tunnels', function()
        it('returns the coordinates of the item when it starts touching the other, and the normal', function()
          assert.same(touch(-3, 3,2,2, 0,0,8,8, 3,3), { -2,  3, -1,  0})
          assert.same(touch( 9, 3,2,2, 0,0,8,8, 3,3), {  8,  3,  1,  0})
          assert.same(touch( 3,-3,2,2, 0,0,8,8, 3,3), {  3, -2,  0, -1})
          assert.same(touch( 3, 9,2,2, 0,0,8,8, 3,3), {  3,  8,  0,  1})
        end)
      end)
    end)
  end)

  describe('slide', function()
    it('slides on overlaps', function()
      assert.same(slide(3,3,2,2, 0,0,8,8, 4, 5), { 0.5, -2, 0,-1, 4, -2})
      assert.same(slide(3,3,2,2, 0,0,8,8, 5, 4), { -2, 0.5, -1,0, -2, 4})
      assert.same(slide(3,3,2,2, 0,0,8,8, 2, 1), { 5.5, 8, 0,1, 2, 8})
      assert.same(slide(3,3,2,2, 0,0,8,8, 1, 2), { 8, 5.5, 1,0, 8, 2})
    end)

    it('slides over tunnels', function()
      assert.same(slide(10,10,2,2, 0,0,8,8, 1, 4), { 7, 8, 0, 1, 1, 8})
      assert.same(slide(10,10,2,2, 0,0,8,8, 4, 1), { 8, 7, 1, 0, 8, 1})

      -- perfect corner case:
      assert.same(slide(10,10,2,2, 0,0,8,8, 1, 1), { 8, 8, 1, 0, 8, 1})
    end)
  end)

  describe('bounce', function()
    it('bounces on overlaps', function()
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 4, 5), { 0.5, -2, 0,-1, 4, -9})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 5, 4), { -2, 0.5, -1,0, -9, 4})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 2, 1), { 5.5, 8, 0,1, 2, 15})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 1, 2), { 8, 5.5, 1,0, 15,2})
    end)

    it('bounces over tunnels', function()
      assert.same(bounce(10,10,2,2, 0,0,8,8, 1, 4), { 7, 8, 0, 1, 1, 12})
      assert.same(bounce(10,10,2,2, 0,0,8,8, 4, 1), { 8, 7, 1, 0, 12, 1})

      -- perfect corner case:
      assert.same(bounce(10,10,2,2, 0,0,8,8, 1, 1), { 8, 8, 1, 0, 15, 1})
    end)
  end)
end)


--- FILE: \lib\bump.lua\spec\World_spec.lua ---

local bump = require 'bump'

describe('World', function()
  local world

  before_each(function()
    world = bump.newWorld()
  end)

  local collect = function(t, field_name)
    local res = {}
    for i,v in ipairs(t) do res[i] = v[field_name] end
    return res
  end

  local sorted = function(array)
    table.sort(array)
    return array
  end

  describe(':add', function()
    it('requires something + 4 numbers', function()
      assert.error(function() world:add({}) end)
      assert.error(function() world:add({}, 40) end)
      assert.error(function() world:add() end)
    end)

    it('returns the added item', function()
      local item = {}
      assert.equals(item, world:add(item, 1,1,1,1))
    end)

    it('throws an error if the object was already added', function()
      local obj = world:add({}, 0,0,10,10)
      assert.error(function() world:add(obj, 0,0,10,10) end)
    end)

    describe('when the world is empty', function()
      it('creates as many cells as needed to hold the item', function()
        world:add({}, 0,0,10,10) -- adss one cell
        assert.equal(world:countCells(), 1)

        world:add({}, 100,100,10,10) -- adds a separate single cell
        assert.equal(world:countCells(), 2)

        world:add({}, 0,0,100,10) -- occupies 2 cells, but just adds one (the other is already added)
        assert.equal(world:countCells(), 3)

        world:add({}, 0,0,100,10) -- occupies 2 cells, but just adds one (the other is already added)
        assert.equal(world:countCells(), 3)

        world:add({}, 300,300,64,64) -- adds 8 new cells
        assert.equal(world:countCells(), 7)
      end)
    end)
  end)

  describe(':update', function()

    describe('when the object is not there', function()
      it('throws an error', function()
        assert.is_error(function() world:update({}, 0,0) end)
      end)
    end)

    it('updates the object', function()
      local a = world:add({}, 0,0,10,10)
      world:update(a, 40,40, 20,20)
      assert.same({world:getRect(a)}, {40,40,20,20})
    end)

    describe('when no width or height is given', function()
      it('takes width and height from its previous value', function()
        local a = world:add({}, 0,0,10,10)
        world:update(a, 5,5)
        assert.same({5,5,10,10}, {world:getRect(a)})
      end)
    end)

    describe('when the object stays in the same group of cells', function()
      it('does not invoke remove and add', function()
        local a = world:add({}, 0,0,10,10)

        spy.on(world, 'remove')
        spy.on(world, 'add')

        world:update(a, 1,1, 11,11)

        assert.spy(world.remove).was.called(0)
        assert.spy(world.add).was.called(0)
      end)
    end)
  end)

  describe(':project', function()
    it('throws an error if when not given a rect', function()
      assert.error(function() world:project() end)
    end)

    describe('when the world is empty', function()
      it('returns an empty list of collisions', function()
        assert.same(world:project({}, 1,2,3,4), {})
      end)
    end)

    describe('when the world is not empty', function()
      it('returns a list of collisions', function()
        world:add({'a'}, 0,0,10,10)
        world:add({'c'}, 14,16,10,10)
        assert.same(#world:project({}, 4,6,10,10), 1)
      end)

      describe('when next futureX & Y are passed', function()
        it('still handles intersections as before', function()
          world:add({'a'}, 0,0, 2,2)
          assert.same(#world:project({}, 1,1,2,2, 1, 1), 1)
        end)

        it('detects and tags tunneling correctly', function()
          world:add({'a'},  1,0, 2,1)
          assert.same(#world:project({}, -5,0,4,1, 5,0), 1)
        end)

        it('detects the case where an object was touching another without intersecting, and then penetrates', function()
          world:add({'b'}, 0,0,32,100)
          assert.same(#world:project({}, 32,50,20,20, 30,50), 1)
        end)

        it('returns a list of collisions sorted by ti', function()
          world:add({'b'}, 70,0, 10,10)
          world:add({'c'}, 50,0, 10,10)
          world:add({'d'}, 90,0, 10,10)

          local col = world:project({}, 110,0,10,10, 10,0)

          assert.same(collect(col, 'ti'), {0.1, 0.3, 0.5})
        end)
      end) -- when FutureX & Y are passed

      describe('the filter param', function()
        it('deactivates collisions when filter returns false', function()
          world:add({'b'}, 70,0, 10,10)
          world:add({'c'}, 50,0, 10,10)
          local d = world:add({'d'}, 90,0, 10,10)

          local cols = world:project({}, 110,0, 10,10, 10, 0, function(item, obj)
            return obj ~= d and "touch"
          end)

          assert.same(#cols, 2)
        end)
      end)
    end) -- when the world is not empty
  end) -- :project

  describe(':remove', function()
    it('throws an error if the item does not exist', function()
      assert.error(function() world:remove({}) end)
    end)
    it('makes the item disappear from the world', function()
      local a = world:add({'a'}, 0,0, 10,10)
      assert.same(#world:project({}, 5,0,1,1), 1)
      world:remove(a)
      assert.same(#world:project({}, 5,0,1,1), 0)
    end)
    it('marks empty cells & rows for deallocation', function()
      world:add({'a'}, 0,0, 10, 10)
      local b = world:add({'b'}, 200,200, 10,10)
      assert.same(world:countCells(), 2)
      world:remove(b)
      assert.same(world:countCells(), 2)
      collectgarbage('collect')
      assert.same(world:countCells(), 1)
    end)
  end)

  describe(':toCell', function()
    it('returns the coordinates of the cell containing a point', function()
      assert.same({world:toCell(0,0)}, {1,1})
      assert.same({world:toCell(63.9,63.9)}, {1,1})
      assert.same({world:toCell(64,64)}, {2,2})
      assert.same({world:toCell(-1,-1)}, {0,0})
    end)
  end)

  describe(':toWorld', function()
    it('returns the world left,top corner of the given cell', function()
      assert.same({world:toWorld(1,1)}, {0,0})
      assert.same({world:toWorld(2,2)}, {64,64})
      assert.same({world:toWorld(-1,1)}, {-128,0})
    end)
  end)

  describe(':queryRect', function()
    it('throws an error when given an invalid rect', function()
      assert.error(function() world:queryRect(0,0,-1,-1) end)
    end)
    it('returns nothing when the world is empty', function()
      assert.same(world:queryRect(0,0,1,1), {})
    end)
    describe('when the world has items', function()
      local a, b, c, d
      before_each(function()
        a = world:add('a', 10,0, 10,10)
        b = world:add('b', 70,0, 10,10)
        c = world:add('c', 50,0, 10,10)
        d = world:add('d', 90,0, 10,10)
      end)

      it('returns the items inside/partially inside the given rect', function()
        assert.same(sorted(world:queryRect(55, 5, 20, 20)), {b,c})
        assert.same(sorted(world:queryRect(0, 5, 100, 20)), {a,b,c,d})
      end)

      it('only returns the items for which filter returns true', function()
        local filter = function(other) return other == a or other == b or other == d end
        assert.same(sorted(world:queryRect(55, 5, 20, 20, filter)), {b})
        assert.same(sorted(world:queryRect(0, 5, 100, 20, filter)), {a,b,d})
      end)
    end)
  end)

  describe(':queryPoint', function()
    it('returns nothing when the world is empty', function()
      assert.same(world:queryPoint(0,0), {})
    end)
    describe('when the world has items', function()
      local a, b, c
      before_each(function()
        a = world:add('a', 10,0, 10,10)
        b = world:add('b', 15,0, 10,10)
        c = world:add('c', 20,0, 10,10)
      end)

      it('returns the items inside/partially inside the given rect', function()
        assert.same(sorted(world:queryPoint( 4,5)), {})
        assert.same(sorted(world:queryPoint(14,5)), {a})
        assert.same(sorted(world:queryPoint(16,5)), {a,b})
        assert.same(sorted(world:queryPoint(21,5)), {b,c})
        assert.same(sorted(world:queryPoint(26,5)), {c})
        assert.same(sorted(world:queryPoint(31,5)), {})
      end)

      it('the items are ignored when filter is present and returns false for them', function()
        local filter = function(other) return other ~= b end
        assert.same(sorted(world:queryPoint( 4,5, filter)), {})
        assert.same(sorted(world:queryPoint(14,5, filter)), {a})
        assert.same(sorted(world:queryPoint(16,5, filter)), {a})
        assert.same(sorted(world:queryPoint(21,5, filter)), {c})
        assert.same(sorted(world:queryPoint(26,5, filter)), {c})
        assert.same(sorted(world:queryPoint(31,5, filter)), {})
      end)
    end)
  end)

  describe(':querySegment', function()
    it('returns nothing when the world is empty', function()
      assert.same(world:querySegment(0,0,1,1), {})
    end)

    it('does not touch borders', function()
      world:add({'a'}, 10,0, 5,5)
      world:add({'c'}, 20,0, 5,5)

      assert.same(world:querySegment(0,5,  10,0),  {})
      assert.same(world:querySegment(15,5, 20,0),  {})
      assert.same(world:querySegment(26,5, 25,0),  {})
    end)

    describe("when the world has items", function()
      local a, b, c
      before_each(function()
        a = world:add('a',  5,0, 5,10)
        b = world:add('b', 15,0, 5,10)
        c = world:add('c', 25,0, 5,10)
      end)

      it('returns the items touched by the segment, sorted by touch order', function()
        assert.same(world:querySegment(0,5, 11,5),  {a})
        assert.same(world:querySegment(0,5, 17,5),  {a,b})
        assert.same(world:querySegment(0,5, 30,5),  {a,b,c})
        assert.same(world:querySegment(17,5, 26,5), {b,c})
        assert.same(world:querySegment(22,5, 26,5), {c})

        assert.same(world:querySegment(11,5, 0,5),  {a})
        assert.same(world:querySegment(17,5, 0,5),  {b,a})
        assert.same(world:querySegment(30,5, 0,5),  {c,b,a})
        assert.same(world:querySegment(26,5, 17,5), {c,b})
        assert.same(world:querySegment(26,5, 22,5), {c})
      end)

      it('filters out items when filter does not return true for them', function()
        local filter = function(other) return other ~= a and other ~= c end

        assert.same(world:querySegment(0,5, 11,5, filter),  {})
        assert.same(world:querySegment(0,5, 17,5, filter),  {b})
        assert.same(world:querySegment(0,5, 30,5, filter),  {b})
        assert.same(world:querySegment(17,5, 26,5, filter), {b})
        assert.same(world:querySegment(22,5, 26,5, filter), {})

        assert.same(world:querySegment(11,5, 0,5, filter),  {})
        assert.same(world:querySegment(17,5, 0,5, filter),  {b})
        assert.same(world:querySegment(30,5, 0,5, filter),  {b})
        assert.same(world:querySegment(26,5, 17,5, filter), {b})
        assert.same(world:querySegment(26,5, 22,5, filter), {})
      end)
    end)
  end)

  describe(":hasItem", function()
    it('returns wether the world has an item', function()
      local item = {}

      assert.is_false(world:hasItem(item))
      world:add(item, 0,0,1,1)
      assert.is_true(world:hasItem(item))
    end)
    it('does not throw errors with non-tables or nil', function()

      assert.is_false(world:hasItem(false))
      assert.is_false(world:hasItem(1))
      assert.is_false(world:hasItem("hello"))
      assert.is_false(world:hasItem())
    end)
  end)

  describe(":getItems", function()
    it('returns all the items in the world', function()
      local a,b = 'a','b'
      world:add(a, 1,1,1,1)
      world:add(b, 2,2,2,2)
      local items, len = world:getItems()
      table.sort(items)
      assert.same({'a', 'b'}, items)
      assert.equals(2, len)
    end)
  end)

  describe(":countItems", function()
    it('counts the items in the world', function()
      world:add({}, 1,1,1,1)
      world:add({}, 2,2,2,2)
      local count = world:countItems()
      assert.equals(2, count)
    end)
  end)

  describe(":move", function()
    describe('when there are no collisions', function()
      it('it moves the object, and returns zero collisions', function()
        local item = world:add({}, 0,0,1,1)
        assert.same({1,1,{},0}, {world:move(item, 1,1)})
      end)
    end)

    describe('when touching', function()
      it('returns a collision with the first item it touches', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,1)
        world:add('c', 0,3,1,1)
        local x,y,cols,len = world:move(a, 0,5, function() return 'touch' end)
        assert.same({x,y}, {0,1})
        assert.equals(1, len)
        assert.same(collect(cols, 'other'), {'b'})
        assert.same(collect(cols, 'type'),  {'touch'})
        assert.same({0,1,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when crossing', function()
      it('returns a collision with every item it crosses', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,1)
        world:add('c', 0,3,1,1)
        local x,y,cols,len = world:move(a, 0,5, function() return 'cross' end)
        assert.same({x,y}, {0,5})
        assert.equals(2, len)
        assert.same(collect(cols, 'other'), {'b', 'c'})
        assert.same(collect(cols, 'type'),  {'cross', 'cross'})
        assert.same({0,5,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when sliding', function()
      it('slides with every element', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,2)
        world:add('c', 2,1,1,1)
        local x,y,cols,len = world:move(a, 5,5, function() return 'slide' end)
        assert.same({x,y}, {1,5})
        assert.equals(1, len)
        assert.same(collect(cols, 'other'), {'c'})
        assert.same(collect(cols, 'type'),  {'slide'})
        assert.same({1,5,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when bouncing', function()
      it('bounces on each element',function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,2)
        local x,y,cols,len = world:move(a, 0,5, function() return 'bounce' end)
        assert.same({x,y}, {0,-3})
        assert.equal(1, len)
        assert.same(collect(cols, 'other'), {'b'})
        assert.same(collect(cols, 'type'),  {'bounce'})
        assert.same({0,-3,1,1}, {world:getRect(a)})
      end)
    end)
  end)
end)


--- FILE: \lib\hump\camera.lua ---

--[[
Copyright (c) 2010-2015 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local _PATH = (...):match('^(.*[%./])[^%.%/]+$') or ''
local cos, sin = math.cos, math.sin

local camera = {}
camera.__index = camera

-- Movement interpolators (for camera locking/windowing)
camera.smooth = {}

function camera.smooth.none()
	return function(dx,dy) return dx,dy end
end

function camera.smooth.linear(speed)
	assert(type(speed) == "number", "Invalid parameter: speed = "..tostring(speed))
	return function(dx,dy, s)
		-- normalize direction
		local d = math.sqrt(dx*dx+dy*dy)
		local dts = math.min((s or speed) * love.timer.getDelta(), d) -- prevent overshooting the goal
		if d > 0 then
			dx,dy = dx/d, dy/d
		end

		return dx*dts, dy*dts
	end
end

function camera.smooth.damped(stiffness)
	assert(type(stiffness) == "number", "Invalid parameter: stiffness = "..tostring(stiffness))
	return function(dx,dy, s)
		local dts = love.timer.getDelta() * (s or stiffness)
		return dx*dts, dy*dts
	end
end


local function new(x,y, zoom, rot, smoother)
	x,y  = x or love.graphics.getWidth()/2, y or love.graphics.getHeight()/2
	zoom = zoom or 1
	rot  = rot or 0
	smoother = smoother or camera.smooth.none() -- for locking, see below
	return setmetatable({x = x, y = y, scale = zoom, rot = rot, smoother = smoother}, camera)
end

function camera:lookAt(x,y)
	self.x, self.y = x, y
	return self
end

function camera:move(dx,dy)
	self.x, self.y = self.x + dx, self.y + dy
	return self
end

function camera:position()
	return self.x, self.y
end

function camera:rotate(phi)
	self.rot = self.rot + phi
	return self
end

function camera:rotateTo(phi)
	self.rot = phi
	return self
end

function camera:zoom(mul)
	self.scale = self.scale * mul
	return self
end

function camera:zoomTo(zoom)
	self.scale = zoom
	return self
end

function camera:attach(x,y,w,h, noclip)
	x,y = x or 0, y or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	self._sx,self._sy,self._sw,self._sh = love.graphics.getScissor()
	if not noclip then
		love.graphics.setScissor(x,y,w,h)
	end

	local cx,cy = x+w/2, y+h/2
	love.graphics.push()
	love.graphics.translate(cx, cy)
	love.graphics.scale(self.scale)
	love.graphics.rotate(self.rot)
	love.graphics.translate(-self.x, -self.y)
end

function camera:detach()
	love.graphics.pop()
	love.graphics.setScissor(self._sx,self._sy,self._sw,self._sh)
end

function camera:draw(...)
	local x,y,w,h,noclip,func
	local nargs = select("#", ...)
	if nargs == 1 then
		func = ...
	elseif nargs == 5 then
		x,y,w,h,func = ...
	elseif nargs == 6 then
		x,y,w,h,noclip,func = ...
	else
		error("Invalid arguments to camera:draw()")
	end

	self:attach(x,y,w,h,noclip)
	func()
	self:detach()
end

-- world coordinates to camera coordinates
function camera:cameraCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = ((x,y) - (self.x, self.y)):rotated(self.rot) * self.scale + center
	local c,s = cos(self.rot), sin(self.rot)
	x,y = x - self.x, y - self.y
	x,y = c*x - s*y, s*x + c*y
	return x*self.scale + w/2 + ox, y*self.scale + h/2 + oy
end

-- camera coordinates to world coordinates
function camera:worldCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = (((x,y) - center) / self.scale):rotated(-self.rot) + (self.x,self.y)
	local c,s = cos(-self.rot), sin(-self.rot)
	x,y = (x - w/2 - ox) / self.scale, (y - h/2 - oy) / self.scale
	x,y = c*x - s*y, s*x + c*y
	return x+self.x, y+self.y
end

function camera:mousePosition(ox,oy,w,h)
	local mx,my = love.mouse.getPosition()
	return self:worldCoords(mx,my, ox,oy,w,h)
end

-- camera scrolling utilities
function camera:lockX(x, smoother, ...)
	local dx, dy = (smoother or self.smoother)(x - self.x, self.y, ...)
	self.x = self.x + dx
	return self
end

function camera:lockY(y, smoother, ...)
	local dx, dy = (smoother or self.smoother)(self.x, y - self.y, ...)
	self.y = self.y + dy
	return self
end

function camera:lockPosition(x,y, smoother, ...)
	return self:move((smoother or self.smoother)(x - self.x, y - self.y, ...))
end

function camera:lockWindow(x, y, x_min, x_max, y_min, y_max, smoother, ...)
	-- figure out displacement in camera coordinates
	x,y = self:cameraCoords(x,y)
	local dx, dy = 0,0
	if x < x_min then
		dx = x - x_min
	elseif x > x_max then
		dx = x - x_max
	end
	if y < y_min then
		dy = y - y_min
	elseif y > y_max then
		dy = y - y_max
	end

	-- transform displacement to movement in world coordinates
	local c,s = cos(-self.rot), sin(-self.rot)
	dx,dy = (c*dx - s*dy) / self.scale, (s*dx + c*dy) / self.scale

	-- move
	self:move((smoother or self.smoother)(dx,dy,...))
end

-- the module
return setmetatable({new = new, smooth = camera.smooth},
	{__call = function(_, ...) return new(...) end})


--- FILE: \lib\hump\class.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function include_helper(to, from, seen)
	if from == nil then
		return to
	elseif type(from) ~= 'table' then
		return from
	elseif seen[from] then
		return seen[from]
	end

	seen[from] = to
	for k,v in pairs(from) do
		k = include_helper({}, k, seen) -- keys might also be tables
		if to[k] == nil then
			to[k] = include_helper({}, v, seen)
		end
	end
	return to
end

-- deeply copies `other' into `class'. keys in `other' that are already
-- defined in `class' are omitted
local function include(class, other)
	return include_helper(class, other, {})
end

-- returns a deep copy of `other'
local function clone(other)
	return setmetatable(include({}, other), getmetatable(other))
end

local function new(class)
	-- mixins
	class = class or {}  -- class can be nil
	local inc = class.__includes or {}
	if getmetatable(inc) then inc = {inc} end

	for _, other in ipairs(inc) do
		if type(other) == "string" then
			other = _G[other]
		end
		include(class, other)
	end

	-- class implementation
	class.__index = class
	class.init    = class.init    or class[1] or function() end
	class.include = class.include or include
	class.clone   = class.clone   or clone

	-- constructor call
	return setmetatable(class, {__call = function(c, ...)
		local o = setmetatable({}, c)
		o:init(...)
		return o
	end})
end

-- interface for cross class-system compatibility (see https://github.com/bartbes/Class-Commons).
if class_commons ~= false and not common then
	common = {}
	function common.class(name, prototype, parent)
		return new{__includes = {prototype, parent}}
	end
	function common.instance(class, ...)
		return class(...)
	end
end


-- the module
return setmetatable({new = new, include = include, clone = clone},
	{__call = function(_,...) return new(...) end})


--- FILE: \lib\hump\gamestate.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function __NULL__() end

 -- default gamestate produces error on every callback
local state_init = setmetatable({leave = __NULL__},
		{__index = function() error("Gamestate not initialized. Use Gamestate.switch()") end})
local stack = {state_init}
local initialized_states = setmetatable({}, {__mode = "k"})
local state_is_dirty = true

local GS = {}
function GS.new(t) return t or {} end -- constructor - deprecated!

local function change_state(stack_offset, to, ...)
	local pre = stack[#stack]

	-- initialize only on first call
	;(initialized_states[to] or to.init or __NULL__)(to)
	initialized_states[to] = __NULL__

	stack[#stack+stack_offset] = to
	state_is_dirty = true
	return (to.enter or __NULL__)(to, pre, ...)
end

function GS.switch(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call switch with colon operator")
	;(stack[#stack].leave or __NULL__)(stack[#stack])
	return change_state(0, to, ...)
end

function GS.push(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call push with colon operator")
	return change_state(1, to, ...)
end

function GS.pop(...)
	assert(#stack > 1, "No more states to pop!")
	local pre, to = stack[#stack], stack[#stack-1]
	stack[#stack] = nil
	;(pre.leave or __NULL__)(pre)
	state_is_dirty = true
	return (to.resume or __NULL__)(to, pre, ...)
end

function GS.current()
	return stack[#stack]
end

-- XXX: don't overwrite love.errorhandler by default:
--      this callback is different than the other callbacks
--      (see http://love2d.org/wiki/love.errorhandler)
--      overwriting thi callback can result in random crashes (issue #95)
local all_callbacks = { 'draw', 'update' }

-- fetch event callbacks from love.handlers
for k in pairs(love.handlers) do
	all_callbacks[#all_callbacks+1] = k
end

function GS.registerEvents(callbacks)
	local registry = {}
	callbacks = callbacks or all_callbacks
	for _, f in ipairs(callbacks) do
		registry[f] = love[f] or __NULL__
		love[f] = function(...)
			registry[f](...)
			return GS[f](...)
		end
	end
end

-- forward any undefined functions
setmetatable(GS, {__index = function(_, func)
	-- call function only if at least one 'update' was called beforehand
	-- (see issue #46)
	if not state_is_dirty or func == 'update' then
		state_is_dirty = false
		return function(...)
			return (stack[#stack][func] or __NULL__)(stack[#stack], ...)
		end
	end
	return __NULL__
end})

return GS


--- FILE: \lib\hump\signal.lua ---

--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Registry = {}
Registry.__index = function(self, key)
	return Registry[key] or (function()
		local t = {}
		rawset(self, key, t)
		return t
	end)()
end

function Registry:register(s, f)
	self[s][f] = f
	return f
end

function Registry:emit(s, ...)
	for f in pairs(self[s]) do
		f(...)
	end
end

function Registry:remove(s, ...)
	local f = {...}
	for i = 1,select('#', ...) do
		self[s][f[i]] = nil
	end
end

function Registry:clear(...)
	local s = {...}
	for i = 1,select('#', ...) do
		self[s[i]] = {}
	end
end

function Registry:emitPattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:emit(s, ...) end
	end
end

function Registry:registerPattern(p, f)
	for s in pairs(self) do
		if s:match(p) then self:register(s, f) end
	end
	return f
end

function Registry:removePattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:remove(s, ...) end
	end
end

function Registry:clearPattern(p)
	for s in pairs(self) do
		if s:match(p) then self[s] = {} end
	end
end

-- instancing
function Registry.new()
	return setmetatable({}, Registry)
end

-- default instance
local default = Registry.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Registry) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end

return setmetatable(module, {__call = Registry.new})


--- FILE: \lib\hump\timer.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Timer = {}
Timer.__index = Timer

local function _nothing_() end

local function updateTimerHandle(handle, dt)
		-- handle: {
		--   time = <number>,
		--   after = <function>,
		--   during = <function>,
		--   limit = <number>,
		--   count = <number>,
		-- }
		handle.time = handle.time + dt
		handle.during(dt, math.max(handle.limit - handle.time, 0))

		while handle.time >= handle.limit and handle.count > 0 do
			if handle.after(handle.after) == false then
				handle.count = 0
				break
			end
			handle.time = handle.time - handle.limit
			handle.count = handle.count - 1
		end
end

function Timer:update(dt)
	-- timers may create new timers, which leads to undefined behavior
	-- in pairs() - so we need to put them in a different table first
	local to_update = {}
	for handle in pairs(self.functions) do
		to_update[handle] = handle
	end

	for handle in pairs(to_update) do
		if self.functions[handle] then
			updateTimerHandle(handle, dt)
			if handle.count == 0 then
				self.functions[handle] = nil
			end
		end
	end
end

function Timer:during(delay, during, after)
	local handle = { time = 0, during = during, after = after or _nothing_, limit = delay, count = 1 }
	self.functions[handle] = true
	return handle
end

function Timer:after(delay, func)
	return self:during(delay, _nothing_, func)
end

function Timer:every(delay, after, count)
	local count = count or math.huge -- exploit below: math.huge - 1 = math.huge
	local handle = { time = 0, during = _nothing_, after = after, limit = delay, count = count }
	self.functions[handle] = true
	return handle
end

function Timer:cancel(handle)
	self.functions[handle] = nil
end

function Timer:clear()
	self.functions = {}
end

function Timer:script(f)
	local co = coroutine.wrap(f)
	co(function(t)
		self:after(t, co)
		coroutine.yield()
	end)
end

Timer.tween = setmetatable({
	-- helper functions
	out = function(f) -- 'rotates' a function
		return function(s, ...) return 1 - f(1-s, ...) end
	end,
	chain = function(f1, f2) -- concatenates two functions
		return function(s, ...) return (s < .5 and f1(2*s, ...) or 1 + f2(2*s-1, ...)) * .5 end
	end,

	-- useful tweening functions
	linear = function(s) return s end,
	quad   = function(s) return s*s end,
	cubic  = function(s) return s*s*s end,
	quart  = function(s) return s*s*s*s end,
	quint  = function(s) return s*s*s*s*s end,
	sine   = function(s) return 1-math.cos(s*math.pi/2) end,
	expo   = function(s) return 2^(10*(s-1)) end,
	circ   = function(s) return 1 - math.sqrt(1-s*s) end,

	back = function(s,bounciness)
		bounciness = bounciness or 1.70158
		return s*s*((bounciness+1)*s - bounciness)
	end,

	bounce = function(s) -- magic numbers ahead
		local a,b = 7.5625, 1/2.75
		return math.min(a*s^2, a*(s-1.5*b)^2 + .75, a*(s-2.25*b)^2 + .9375, a*(s-2.625*b)^2 + .984375)
	end,

	elastic = function(s, amp, period)
		amp, period = amp and math.max(1, amp) or 1, period or .3
		return (-amp * math.sin(2*math.pi/period * (s-1) - math.asin(1/amp))) * 2^(10*(s-1))
	end,
}, {

-- register new tween
__call = function(tween, self, len, subject, target, method, after, ...)
	-- recursively collects fields that are defined in both subject and target into a flat list
	local function tween_collect_payload(subject, target, out)
		for k,v in pairs(target) do
			local ref = subject[k]
			assert(type(v) == type(ref), 'Type mismatch in field "'..k..'".')
			if type(v) == 'table' then
				tween_collect_payload(ref, v, out)
			else
				local ok, delta = pcall(function() return (v-ref)*1 end)
				assert(ok, 'Field "'..k..'" does not support arithmetic operations')
				out[#out+1] = {subject, k, delta}
			end
		end
		return out
	end

	method = tween[method or 'linear'] -- see __index
	local payload, t, args = tween_collect_payload(subject, target, {}), 0, {...}

	local last_s = 0
	return self:during(len, function(dt)
		t = t + dt
		local s = method(math.min(1, t/len), unpack(args))
		local ds = s - last_s
		last_s = s
		for _, info in ipairs(payload) do
			local ref, key, delta = unpack(info)
			ref[key] = ref[key] + delta * ds
		end
	end, after)
end,

-- fetches function and generated compositions for method `key`
__index = function(tweens, key)
	if type(key) == 'function' then return key end

	assert(type(key) == 'string', 'Method must be function or string.')
	if rawget(tweens, key) then return rawget(tweens, key) end

	local function construct(pattern, f)
		local method = rawget(tweens, key:match(pattern))
		if method then return f(method) end
		return nil
	end

	local out, chain = rawget(tweens,'out'), rawget(tweens,'chain')
	return construct('^in%-([^-]+)$', function(...) return ... end)
	       or construct('^out%-([^-]+)$', out)
	       or construct('^in%-out%-([^-]+)$', function(f) return chain(f, out(f)) end)
	       or construct('^out%-in%-([^-]+)$', function(f) return chain(out(f), f) end)
	       or error('Unknown interpolation method: ' .. key)
end})

-- Timer instancing
function Timer.new()
	return setmetatable({functions = {}, tween = Timer.tween}, Timer)
end

-- default instance
local default = Timer.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Timer) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end
module.tween = setmetatable({}, {
	__index = Timer.tween,
	__newindex = function(k,v) Timer.tween[k] = v end,
	__call = function(t, ...) return default:tween(...) end,
})

return setmetatable(module, {__call = Timer.new})


--- FILE: \lib\hump\vector-light.lua ---

--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local function str(x,y)
	return "("..tonumber(x)..","..tonumber(y)..")"
end

local function mul(s, x,y)
	return s*x, s*y
end

local function div(s, x,y)
	return x/s, y/s
end

local function add(x1,y1, x2,y2)
	return x1+x2, y1+y2
end

local function sub(x1,y1, x2,y2)
	return x1-x2, y1-y2
end

local function permul(x1,y1, x2,y2)
	return x1*x2, y1*y2
end

local function dot(x1,y1, x2,y2)
	return x1*x2 + y1*y2
end

local function det(x1,y1, x2,y2)
	return x1*y2 - y1*x2
end

local function eq(x1,y1, x2,y2)
	return x1 == x2 and y1 == y2
end

local function lt(x1,y1, x2,y2)
	return x1 < x2 or (x1 == x2 and y1 < y2)
end

local function le(x1,y1, x2,y2)
	return x1 <= x2 and y1 <= y2
end

local function len2(x,y)
	return x*x + y*y
end

local function len(x,y)
	return sqrt(x*x + y*y)
end

local function fromPolar(angle, radius)
	radius = radius or 1
	return cos(angle)*radius, sin(angle)*radius
end

local function randomDirection(len_min, len_max)
	len_min = len_min or 1
	len_max = len_max or len_min

	assert(len_max > 0, "len_max must be greater than zero")
	assert(len_max >= len_min, "len_max must be greater than or equal to len_min")

	return fromPolar(math.random()*2*math.pi,
	                 math.random() * (len_max-len_min) + len_min)
end

local function toPolar(x, y)
	return atan2(y,x), len(x,y)
end

local function dist2(x1,y1, x2,y2)
	return len2(x1-x2, y1-y2)
end

local function dist(x1,y1, x2,y2)
	return len(x1-x2, y1-y2)
end

local function normalize(x,y)
	local l = len(x,y)
	if l > 0 then
		return x/l, y/l
	end
	return x,y
end

local function rotate(phi, x,y)
	local c, s = cos(phi), sin(phi)
	return c*x - s*y, s*x + c*y
end

local function perpendicular(x,y)
	return -y, x
end

local function project(x,y, u,v)
	local s = (x*u + y*v) / (u*u + v*v)
	return s*u, s*v
end

local function mirror(x,y, u,v)
	local s = 2 * (x*u + y*v) / (u*u + v*v)
	return s*u - x, s*v - y
end

-- ref.: http://blog.signalsondisplay.com/?p=336
local function trim(maxLen, x, y)
	local s = maxLen * maxLen / len2(x, y)
	s = s > 1 and 1 or math.sqrt(s)
	return x * s, y * s
end

local function angleTo(x,y, u,v)
	if u and v then
		return atan2(y, x) - atan2(v, u)
	end
	return atan2(y, x)
end

-- the module
return {
	str = str,

	fromPolar       = fromPolar,
	toPolar         = toPolar,
	randomDirection = randomDirection,

	-- arithmetic
	mul    = mul,
	div    = div,
	idiv   = idiv,
	add    = add,
	sub    = sub,
	permul = permul,
	dot    = dot,
	det    = det,
	cross  = det,

	-- relation
	eq = eq,
	lt = lt,
	le = le,

	-- misc operations
	len2          = len2,
	len           = len,
	dist2         = dist2,
	dist          = dist,
	normalize     = normalize,
	rotate        = rotate,
	perpendicular = perpendicular,
	project       = project,
	mirror        = mirror,
	trim          = trim,
	angleTo       = angleTo,
}


--- FILE: \lib\hump\vector.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local assert = assert
local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local vector = {}
vector.__index = vector

local function new(x,y)
	return setmetatable({x = x or 0, y = y or 0}, vector)
end
local zero = new(0,0)

local function fromPolar(angle, radius)
	radius = radius or 1
	return new(cos(angle) * radius, sin(angle) * radius)
end

local function randomDirection(len_min, len_max)
	len_min = len_min or 1
	len_max = len_max or len_min

	assert(len_max > 0, "len_max must be greater than zero")
	assert(len_max >= len_min, "len_max must be greater than or equal to len_min")
	
	return fromPolar(math.random() * 2*math.pi,
	                 math.random() * (len_max-len_min) + len_min)
end

local function isvector(v)
	return type(v) == 'table' and type(v.x) == 'number' and type(v.y) == 'number'
end

function vector:clone()
	return new(self.x, self.y)
end

function vector:unpack()
	return self.x, self.y
end

function vector:__tostring()
	return "("..tonumber(self.x)..","..tonumber(self.y)..")"
end

function vector.__unm(a)
	return new(-a.x, -a.y)
end

function vector.__add(a,b)
	assert(isvector(a) and isvector(b), "Add: wrong argument types (<vector> expected)")
	return new(a.x+b.x, a.y+b.y)
end

function vector.__sub(a,b)
	assert(isvector(a) and isvector(b), "Sub: wrong argument types (<vector> expected)")
	return new(a.x-b.x, a.y-b.y)
end

function vector.__mul(a,b)
	if type(a) == "number" then
		return new(a*b.x, a*b.y)
	elseif type(b) == "number" then
		return new(b*a.x, b*a.y)
	else
		assert(isvector(a) and isvector(b), "Mul: wrong argument types (<vector> or <number> expected)")
		return a.x*b.x + a.y*b.y
	end
end

function vector.__div(a,b)
	assert(isvector(a) and type(b) == "number", "wrong argument types (expected <vector> / <number>)")
	return new(a.x / b, a.y / b)
end

function vector.__eq(a,b)
	return a.x == b.x and a.y == b.y
end

function vector.__lt(a,b)
	return a.x < b.x or (a.x == b.x and a.y < b.y)
end

function vector.__le(a,b)
	return a.x <= b.x and a.y <= b.y
end

function vector.permul(a,b)
	assert(isvector(a) and isvector(b), "permul: wrong argument types (<vector> expected)")
	return new(a.x*b.x, a.y*b.y)
end

function vector:toPolar()
	return new(atan2(self.x, self.y), self:len())
end

function vector:len2()
	return self.x * self.x + self.y * self.y
end

function vector:len()
	return sqrt(self.x * self.x + self.y * self.y)
end

function vector.dist(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return sqrt(dx * dx + dy * dy)
end

function vector.dist2(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return (dx * dx + dy * dy)
end

function vector:normalizeInplace()
	local l = self:len()
	if l > 0 then
		self.x, self.y = self.x / l, self.y / l
	end
	return self
end

function vector:normalized()
	return self:clone():normalizeInplace()
end

function vector:rotateInplace(phi)
	local c, s = cos(phi), sin(phi)
	self.x, self.y = c * self.x - s * self.y, s * self.x + c * self.y
	return self
end

function vector:rotated(phi)
	local c, s = cos(phi), sin(phi)
	return new(c * self.x - s * self.y, s * self.x + c * self.y)
end

function vector:perpendicular()
	return new(-self.y, self.x)
end

function vector:projectOn(v)
	assert(isvector(v), "invalid argument: cannot project vector on " .. type(v))
	-- (self * v) * v / v:len2()
	local s = (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x, s * v.y)
end

function vector:mirrorOn(v)
	assert(isvector(v), "invalid argument: cannot mirror vector on " .. type(v))
	-- 2 * self:projectOn(v) - self
	local s = 2 * (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x - self.x, s * v.y - self.y)
end

function vector:cross(v)
	assert(isvector(v), "cross: wrong argument types (<vector> expected)")
	return self.x * v.y - self.y * v.x
end

-- ref.: http://blog.signalsondisplay.com/?p=336
function vector:trimInplace(maxLen)
	local s = maxLen * maxLen / self:len2()
	s = (s > 1 and 1) or math.sqrt(s)
	self.x, self.y = self.x * s, self.y * s
	return self
end

function vector:angleTo(other)
	if other then
		return atan2(self.y, self.x) - atan2(other.y, other.x)
	end
	return atan2(self.y, self.x)
end

function vector:trimmed(maxLen)
	return self:clone():trimInplace(maxLen)
end


-- the module
return setmetatable({
	new             = new,
	fromPolar       = fromPolar,
	randomDirection = randomDirection,
	isvector        = isvector,
	zero            = zero
}, {
	__call = function(_, ...) return new(...) end
})


--- FILE: \lib\hump\spec\timer_spec.lua ---

local timer = require 'timer'()

describe('hump.timer', function()
  it('runs a function during a specified time', function()
    local delta, remaining

    timer:during(10, function(...) delta, remaining = ... end)

    timer:update(2)
    assert.are.equal(delta, 2)
    assert.are.equal(8, remaining)

    timer:update(5)
    assert.are.equal(delta, 5)
    assert.are.equal(3, remaining)

    timer:update(10)
    assert.are.equal(delta, 10)
    assert.are.equal(0, remaining)
  end)

  it('runs a function after a specified time', function()
    local finished1 = false
    local finished2 = false

    timer:after(3, function(...) finished1 = true end)
    timer:after(5, function(...) finished2 = true end)

    timer:update(4)
    assert.are.equal(true, finished1)
    assert.are.equal(false, finished2)

    timer:update(4)
    assert.are.equal(true, finished1)
    assert.are.equal(true, finished2)
  end)

  it('runs a function every so often', function()
    local count = 0

    timer:every(1, function(...) count = count + 1 end)

    timer:update(3)
    assert.are.equal(3, count)

    timer:update(7)
    assert.are.equal(10, count)
  end)

  it('can script timed events', function()
    local state

    timer:script(function(wait)
      state = 'foo'
      wait(1)
      state = 'bar'
    end)

    assert.are.equal('foo', state)
    timer:update(0.5)
    assert.are.equal('foo', state)
    timer:update(1)
    assert.are.equal('bar', state)
  end)

  it('cancels and clears timer functions', function()
    pending('to be tested...')
  end)

  it('tweens', function()
    pending('to be tested...')
  end)
end)


--- FILE: \lib\Jumper\examples\annotatedPathing.lua ---

-- Tests sample for clearance metrics calculation
-- See Figure 10 at http://aigamedev.com/open/tutorial/clearance-based-pathfinding/
-- Jump Point Search still has some flaws with clearance based pathfinding

local Grid = require 'jumper.grid'
local PF = require 'jumper.pathfinder'
local map = {
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,1,0,0,0,0,0,0},
	{0,0,1,0,0,0,0,0,2,0},
	{0,0,1,1,1,0,0,2,0,0},
	{0,0,0,1,1,0,2,0,0,2},
	{0,0,0,0,1,0,0,0,0,2},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0}
}
local grid = Grid(map)
local walkable = function(v) return v~=2 end
local finder = PF(grid, 'ASTAR',walkable)
finder:annotateGrid()
local finderNames = PF:getFinders()

local sx, sy = 1,1
local ex, ey = 9,9
local agent_size = 2

for i = 1,#finderNames do
	finder:setFinder(finderNames[i])
	local path = finder:getPath(sx, sy, ex, ey, agent_size)
	print(('Algorithm used: %s - Path %s')
		:format(finder:getFinder(), path and 'found' or 'not found'))
	if path then
		for node, count in path:nodes() do
			print(('  Step %d. (%d,%d)')
				:format(count, node:getPos()))
		end
	end
end



--- FILE: \lib\Jumper\examples\customHeuristics.lua ---

--- Example of use for Heuristics

local Grid = require ("jumper.grid")
local Pathfinder = require ("jumper.pathfinder")

local map = {
  {0,0,0,0,0,0},
  {0,0,0,0,0,0},
  {0,1,1,1,1,0},
  {0,0,0,0,0,0},
  {0,0,0,0,0,0},
}

local walkable = 0
local grid = Grid(map)
local myFinder = Pathfinder(grid, 'ASTAR', walkable)

-- Use Euclidian heuristic to evaluate distance
myFinder:setHeuristic('EUCLIDIAN')
myFinder:setHeuristic('DIAGONAL')
myFinder:setHeuristic('MANHATTAN')

-- Custom
local h = function(nodeA, nodeB)
	return (0.1 * (math.abs(nodeA:getX() - nodeB:getX()))
	      + 0.9 * (math.abs(nodeA:getY() - nodeB:getY())))
end
myFinder:setHeuristic(h)

local p = myFinder:getPath(1,1, 6,5)
for node, count in p:nodes() do
  print(('%d. Node(%d,%d)'):format(count, node:getX(), node:getY()))
end
print(('Path length: %.2f'):format(p:getLength()))

-- etc ...


--- FILE: \lib\Jumper\examples\makeClearance.lua ---

-- Tests sample for clearance metrics calculation
-- See Figure 10 at http://aigamedev.com/open/tutorial/clearance-based-pathfinding/
local Grid = require 'jumper.grid'
local PF = require 'jumper.pathfinder'
local map = {
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,1,0,0,0,0,0,0},
	{0,0,1,0,0,0,0,0,2,0},
	{0,0,1,1,1,0,0,2,0,0},
	{0,0,0,1,1,0,2,0,0,2},
	{0,0,0,0,1,0,0,0,0,2},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0}
}
local grid = Grid(map)
local walkable = function(v) return v~=2 end
local finder = PF(grid, 'ASTAR',walkable)
finder:annotateGrid()

for y = 1, #map do
	local s = ''
	for x = 1, #map[y] do
	  local node = grid:getNodeAt(x,y)
		s = (s .. ' ' .. node:getClearance(walkable))
	end
	print(s)
end

-- Expected output
--  6 6 5 5 4 4 4 3 2 1
--  6 5 5 4 4 3 3 3 2 1
--  6 5 4 4 3 3 2 2 2 1
--  6 5 4 3 3 2 2 1 1 1
--  6 5 4 3 2 2 1 1 0 1
--  5 5 4 3 2 1 1 0 1 1
--  4 4 4 3 2 1 0 2 1 0
--  3 3 3 3 3 3 3 2 1 0
--  2 2 2 2 2 2 2 2 2 1
--  1 1 1 1 1 1 1 1 1 1



--- FILE: \lib\Jumper\examples\simpleExample.lua ---

--- Very minimal usage example for Jumper

-- Set up a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
-- Calls the grid class
local Grid = require ("jumper.grid")
-- Calls the pathfinder class
local Pathfinder = require ("jumper.pathfinder")

-- Creates a grid object
local grid = Grid(map)

-- Creates a pathfinder object using Jump Point Search algorithm
local myFinder = Pathfinder(grid, 'JPS', walkable)

-- Define start and goal locations coordinates
local startx, starty = 1,1
local endx, endy = 5,1

-- Calculates the path, and its length
local path = myFinder:getPath(startx, starty, endx, endy)

-- Pretty-printing the results
if path then
  print(('Path found! Length: %.2f'):format(path:getLength()))
	for node, count in path:nodes() do
	  print(('Step: %d - x: %d - y: %d'):format(count, node:getX(), node:getY()))
	end
end


--- FILE: \lib\Jumper\jumper\grid.lua ---

--- The Grid class.
-- Implementation of the `grid` class.
-- The `grid` is a implicit graph which represents the 2D
-- world map layout on which the `pathfinder` object will run.
-- During a search, the `pathfinder` object needs to save some critical values. These values are cached within each `node`
-- object, and the whole set of nodes are tight inside the `grid` object itself.

if (...) then

	-- Dependencies
  local _PATH = (...):gsub('%.grid$','')

	-- Local references
  local Utils = require (_PATH .. '.core.utils')
  local Assert = require (_PATH .. '.core.assert')
  local Node = require (_PATH .. '.core.node')

	-- Local references
  local pairs = pairs
  local assert = assert
  local next = next
	local setmetatable = setmetatable
  local floor = math.floor
	local coroutine = coroutine

  -- Offsets for straights moves
  local straightOffsets = {
    {x = 1, y = 0} --[[W]], {x = -1, y =  0}, --[[E]]
    {x = 0, y = 1} --[[S]], {x =  0, y = -1}, --[[N]]
  }

  -- Offsets for diagonal moves
  local diagonalOffsets = {
    {x = -1, y = -1} --[[NW]], {x = 1, y = -1}, --[[NE]]
    {x = -1, y =  1} --[[SW]], {x = 1, y =  1}, --[[SE]]
  }

	--- The `Grid` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Grid(...)</code> _acts as a shortcut to_ <code>Grid:new(...)</code>.
	-- @type Grid
  local Grid = {}
  Grid.__index = Grid

  -- Specialized grids
  local PreProcessGrid = setmetatable({},Grid)
  local PostProcessGrid = setmetatable({},Grid)
  PreProcessGrid.__index = PreProcessGrid
  PostProcessGrid.__index = PostProcessGrid
  PreProcessGrid.__call = function (self,x,y)
    return self:getNodeAt(x,y)
  end
  PostProcessGrid.__call = function (self,x,y,create)
    if create then return self:getNodeAt(x,y) end
    return self._nodes[y] and self._nodes[y][x]
  end

  --- Inits a new `grid`
  -- @class function
  -- @tparam table|string map A collision map - (2D array) with consecutive indices (starting at 0 or 1)
	-- or a `string` with line-break chars (<code>\n</code> or <code>\r</code>) as row delimiters.
  -- @tparam[opt] bool cacheNodeAtRuntime When __true__, returns an empty `grid` instance, so that
	-- later on, indexing a non-cached `node` will cause it to be created and cache within the `grid` on purpose (i.e, when needed).
	-- This is a __memory-safe__ option, in case your dealing with some tight memory constraints.
	-- Defaults to __false__ when omitted.
  -- @treturn grid a new `grid` instance
	-- @usage
	-- -- A simple 3x3 grid
	-- local myGrid = Grid:new({{0,0,0},{0,0,0},{0,0,0}})
	--
	-- -- A memory-safe 3x3 grid
	-- myGrid = Grid('000\n000\n000', true)
  function Grid:new(map, cacheNodeAtRuntime)
		if type(map) == 'string' then
			assert(Assert.isStrMap(map), 'Wrong argument #1. Not a valid string map')
			map = Utils.strToMap(map)
		end
    assert(Assert.isMap(map),('Bad argument #1. Not a valid map'))
    assert(Assert.isBool(cacheNodeAtRuntime) or Assert.isNil(cacheNodeAtRuntime),
      ('Bad argument #2. Expected \'boolean\', got %s.'):format(type(cacheNodeAtRuntime)))
    if cacheNodeAtRuntime then
      return PostProcessGrid:new(map,walkable)
    end
    return PreProcessGrid:new(map,walkable)
  end

  --- Checks if `node` at [x,y] is __walkable__.
	-- Will check if `node` at location [x,y] both *exists* on the collision map and *is walkable*
  -- @class function
  -- @tparam int x the x-location of the node
  -- @tparam int y the y-location of the node
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- If this parameter is a function, it should be prototyped as __f(value)__ and return a `boolean`:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise. If this parameter is not given
  -- while location [x,y] __is valid__, this actual function returns __true__.
  -- @tparam[optchain] int clearance the amount of clearance needed. Defaults to 1 (normal clearance) when not given.
  -- @treturn bool __true__ if `node` exists and is __walkable__, __false__ otherwise
	-- @usage
	-- -- Always true
	-- print(myGrid:isWalkableAt(2,3))
	--
	-- -- True if node at [2,3] collision map value is 0
	-- print(myGrid:isWalkableAt(2,3,0))
	--
	-- -- True if node at [2,3] collision map value is 0 and has a clearance higher or equal to 2
	-- print(myGrid:isWalkableAt(2,3,0,2))
	--
  function Grid:isWalkableAt(x, y, walkable, clearance)
    local nodeValue = self._map[y] and self._map[y][x]
    if nodeValue then
      if not walkable then return true end
    else
			return false
    end
		local hasEnoughClearance = not clearance and true or false
		if not hasEnoughClearance then
			if not self._isAnnotated[walkable] then return false end
			local node = self:getNodeAt(x,y)
			local nodeClearance = node:getClearance(walkable)
			hasEnoughClearance = (nodeClearance >= clearance)
		end
    if self._eval then
			return walkable(nodeValue) and hasEnoughClearance
		end
    return ((nodeValue == walkable) and hasEnoughClearance)
  end

  --- Returns the `grid` width.
  -- @class function
  -- @treturn int the `grid` width
	-- @usage print(myGrid:getWidth())
  function Grid:getWidth()
    return self._width
  end

  --- Returns the `grid` height.
  -- @class function
  -- @treturn int the `grid` height
	-- @usage print(myGrid:getHeight())
  function Grid:getHeight()
     return self._height
  end

  --- Returns the collision map.
  -- @class function
  -- @treturn map the collision map (see @{Grid:new})
	-- @usage local map = myGrid:getMap()
  function Grid:getMap()
    return self._map
  end

  --- Returns the set of nodes.
  -- @class function
  -- @treturn {{node,...},...} an array of nodes
	-- @usage local nodes = myGrid:getNodes()
  function Grid:getNodes()
    return self._nodes
  end

  --- Returns the `grid` bounds. Returned values corresponds to the upper-left
	-- and lower-right coordinates (in tile units) of the actual `grid` instance.
  -- @class function
  -- @treturn int the upper-left corner x-coordinate
  -- @treturn int the upper-left corner y-coordinate
  -- @treturn int the lower-right corner x-coordinate
  -- @treturn int the lower-right corner y-coordinate
	-- @usage local left_x, left_y, right_x, right_y = myGrid:getBounds()
	function Grid:getBounds()
		return self._min_x, self._min_y,self._max_x, self._max_y
	end

  --- Returns neighbours. The returned value is an array of __walkable__ nodes neighbouring a given `node`.
  -- @class function
  -- @tparam node node a given `node`
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool allowDiagonal when __true__, allows adjacent nodes are included (8-neighbours).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool tunnel When __true__, allows the `pathfinder` to tunnel through walls when heading diagonally.
  -- @tparam[optchain] int clearance When given, will prune for the neighbours set all nodes having a clearance value lower than the passed-in value
	-- Defaults to __false__ when omitted.
  -- @treturn {node,...} an array of nodes neighbouring a given node
	-- @usage
	-- local aNode = myGrid:getNodeAt(5,6)
	-- local neighbours = myGrid:getNeighbours(aNode, 0, true)
  function Grid:getNeighbours(node, walkable, allowDiagonal, tunnel, clearance)
		local neighbours = {}
    for i = 1,#straightOffsets do
      local n = self:getNodeAt(
        node._x + straightOffsets[i].x,
        node._y + straightOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
        neighbours[#neighbours+1] = n
      end
    end

    if not allowDiagonal then return neighbours end

		tunnel = not not tunnel
    for i = 1,#diagonalOffsets do
      local n = self:getNodeAt(
        node._x + diagonalOffsets[i].x,
        node._y + diagonalOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
				if tunnel then
					neighbours[#neighbours+1] = n
				else
					local skipThisNode = false
					local n1 = self:getNodeAt(node._x+diagonalOffsets[i].x, node._y)
					local n2 = self:getNodeAt(node._x, node._y+diagonalOffsets[i].y)
					if ((n1 and n2) and not self:isWalkableAt(n1._x, n1._y, walkable, clearance) and not self:isWalkableAt(n2._x, n2._y, walkable, clearance)) then
						skipThisNode = true
					end
					if not skipThisNode then neighbours[#neighbours+1] = n end
				end
      end
    end

    return neighbours
  end

  --- Grid iterator. Iterates on every single node
  -- in the `grid`. Passing __lx, ly, ex, ey__ arguments will iterate
  -- only on nodes inside the bounding-rectangle delimited by those given coordinates.
  -- @class function
  -- @tparam[opt] int lx the leftmost x-coordinate of the rectangle. Default to the `grid` leftmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ly the topmost y-coordinate of the rectangle. Default to the `grid` topmost y-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ex the rightmost x-coordinate of the rectangle. Default to the `grid` rightmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ey the bottom-most y-coordinate of the rectangle. Default to the `grid` bottom-most y-coordinate (see @{Grid:getBounds}).
  -- @treturn node a `node` on the collision map, upon each iteration step
  -- @treturn int the iteration count
	-- @usage
	-- for node, count in myGrid:iter() do
	--   print(node:getX(), node:getY(), count)
	-- end
  function Grid:iter(lx,ly,ex,ey)
    local min_x = lx or self._min_x
    local min_y = ly or self._min_y
    local max_x = ex or self._max_x
    local max_y = ey or self._max_y

    local x, y
    y = min_y
    return function()
      x = not x and min_x or x+1
      if x > max_x then
        x = min_x
        y = y+1
      end
      if y > max_y then
        y = nil
      end
      return self._nodes[y] and self._nodes[y][x] or self:getNodeAt(x,y)
    end
  end

	--- Grid iterator. Iterates on each node along the outline (border) of a squared area
	-- centered on the given node.
	-- @tparam node node a given `node`
	-- @tparam[opt] int radius the area radius (half-length). Defaults to __1__ when not given.
	-- @treturn node a `node` at each iteration step
	-- @usage
	-- for node in myGrid:around(node, 2) do
	--   ...
	-- end
	function Grid:around(node, radius)
		local x, y = node._x, node._y
		radius = radius or 1
		local _around = Utils.around()
		local _nodes = {}
		repeat
			local state, x, y = coroutine.resume(_around,x,y,radius)
			local nodeAt = state and self:getNodeAt(x, y)
			if nodeAt then _nodes[#_nodes+1] = nodeAt end
		until (not state)
		local _i = 0
		return function()
			_i = _i+1
			return _nodes[_i]
		end
	end

  --- Each transformation. Calls the given function on each `node` in the `grid`,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:each(printNode)
  function Grid:each(f,...)
    for node in self:iter() do f(node,...) end
		return self
  end

  --- Each (in range) transformation. Calls a function on each `node` in the range of a rectangle of cells,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:eachRange(1,1,8,8,printNode)
  function Grid:eachRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do f(node,...) end
		return self
  end

  --- Map transformation.
	-- Calls function __f(node,...)__ on each `node` in a given range, passing the `node` as the first arg to function __f__ and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(nothing)
  function Grid:imap(f,...)
    for node in self:iter() do
      node = f(node,...)
    end
		return self
  end

  --- Map in range transformation.
	-- Calls function __f(node,...)__ on each `node` in a rectangle range, passing the `node` as the first argument to the function and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
	-- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(1,1,6,6,nothing)
  function Grid:imapRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do
      node = f(node,...)
    end
		return self
  end

  -- Specialized grids
  -- Inits a preprocessed grid
  function PreProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes, newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.arrayToNodes(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}
    return setmetatable(newGrid,PreProcessGrid)
  end

  -- Inits a postprocessed grid
  function PostProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes = {}
    newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.getArrayBounds(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}		
    return setmetatable(newGrid,PostProcessGrid)
  end

  --- Returns the `node` at location [x,y].
  -- @class function
  -- @name Grid:getNodeAt
  -- @tparam int x the x-coordinate coordinate
  -- @tparam int y the y-coordinate coordinate
  -- @treturn node a `node`
	-- @usage local aNode = myGrid:getNodeAt(2,2)

  -- Gets the node at location <x,y> on a preprocessed grid
  function PreProcessGrid:getNodeAt(x,y)
    return self._nodes[y] and self._nodes[y][x] or nil
  end

  -- Gets the node at location <x,y> on a postprocessed grid
  function PostProcessGrid:getNodeAt(x,y)
    if not x or not y then return end
    if Utils.outOfRange(x,self._min_x,self._max_x) then return end
    if Utils.outOfRange(y,self._min_y,self._max_y) then return end
    if not self._nodes[y] then self._nodes[y] = {} end
    if not self._nodes[y][x] then self._nodes[y][x] = Node:new(x,y) end
    return self._nodes[y][x]
  end

  return setmetatable(Grid,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end


--- FILE: \lib\Jumper\jumper\pathfinder.lua ---

--- The Pathfinder class

--
-- Implementation of the `pathfinder` class.

local _VERSION = ""
local _RELEASEDATE = ""

if (...) then

  -- Dependencies
  local _PATH = (...):gsub('%.pathfinder$','')
	local Utils     = require (_PATH .. '.core.utils')
	local Assert    = require (_PATH .. '.core.assert')
  local Heap      = require (_PATH .. '.core.bheap')
  local Heuristic = require (_PATH .. '.core.heuristics')
  local Grid      = require (_PATH .. '.grid')
  local Path      = require (_PATH .. '.core.path')

  -- Internalization
  local t_insert, t_remove = table.insert, table.remove
	local floor = math.floor
  local pairs = pairs
  local assert = assert
	local type = type
  local setmetatable, getmetatable = setmetatable, getmetatable

	--- Finders (search algorithms implemented). Refers to the search algorithms actually implemented in Jumper.
	--
	-- <li>[A*](http://en.wikipedia.org/wiki/A*_search_algorithm)</li>
	-- <li>[Dijkstra](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)</li>
	-- <li>[Theta Astar](http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/)</li>
	-- <li>[BFS](http://en.wikipedia.org/wiki/Breadth-first_search)</li>
	-- <li>[DFS](http://en.wikipedia.org/wiki/Depth-first_search)</li>
	-- <li>[JPS](http://harablog.wordpress.com/2011/09/07/jump-point-search/)</li>
	-- @finder Finders
	-- @see Pathfinder:getFinders
  local Finders = {
    ['ASTAR']     = require (_PATH .. '.search.astar'),
    ['DIJKSTRA']  = require (_PATH .. '.search.dijkstra'),
    ['THETASTAR'] = require (_PATH .. '.search.thetastar'),
    ['BFS']       = require (_PATH .. '.search.bfs'),
    ['DFS']       = require (_PATH .. '.search.dfs'),
    ['JPS']       = require (_PATH .. '.search.jps')
  }

  -- Will keep track of all nodes expanded during the search
  -- to easily reset their properties for the next pathfinding call
  local toClear = {}

	--- Search modes. Refers to the search modes. In ORTHOGONAL mode, 4-directions are only possible when moving,
	-- including North, East, West, South. In DIAGONAL mode, 8-directions are possible when moving,
	-- including North, East, West, South and adjacent directions.
	--
	-- <li>ORTHOGONAL</li>
	-- <li>DIAGONAL</li>
	-- @mode Modes
	-- @see Pathfinder:getModes
  local searchModes = {['DIAGONAL'] = true, ['ORTHOGONAL'] = true}

  -- Performs a traceback from the goal node to the start node
  -- Only happens when the path was found

	--- The `Pathfinder` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Pathfinder(...)</code> _acts as a shortcut to_ <code>Pathfinder:new(...)</code>.
	-- @type Pathfinder
  local Pathfinder = {}
  Pathfinder.__index = Pathfinder

  --- Inits a new `pathfinder`
  -- @class function
  -- @tparam grid grid a `grid`
  -- @tparam[opt] string finderName the name of the `Finder` (search algorithm) to be used for search.
	-- Defaults to `ASTAR` when not given (see @{Pathfinder:getFinders}).
  -- @tparam[optchain] string|int|func walkable the value for __walkable__ nodes.
  -- If this parameter is a function, it should be prototyped as __f(value)__, returning a boolean:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise.
  -- @treturn pathfinder a new `pathfinder` instance
	-- @usage
	-- -- Example one
	-- local finder = Pathfinder:new(myGrid, 'ASTAR', 0)
	--
	-- -- Example two
	-- local function walkable(value)
	--   return value > 0
	-- end
	-- local finder = Pathfinder(myGrid, 'JPS', walkable)
  function Pathfinder:new(grid, finderName, walkable)
    local newPathfinder = {}
    setmetatable(newPathfinder, Pathfinder)
	  newPathfinder:setGrid(grid)
    newPathfinder:setFinder(finderName)
    newPathfinder:setWalkable(walkable)
    newPathfinder:setMode('DIAGONAL')
    newPathfinder:setHeuristic('MANHATTAN')
    newPathfinder:setTunnelling(false)
    return newPathfinder
  end

	--- Evaluates [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)
	-- for the whole `grid`. It should be called only once, unless the collision map or the
	-- __walkable__ attribute changes. The clearance values are calculated and cached within the grid nodes.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:annotateGrid()
	function Pathfinder:annotateGrid()
		assert(self._walkable, 'Finder must implement a walkable value')
		for x=self._grid._max_x,self._grid._min_x,-1 do
			for y=self._grid._max_y,self._grid._min_y,-1 do
				local node = self._grid:getNodeAt(x,y)
				if self._grid:isWalkableAt(x,y,self._walkable) then
					local nr = self._grid:getNodeAt(node._x+1, node._y)
					local nrd = self._grid:getNodeAt(node._x+1, node._y+1)
					local nd = self._grid:getNodeAt(node._x, node._y+1)
					if nr and nrd and nd then
						local m = nrd._clearance[self._walkable] or 0
						m = (nd._clearance[self._walkable] or 0)<m and (nd._clearance[self._walkable] or 0) or m
						m = (nr._clearance[self._walkable] or 0)<m and (nr._clearance[self._walkable] or 0) or m
						node._clearance[self._walkable] = m+1
					else
						node._clearance[self._walkable] = 1
					end
				else node._clearance[self._walkable] = 0
				end
			end
		end
		self._grid._isAnnotated[self._walkable] = true
		return self
	end

	--- Removes [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)values.
	-- Clears cached clearance values for the current __walkable__.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:clearAnnotations()
	function Pathfinder:clearAnnotations()
		assert(self._walkable, 'Finder must implement a walkable value')
		for node in self._grid:iter() do
			node:removeClearance(self._walkable)
		end
		self._grid._isAnnotated[self._walkable] = false
		return self
	end

  --- Sets the `grid`. Defines the given `grid` as the one on which the `pathfinder` will perform the search.
  -- @class function
  -- @tparam grid grid a `grid`
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setGrid(myGrid)
  function Pathfinder:setGrid(grid)
    assert(Assert.inherits(grid, Grid), 'Wrong argument #1. Expected a \'grid\' object')
    self._grid = grid
    self._grid._eval = self._walkable and type(self._walkable) == 'function'
    return self
  end

  --- Returns the `grid`. This is a reference to the actual `grid` used by the `pathfinder`.
  -- @class function
  -- @treturn grid the `grid`
	-- @usage local myGrid = myFinder:getGrid()
  function Pathfinder:getGrid()
    return self._grid
  end

  --- Sets the __walkable__ value or function.
  -- @class function
  -- @tparam string|int|func walkable the value for walkable nodes.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- -- Value '0' is walkable
	-- myFinder:setWalkable(0)
	--
	-- -- Any value greater than 0 is walkable
	-- myFinder:setWalkable(function(n)
	--   return n>0
	-- end
  function Pathfinder:setWalkable(walkable)
    assert(Assert.matchType(walkable,'stringintfunctionnil'),
      ('Wrong argument #1. Expected \'string\', \'number\' or \'function\', got %s.'):format(type(walkable)))
    self._walkable = walkable
    self._grid._eval = type(self._walkable) == 'function'
    return self
  end

  --- Gets the __walkable__ value or function.
  -- @class function
  -- @treturn string|int|func the `walkable` value or function
	-- @usage local walkable = myFinder:getWalkable()
  function Pathfinder:getWalkable()
    return self._walkable
  end

  --- Defines the `finder`. It refers to the search algorithm used by the `pathfinder`.
  -- Default finder is `ASTAR`. Use @{Pathfinder:getFinders} to get the list of available finders.
  -- @class function
  -- @tparam string finderName the name of the `finder` to be used for further searches.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- --To use Breadth-First-Search
	-- myFinder:setFinder('BFS')
	-- @see Pathfinder:getFinders
  function Pathfinder:setFinder(finderName)
		if not finderName then
			if not self._finder then
				finderName = 'ASTAR'
			else return
			end
		end
    assert(Finders[finderName],'Not a valid finder name!')
    self._finder = finderName
    return self
  end

  --- Returns the name of the `finder` being used.
  -- @class function
  -- @treturn string the name of the `finder` to be used for further searches.
	-- @usage local finderName = myFinder:getFinder()
  function Pathfinder:getFinder()
    return self._finder
  end

  --- Returns the list of all available finders names.
  -- @class function
  -- @treturn {string,...} array of built-in finders names.
	-- @usage
	-- local finders = myFinder:getFinders()
	-- for i, finderName in ipairs(finders) do
	--   print(i, finderName)
	-- end
  function Pathfinder:getFinders()
    return Utils.getKeys(Finders)
  end

  --- Sets a heuristic. This is a function internally used by the `pathfinder` to find the optimal path during a search.
  -- Use @{Pathfinder:getHeuristics} to get the list of all available `heuristics`. One can also define
  -- his own `heuristic` function.
  -- @class function
  -- @tparam func|string heuristic `heuristic` function, prototyped as __f(dx,dy)__ or as a `string`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getHeuristics
	-- @see core.heuristics
	-- @usage myFinder:setHeuristic('MANHATTAN')
  function Pathfinder:setHeuristic(heuristic)
    assert(Heuristic[heuristic] or (type(heuristic) == 'function'),'Not a valid heuristic!')
    self._heuristic = Heuristic[heuristic] or heuristic
    return self
  end

  --- Returns the `heuristic` used. Returns the function itself.
  -- @class function
  -- @treturn func the `heuristic` function being used by the `pathfinder`
	-- @see core.heuristics
	-- @usage local h = myFinder:getHeuristic()
  function Pathfinder:getHeuristic()
    return self._heuristic
  end

  --- Gets the list of all available `heuristics`.
  -- @class function
  -- @treturn {string,...} array of heuristic names.
	-- @see core.heuristics
	-- @usage
	-- local heur = myFinder:getHeuristic()
	-- for i, heuristicName in ipairs(heur) do
	--   ...
	-- end
  function Pathfinder:getHeuristics()
    return Utils.getKeys(Heuristic)
  end

  --- Defines the search `mode`.
  -- The default search mode is the `DIAGONAL` mode, which implies 8-possible directions when moving (north, south, east, west and diagonals).
  -- In `ORTHOGONAL` mode, only 4-directions are allowed (north, south, east and west).
  -- Use @{Pathfinder:getModes} to get the list of all available search modes.
  -- @class function
  -- @tparam string mode the new search `mode`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getModes
	-- @see Modes
	-- @usage myFinder:setMode('ORTHOGONAL')
  function Pathfinder:setMode(mode)
    assert(searchModes[mode],'Invalid mode')
    self._allowDiagonal = (mode == 'DIAGONAL')
    return self
  end

  --- Returns the search mode.
  -- @class function
  -- @treturn string the current search mode
	-- @see Modes
	-- @usage local mode = myFinder:getMode()
  function Pathfinder:getMode()
    return (self._allowDiagonal and 'DIAGONAL' or 'ORTHOGONAL')
  end

  --- Gets the list of all available search modes.
  -- @class function
  -- @treturn {string,...} array of search modes.
	-- @see Modes
	-- @usage local modes = myFinder:getModes()
	-- for modeName in ipairs(modes) do
	--   ...
	-- end
  function Pathfinder:getModes()
    return Utils.getKeys(searchModes)
  end

  --- Enables tunnelling. Defines the ability for the `pathfinder` to tunnel through walls when heading diagonally.
	-- This feature __is not compatible__ with Jump Point Search algorithm (i.e. enabling it will not affect Jump Point Search)
  -- @class function
  -- @tparam bool bool a boolean
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setTunnelling(true)
  function Pathfinder:setTunnelling(bool)
    assert(Assert.isBool(bool), ('Wrong argument #1. Expected boolean, got %s'):format(type(bool)))
		self._tunnel = bool
		return self
  end

  --- Returns tunnelling feature state.
  -- @class function
	-- @treturn bool tunnelling feature actual state
	-- @usage local isTunnellingEnabled = myFinder:getTunnelling()
  function Pathfinder:getTunnelling()
		return self._tunnel
  end

  --- Calculates a `path`. Returns the `path` from location __[startX, startY]__ to location __[endX, endY]__.
  -- Both locations must exist on the collision map. The starting location can be unwalkable.
  -- @class function
  -- @tparam int startX the x-coordinate for the starting location
  -- @tparam int startY the y-coordinate for the starting location
  -- @tparam int endX the x-coordinate for the goal location
  -- @tparam int endY the y-coordinate for the goal location
  -- @tparam int clearance the amount of clearance (i.e the pathing agent size) to consider
  -- @treturn path a path (array of nodes) when found, otherwise nil
	-- @usage local path = myFinder:getPath(1,1,5,5)
  function Pathfinder:getPath(startX, startY, endX, endY, clearance)
		self:reset()
    local startNode = self._grid:getNodeAt(startX, startY)
    local endNode = self._grid:getNodeAt(endX, endY)
    assert(startNode, ('Invalid location [%d, %d]'):format(startX, startY))
    assert(endNode and self._grid:isWalkableAt(endX, endY),
      ('Invalid or unreachable location [%d, %d]'):format(endX, endY))
    local _endNode = Finders[self._finder](self, startNode, endNode, clearance, toClear)
    if _endNode then
			return Utils.traceBackPath(self, _endNode, startNode)
    end
    return nil
  end

  --- Resets the `pathfinder`. This function is called internally between successive pathfinding calls, so you should not
	-- use it explicitely, unless under specific circumstances.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage local path, len = myFinder:getPath(1,1,5,5)
	function Pathfinder:reset()
    for node in pairs(toClear) do node:reset() end
    toClear = {}
		return self
	end


  -- Returns Pathfinder class
	Pathfinder._VERSION = _VERSION
	Pathfinder._RELEASEDATE = _RELEASEDATE
  return setmetatable(Pathfinder,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end


--- FILE: \lib\Jumper\jumper\core\assert.lua ---

-- Various assertion function for API methods argument-checking

if (...) then
	
	-- Dependancies
	local _PATH = (...):gsub('%.core.assert$','')
	local Utils = require (_PATH .. '.core.utils')
	
	-- Local references
	local lua_type = type
	local floor = math.floor
	local concat = table.concat
	local next = next
	local pairs = pairs
	local getmetatable = getmetatable
	
	-- Is I an integer ?
	local function isInteger(i)
		return lua_type(i) ==('number') and (floor(i)==i)
	end
	
	-- Override lua_type to return integers
	local function type(v)
		return isInteger(v) and 'int' or lua_type(v)
	end
	
	-- Does the given array contents match a predicate type ?
	local function arrayContentsMatch(t,...)
		local n_count = Utils.arraySize(t)
		if n_count < 1 then return false end
		local init_count = t[0] and 0 or 1
		local n_count = (t[0] and n_count-1 or n_count)
		local types = {...}
		if types then types = concat(types) end
		for i=init_count,n_count,1 do
			if not t[i] then return false end
			if types then
				if not types:match(type(t[i])) then return false end
			end
		end
		return true
	end	
	
	-- Checks if arg is a valid array map
  local function isMap(m)
		if not arrayContentsMatch(m, 'table') then return false end
		local lsize = Utils.arraySize(m[next(m)])
		for k,v in pairs(m) do
			if not arrayContentsMatch(m[k], 'string', 'int') then return false end
			if Utils.arraySize(v)~=lsize then return false end
		end
		return true
  end	
	
	-- Checks if s is a valid string map
  local function isStringMap(s)
    if lua_type(s) ~= 'string' then return false end
    local w
    for row in s:gmatch('[^\n\r]+') do
      if not row then return false end
      w = w or #row
      if w ~= #row then return false end
    end
    return true
  end

	-- Does instance derive straight from class
	local function derives(instance, class)
		return getmetatable(instance) == class
	end
	
	-- Does instance inherits from class	
	local function inherits(instance, class)
		return (getmetatable(getmetatable(instance)) == class)
	end
	
	-- Is arg a boolean
	local function isBoolean(b) 
		return (b==true or b==false)
	end
	
	-- Is arg nil ?
	local function isNil(n)
		return (n==nil)
	end
	
	local function matchType(value, types)
		return types:match(type(value))	
	end
	
	return {
		arrayContentsMatch = arrayContentsMatch,
		derives = derives,
		inherits = inherits,
		isInteger = isInteger,
		isBool = isBoolean,
		isMap = isMap,
		isStrMap = isStringMap,
		isOutOfRange = isOutOfRange,
		isNil = isNil,
		type = type,
		matchType = matchType
	}

end




--- FILE: \lib\Jumper\jumper\core\bheap.lua ---

--- A light implementation of Binary heaps data structure.
-- While running a search, some search algorithms (Astar, Dijkstra, Jump Point Search) have to maintains
-- a list of nodes called __open list__. Retrieve from this list the lowest cost node can be quite slow, 
-- as it normally requires to skim through the full set of nodes stored in this list. This becomes a real 
-- problem especially when dozens of nodes are being processed (on large maps). 
--
-- The current module implements a <a href="http://www.policyalmanac.org/games/binaryHeaps.htm">binary heap</a>
-- data structure, from which the search algorithm will instantiate an open list, and cache the nodes being 
-- examined during a search. As such, retrieving the lower-cost node is faster and globally makes the search end 
-- up quickly.
-- 
-- This module is internally used by the library on purpose.
-- It should normally not be used explicitely, yet it remains fully accessible.
--

--[[
  Notes:
  This lighter implementation of binary heaps, based on :
    https://github.com/Yonaba/Binary-Heaps
--]]

if (...) then

	-- Dependency
	local Utils = require((...):gsub('%.bheap$','.utils'))
	
	-- Local reference
	local floor = math.floor

	-- Default comparison function
	local function f_min(a,b) return a < b end

	-- Percolates up
	local function percolate_up(heap, index)
		if index == 1 then return end
		local pIndex
		if index <= 1 then return end
		if index%2 == 0 then
			pIndex =  index/2
		else pIndex = (index-1)/2
		end
		if not heap._sort(heap._heap[pIndex], heap._heap[index]) then
			heap._heap[pIndex], heap._heap[index] = 
				heap._heap[index], heap._heap[pIndex]
			percolate_up(heap, pIndex)
		end
	end

	-- Percolates down
	local function percolate_down(heap,index)
		local lfIndex,rtIndex,minIndex
		lfIndex = 2*index
		rtIndex = lfIndex + 1
		if rtIndex > heap._size then
			if lfIndex > heap._size then return
			else minIndex = lfIndex  end
		else
			if heap._sort(heap._heap[lfIndex],heap._heap[rtIndex]) then
				minIndex = lfIndex
			else
				minIndex = rtIndex
			end
		end
		if not heap._sort(heap._heap[index],heap._heap[minIndex]) then
			heap._heap[index],heap._heap[minIndex] = heap._heap[minIndex],heap._heap[index]
			percolate_down(heap,minIndex)
		end
	end

	-- Produces a new heap
	local function newHeap(template,comp)
		return setmetatable({_heap = {},
			_sort = comp or f_min, _size = 0},
		template)
	end


	--- The `heap` class.<br/>
	-- This class is callable.
	-- _Therefore,_ <code>heap(...)</code> _is used to instantiate new heaps_.
	-- @type heap
	local heap = setmetatable({},
		{__call = function(self,...)
			return newHeap(self,...)
		end})
	heap.__index = heap

	--- Checks if a `heap` is empty
	-- @class function
	-- @treturn bool __true__ of no item is queued in the heap, __false__ otherwise
	-- @usage
	-- if myHeap:empty() then 
	--   print('Heap is empty!')
	-- end
	function heap:empty()
		return (self._size==0)
	end

	--- Clears the `heap` (removes all items queued in the heap)
	-- @class function
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage myHeap:clear()
	function heap:clear()
		self._heap = {}
		self._size = 0
		self._sort = self._sort or f_min
		return self
	end

	--- Adds a new item in the `heap`
	-- @class function
	-- @tparam value item a new value to be queued in the heap
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage
	-- myHeap:push(1)
	-- -- or, with chaining
	-- myHeap:push(1):push(2):push(4)
	function heap:push(item)
		if item then
			self._size = self._size + 1
			self._heap[self._size] = item
			percolate_up(self, self._size)
		end
		return self
	end

	--- Pops from the `heap`.
	-- Removes and returns the lowest cost item (with respect to the comparison function being used) from the `heap`.
	-- @class function
	-- @treturn value a value previously pushed into the heap
	-- @usage
	-- while not myHeap:empty() do 
	--   local lowestValue = myHeap:pop()
	--   ...
	-- end
	function heap:pop()
		local root
		if self._size > 0 then
			root = self._heap[1]
			self._heap[1] = self._heap[self._size]
			self._heap[self._size] = nil
			self._size = self._size-1
			if self._size>1 then
				percolate_down(self, 1)
			end
		end
		return root
	end

	--- Restores the `heap` property.
	-- Reorders the `heap` with respect to the comparison function being used. 
	-- When given argument __item__ (a value existing in the `heap`), will sort from that very item in the `heap`. 
	-- Otherwise, the whole `heap` will be cheacked. 
	-- @class function
	-- @tparam[opt] value item the modified value
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage myHeap:heapify() 
	function heap:heapify(item)
		if self._size == 0 then return end
		if item then
			local i = Utils.indexOf(self._heap,item)
			if i then 
				percolate_down(self, i)
				percolate_up(self, i)
			end
			return
		end
		for i = floor(self._size/2),1,-1 do
			percolate_down(self,i)
		end
		return self
	end

	return heap
end


--- FILE: \lib\Jumper\jumper\core\heuristics.lua ---

--- Heuristic functions for search algorithms.
-- A <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">distance heuristic</a> 
-- provides an *estimate of the optimal distance cost* from a given location to a target. 
-- As such, it guides the pathfinder to the goal, helping it to decide which route is the best.
--
-- This script holds the definition of some built-in heuristics available through jumper.
--
-- Distance functions are internally used by the `pathfinder` to evaluate the optimal path
-- from the start location to the goal. These functions share the same prototype:
--     local function myHeuristic(nodeA, nodeB)
--       -- function body
--     end
-- Jumper features some built-in distance heuristics, namely `MANHATTAN`, `EUCLIDIAN`, `DIAGONAL`, `CARDINTCARD`.
-- You can also supply your own heuristic function, following the same template as above.


local abs = math.abs
local sqrt = math.sqrt
local sqrt2 = sqrt(2)
local max, min = math.max, math.min

local Heuristics = {}
  --- Manhattan distance.
  -- <br/>This heuristic is the default one being used by the `pathfinder` object.
  -- <br/>Evaluates as <code>distance = |dx|+|dy|</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('MANHATTAN')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.MANHATTAN)
  function Heuristics.MANHATTAN(nodeA, nodeB) 
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)
		return (dx + dy) 
	end
  
  --- Euclidian distance.
  -- <br/>Evaluates as <code>distance = squareRoot(dx*dx+dy*dy)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('EUCLIDIAN')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.EUCLIDIAN) 
  function Heuristics.EUCLIDIAN(nodeA, nodeB)
		local dx = nodeA._x - nodeB._x
		local dy = nodeA._y - nodeB._y
		return sqrt(dx*dx+dy*dy) 
	end
  
  --- Diagonal distance.
  -- <br/>Evaluates as <code>distance = max(|dx|, abs|dy|)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('DIAGONAL')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.DIAGONAL)
  function Heuristics.DIAGONAL(nodeA, nodeB)
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)	
		return max(dx,dy) 
	end
  
  --- Cardinal/Intercardinal distance.
  -- <br/>Evaluates as <code>distance = min(dx, dy)*squareRoot(2) + max(dx, dy) - min(dx, dy)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('CARDINTCARD')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.CARDINTCARD)
  function Heuristics.CARDINTCARD(nodeA, nodeB)
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)	
    return min(dx,dy) * sqrt2 + max(dx,dy) - min(dx,dy)
  end

return Heuristics


--- FILE: \lib\Jumper\jumper\core\lookuptable.lua ---

local addNode(self, node, nextNode, ed)
	if not self._pathDB[node] then self._pathDB[node] = {} end
	self._pathDB[node][ed] = (nextNode == ed and node or nextNode)
end

-- Path lookupTable
local lookupTable = {}
lookupTable.__index = lookupTable

function lookupTable:new()
	local lut = {_pathDB = {}}
	return setmetatable(lut, lookupTable)
end

function lookupTable:addPath(path)
	local st, ed = path._nodes[1], path._nodes[#path._nodes]
	for node, count in path:nodes() do
		local nextNode = path._nodes[count+1]
		if nextNode then addNode(self, node, nextNode, ed) end
	end
end

function lookupTable:hasPath(nodeA, nodeB)
	local found
	found = self._pathDB[nodeA] and self._path[nodeA][nodeB]
	if found then return true, true end
	found = self._pathDB[nodeB] and self._path[nodeB][nodeA]
	if found then return true, false end
	return false
end

return lookupTable


--- FILE: \lib\Jumper\jumper\core\node.lua ---

--- The Node class.
-- The `node` represents a cell (or a tile) on a collision map. Basically, for each single cell (tile)
-- in the collision map passed-in upon initialization, a `node` object will be generated
-- and then cached within the `grid`.
--
-- In the following implementation, nodes can be compared using the `<` operator. The comparison is
-- made with regards of their `f` cost. From a given node being examined, the `pathfinder` will expand the search 
-- to the next neighbouring node having the lowest `f` cost. See `core.bheap` for more details.
-- 

if (...) then

	local assert = assert
	
	--- The `Node` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Node(...)</code> _acts as a shortcut to_ <code>Node:new(...)</code>.
	-- @type Node
  local Node = {}
  Node.__index = Node

  --- Inits a new `node`
  -- @class function
  -- @tparam int x the x-coordinate of the node on the collision map
  -- @tparam int y the y-coordinate of the node on the collision map
  -- @treturn node a new `node`
	-- @usage local node = Node(3,4)
  function Node:new(x,y)
    return setmetatable({_x = x, _y = y, _clearance = {}}, Node)
  end

  -- Enables the use of operator '<' to compare nodes.
  -- Will be used to sort a collection of nodes in a binary heap on the basis of their F-cost
  function Node.__lt(A,B) return (A._f < B._f) end

  --- Returns x-coordinate of a `node`
  -- @class function
  -- @treturn number the x-coordinate of the `node`
	-- @usage local x = node:getX()	
	function Node:getX() return self._x end
	
  --- Returns y-coordinate of a `node`
  -- @class function
  -- @treturn number the y-coordinate of the `node`	
	-- @usage local y = node:getY()		
	function Node:getY() return self._y end
	
  --- Returns x and y coordinates of a `node`
  -- @class function
  -- @treturn number the x-coordinate of the `node`
  -- @treturn number the y-coordinate of the `node`
	-- @usage local x, y = node:getPos()		
	function Node:getPos() return self._x, self._y end
	
  --- Returns the amount of true [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric) 
	-- for a given `node`
  -- @class function
  -- @tparam string|int|func walkable the value for walkable locations in the collision map array.
  -- @treturn int the clearance of the `node`
	-- @usage
	--  -- Assuming walkable was 0	
	-- local clearance = node:getClearance(0)		
	function Node:getClearance(walkable)
		return self._clearance[walkable]
	end
	
  --- Removes the clearance value for a given walkable.
  -- @class function
  -- @tparam string|int|func walkable the value for walkable locations in the collision map array.
	-- @treturn node self (the calling `node` itself, can be chained)
	-- @usage
	--  -- Assuming walkable is defined	
	-- node:removeClearance(walkable)	
	function Node:removeClearance(walkable)
		self._clearance[walkable] = nil
		return self
	end
	
	--- Clears temporary cached attributes of a `node`.
	-- Deletes the attributes cached within a given node after a pathfinding call.
	-- This function is internally used by the search algorithms, so you should not use it explicitely.
	-- @class function
	-- @treturn node self (the calling `node` itself, can be chained)
	-- @usage
	-- local thisNode = Node(1,2)
	-- thisNode:reset()
	function Node:reset()
		self._g, self._h, self._f = nil, nil, nil
		self._opened, self._closed, self._parent = nil, nil, nil
		return self
	end
	
  return setmetatable(Node,
		{__call = function(self,...) 
			return Node:new(...) 
		end}
	)
end


--- FILE: \lib\Jumper\jumper\core\path.lua ---

--- The Path class.
-- The `path` class is a structure which represents a path (ordered set of nodes) from a start location to a goal.
-- An instance from this class would be a result of a request addressed to `Pathfinder:getPath`.
--
-- This module is internally used by the library on purpose.
-- It should normally not be used explicitely, yet it remains fully accessible.
--


if (...) then
	
  -- Dependencies
	local _PATH = (...):match('(.+)%.path$')
  local Heuristic = require (_PATH .. '.heuristics')
	
	 -- Local references
  local abs, max = math.abs, math.max
	local t_insert, t_remove = table.insert, table.remove
	
	--- The `Path` class.<br/>
	-- This class is callable.
	-- Therefore, <em><code>Path(...)</code></em> acts as a shortcut to <em><code>Path:new(...)</code></em>.
	-- @type Path
  local Path = {}
  Path.__index = Path

  --- Inits a new `path`.
  -- @class function
  -- @treturn path a `path`
	-- @usage local p = Path()
  function Path:new()
    return setmetatable({_nodes = {}}, Path)
  end

  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns the `node` plus a count value. Aliased as @{Path:nodes}
  -- @class function
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see Path:nodes
	-- @usage
	-- for node, count in p:iter() do
	--   ...
	-- end
  function Path:iter()
    local i,pathLen = 1,#self._nodes
    return function()
      if self._nodes[i] then
        i = i+1
        return self._nodes[i-1],i-1
      end
    end
  end
  
  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns a `node` plus a count value. Alias for @{Path:iter}
  -- @class function
	-- @name Path:nodes
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see Path:iter	
	-- @usage
	-- for node, count in p:nodes() do
	--   ...
	-- end	
	Path.nodes = Path.iter
	
  --- Evaluates the `path` length
  -- @class function
  -- @treturn number the `path` length
	-- @usage local len = p:getLength()
  function Path:getLength()
    local len = 0
    for i = 2,#self._nodes do
      len = len + Heuristic.EUCLIDIAN(self._nodes[i], self._nodes[i-1])
    end
    return len
  end
	
	--- Counts the number of steps.
	-- Returns the number of waypoints (nodes) in the current path.
	-- @class function
	-- @tparam node node a node to be added to the path
	-- @tparam[opt] int index the index at which the node will be inserted. If omitted, the node will be appended after the last node in the path.
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage local nSteps = p:countSteps()
	function Path:addNode(node, index)
		index = index or #self._nodes+1
		t_insert(self._nodes, index, node)
		return self
	end
	
	
  --- `Path` filling modifier. Interpolates between non contiguous nodes along a `path`
  -- to build a fully continuous `path`. This maybe useful when using search algorithms such as Jump Point Search.
  -- Does the opposite of @{Path:filter}
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)	
  -- @see Path:filter
	-- @usage p:fill()
  function Path:fill()
    local i = 2
    local xi,yi,dx,dy
    local N = #self._nodes
    local incrX, incrY
    while true do
      xi,yi = self._nodes[i]._x,self._nodes[i]._y
      dx,dy = xi-self._nodes[i-1]._x,yi-self._nodes[i-1]._y
      if (abs(dx) > 1 or abs(dy) > 1) then
        incrX = dx/max(abs(dx),1)
        incrY = dy/max(abs(dy),1)
        t_insert(self._nodes, i, self._grid:getNodeAt(self._nodes[i-1]._x + incrX, self._nodes[i-1]._y +incrY))
        N = N+1
      else i=i+1
      end
      if i>N then break end
    end
		return self
  end

  --- `Path` compression modifier. Given a `path`, eliminates useless nodes to return a lighter `path` 
	-- consisting of straight moves. Does the opposite of @{Path:fill}
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)	
  -- @see Path:fill
	-- @usage p:filter()
  function Path:filter()
    local i = 2
    local xi,yi,dx,dy, olddx, olddy
    xi,yi = self._nodes[i]._x, self._nodes[i]._y
    dx, dy = xi - self._nodes[i-1]._x, yi-self._nodes[i-1]._y
    while true do
      olddx, olddy = dx, dy
      if self._nodes[i+1] then
        i = i+1
        xi, yi = self._nodes[i]._x, self._nodes[i]._y
        dx, dy = xi - self._nodes[i-1]._x, yi - self._nodes[i-1]._y
        if olddx == dx and olddy == dy then
          t_remove(self._nodes, i-1)
          i = i - 1
        end
      else break end
    end
		return self
  end
	
  --- Clones a `path`.
  -- @class function
  -- @treturn path a `path`
	-- @usage local p = path:clone()	
	function Path:clone()
		local p = Path:new()
		for node in self:nodes() do p:addNode(node) end
		return p
	end
	
  --- Checks if a `path` is equal to another. It also supports *filtered paths* (see @{Path:filter}).
  -- @class function
	-- @tparam path p2 a path
  -- @treturn boolean a boolean
	-- @usage print(myPath:isEqualTo(anotherPath))
	function Path:isEqualTo(p2)
		local p1 = self:clone():filter()
		local p2 = p2:clone():filter()
		for node, count in p1:nodes() do
			if not p2._nodes[count] then return false end
			local n = p2._nodes[count]
			if n._x~=node._x or n._y~=node._y then return false end
		end	
		return true
	end
	
  --- Reverses a `path`.
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage myPath:reverse()	
	function Path:reverse()
		local _nodes = {}
		for i = #self._nodes,1,-1 do
			_nodes[#_nodes+1] = self._nodes[i]		
		end
		self._nodes = _nodes
		return self
	end	

  --- Appends a given `path` to self.
  -- @class function
	-- @tparam path p a path
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage myPath:append(anotherPath)		
	function Path:append(p)
		for node in p:nodes() do self:addNode(node)	end
		return self
	end
	
  return setmetatable(Path,
    {__call = function(self,...)
      return Path:new(...)
    end
  })
end


--- FILE: \lib\Jumper\jumper\core\utils.lua ---

-- Various utilities for Jumper top-level modules

if (...) then

	-- Dependencies
	local _PATH = (...):gsub('%.utils$','')
	local Path = require (_PATH .. '.path')
	local Node = require (_PATH .. '.node')

	-- Local references
	local pairs = pairs
	local type = type
	local t_insert = table.insert
	local assert = assert
	local coroutine = coroutine

	-- Raw array items count
	local function arraySize(t)
		local count = 0
		for k,v in pairs(t) do
			count = count+1
		end
		return count
	end

	-- Parses a string map and builds an array map
  local function stringMapToArray(str)
		local map = {}
		local w, h
    for line in str:gmatch('[^\n\r]+') do
      if line then
        w = not w and #line or w
        assert(#line == w, 'Error parsing map, rows must have the same size!')
        h = (h or 0) + 1
        map[h] = {}
        for char in line:gmatch('.') do
					map[h][#map[h]+1] = char
				end
      end
    end
    return map
  end

	-- Collects and returns the keys of a given array
  local function getKeys(t)
    local keys = {}
    for k,v in pairs(t) do keys[#keys+1] = k end
    return keys
  end

	-- Calculates the bounds of a 2d array
  local function getArrayBounds(map)
    local min_x, max_x
    local min_y, max_y
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
        end
      end
    return min_x,max_x,min_y,max_y
  end

  -- Converts an array to a set of nodes
  local function arrayToNodes(map)
    local min_x, max_x
    local min_y, max_y
    local nodes = {}
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        nodes[y] = {}
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
          nodes[y][x] = Node:new(x,y)
        end
      end
    return nodes,
			 (min_x or 0), (max_x or 0),
			 (min_y or 0), (max_y or 0)
  end

	-- Iterator, wrapped within a coroutine
	-- Iterates around a given position following the outline of a square
	local function around()
		local iterf = function(x0, y0, s)
			local x, y = x0-s, y0-s
			coroutine.yield(x, y)
			repeat
				x = x + 1
				coroutine.yield(x,y)
			until x == x0+s
			repeat
				y = y + 1
				coroutine.yield(x,y)
			until y == y0 + s
			repeat
				x = x - 1
				coroutine.yield(x, y)
			until x == x0-s
			repeat
				y = y - 1
				coroutine.yield(x,y)
			until y == y0-s+1
		end
		return coroutine.create(iterf)
	end

	-- Extract a path from a given start/end position
  local function traceBackPath(finder, node, startNode)
    local path = Path:new()
    path._grid = finder._grid
    while true do
      if node._parent then
        t_insert(path._nodes,1,node)
        node = node._parent
      else
        t_insert(path._nodes,1,startNode)
        return path
      end
    end
  end

	-- Lookup for value in a table
	local indexOf = function(t,v)
		for i = 1,#t do
			if t[i] == v then return i end
		end
		return nil
	end

	-- Is i out of range
  local function outOfRange(i,low,up)
    return (i< low or i > up)
  end
	
	return {
		arraySize = arraySize,
		getKeys = getKeys,
		indexOf = indexOf,
		outOfRange = outOfRange,
		getArrayBounds = getArrayBounds,
		arrayToNodes = arrayToNodes,
		strToMap = stringMapToArray,
		around = around,
		drAround = drAround,
		traceBackPath = traceBackPath
	}

end


--- FILE: \lib\Jumper\jumper\search\astar.lua ---

-- Astar algorithm
-- This actual implementation of A-star is based on
-- [Nash A. & al. pseudocode](http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/)

if (...) then

	-- Internalization
	local ipairs = ipairs
	local huge = math.huge

	-- Dependancies
	local _PATH = (...):match('(.+)%.search.astar$')
	local Heuristics = require (_PATH .. '.core.heuristics')
	local Heap = require (_PATH.. '.core.bheap')

	-- Updates G-cost
	local function computeCost(node, neighbour, finder, clearance)
		local mCost = Heuristics.EUCLIDIAN(neighbour, node)
		if node._g + mCost < neighbour._g then
			neighbour._parent = node
			neighbour._g = node._g + mCost
		end
	end

	-- Updates vertex node-neighbour
	local function updateVertex(finder, openList, node, neighbour, endNode, clearance, heuristic, overrideCostEval)
		local oldG = neighbour._g
		local cmpCost = overrideCostEval or computeCost
		cmpCost(node, neighbour, finder, clearance)
		if neighbour._g < oldG then
			local nClearance = neighbour._clearance[finder._walkable]
			local pushThisNode = clearance and nClearance and (nClearance >= clearance)
			if (clearance and pushThisNode) or (not clearance) then
				if neighbour._opened then neighbour._opened = false end				
				neighbour._h = heuristic(endNode, neighbour)
				neighbour._f = neighbour._g + neighbour._h
				openList:push(neighbour)
				neighbour._opened = true
			end
		end
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear, overrideHeuristic, overrideCostEval)
		
		local heuristic = overrideHeuristic or finder._heuristic
		local openList = Heap()
		startNode._g = 0
		startNode._h = heuristic(endNode, startNode)
		startNode._f = startNode._g + startNode._h
		openList:push(startNode)
		toClear[startNode] = true
		startNode._opened = true

		while not openList:empty() do
			local node = openList:pop()
			node._closed = true
			if node == endNode then return node end
			local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
			for i = 1,#neighbours do
				local neighbour = neighbours[i]
				if not neighbour._closed then
					toClear[neighbour] = true
					if not neighbour._opened then
						neighbour._g = huge
						neighbour._parent = nil	
					end
					updateVertex(finder, openList, node, neighbour, endNode, clearance, heuristic, overrideCostEval)
				end	
			end	
		end
		
		return nil 
	end

end


--- FILE: \lib\Jumper\jumper\search\bfs.lua ---

-- Breadth-First search algorithm

if (...) then
  -- Internalization
  local t_remove = table.remove

  local function breadth_first_search(finder, openList, node, endNode, clearance, toClear)
    local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if not neighbour._closed and not neighbour._opened then
				local nClearance = neighbour._clearance[finder._walkable]
				local pushThisNode = clearance and nClearance and (nClearance >= clearance)			
        if (clearance and pushThisNode) or (not clearance) then
					openList[#openList+1] = neighbour
					neighbour._opened = true
					neighbour._parent = node
					toClear[neighbour] = true
				end
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)

    local openList = {} -- We'll use a FIFO queue (simple array)
    openList[1] = startNode
    startNode._opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[1]
      t_remove(openList,1)
      node._closed = true
      if node == endNode then return node end
      breadth_first_search(finder, openList, node, endNode, clearance, toClear)
    end

    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\dfs.lua ---

-- Depth-First search algorithm.

if (...) then
  -- Internalization
  local t_remove = table.remove

  local function depth_first_search(finder, openList, node, endNode, clearance, toClear)
    local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if (not neighbour._closed and not neighbour._opened) then
				local nClearance = neighbour._clearance[finder._walkable]
				local pushThisNode = clearance and nClearance and (nClearance >= clearance)
				if (clearance and pushThisNode) or (not clearance) then			
					openList[#openList+1] = neighbour
					neighbour._opened = true
					neighbour._parent = node
					toClear[neighbour] = true
				end
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)

    local openList = {} -- We'll use a LIFO queue (simple array)
    openList[1] = startNode
    startNode._opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[#openList]
      t_remove(openList)
      node._closed = true
      if node == endNode then return node end
      depth_first_search(finder, openList, node, endNode, clearance, toClear)
    end

    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\dijkstra.lua ---

-- Dijkstra algorithm (Uses Astar implementation)

if (...) then

  local astar_search = require ((...):gsub('%.dijkstra$','.astar'))
  -- Dijkstra is similar to aStar, with no heuristic
  local dijkstraHeuristic = function() return 0 end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)
    return astar_search(finder, startNode, endNode, clearance, toClear, dijkstraHeuristic)
  end

end


--- FILE: \lib\Jumper\jumper\search\jps.lua ---

-- Jump Point search algorithm

if (...) then

  -- Dependancies
  local _PATH = (...):match('(.+)%.search.jps$')
  local Heuristics = require (_PATH .. '.core.heuristics')
	local Heap = require (_PATH.. '.core.bheap')

  -- Internalization
  local max, abs = math.max, math.abs

  -- Local helpers, these routines will stay private
  -- As they are internally used by the public interface

  -- Resets properties of nodes expanded during a search
  -- This is a lot faster than resetting all nodes
  -- between consecutive pathfinding requests

  --[[
    Looks for the neighbours of a given node.
    Returns its natural neighbours plus forced neighbours when the given
    node has no parent (generally occurs with the starting node).
    Otherwise, based on the direction of move from the parent, returns
    neighbours while pruning directions which will lead to symmetric paths.

    In case diagonal moves are forbidden, when the given node has no
    parent, we return straight neighbours (up, down, left and right).
    Otherwise, we add left and right node (perpendicular to the direction
    of move) in the neighbours list.
  --]]
  local function findNeighbours(finder, node, clearance)

    if node._parent then
      local neighbours = {}
      local x,y = node._x, node._y
      -- Node have a parent, we will prune some neighbours
      -- Gets the direction of move
      local dx = (x-node._parent._x)/max(abs(x-node._parent._x),1)
      local dy = (y-node._parent._y)/max(abs(y-node._parent._y),1)

        -- Diagonal move case
      if dx~=0 and dy~=0 then
        local walkY, walkX

        -- Natural neighbours
        if finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+dy)
          walkY = true
        end
        if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y)
          walkX = true
        end
        if walkX or walkY then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y+dy)
        end

        -- Forced neighbours
        if (not finder._grid:isWalkableAt(x-dx,y,finder._walkable, clearance)) and walkY then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x-dx,y+dy)
        end
        if (not finder._grid:isWalkableAt(x,y-dy,finder._walkable, clearance)) and walkX then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y-dy)
        end

      else
        -- Move along Y-axis case
        if dx==0 then
          local walkY
          if finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
            neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+dy)

            -- Forced neighbours are left and right ahead along Y
            if (not finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+1,y+dy)
            end
            if (not finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x-1,y+dy)
            end
          end
          -- In case diagonal moves are forbidden : Needs to be optimized
          if not finder._allowDiagonal then
            if finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+1,y)
            end
            if finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance)
              then neighbours[#neighbours+1] = finder._grid:getNodeAt(x-1,y)
            end
          end
        else
        -- Move along X-axis case
          if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) then
            neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y)

            -- Forced neighbours are up and down ahead along X
            if (not finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y+1)
            end
            if (not finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y-1)
            end
          end
          -- : In case diagonal moves are forbidden
          if not finder._allowDiagonal then
            if finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+1)
            end
            if finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y-1)
            end
          end
        end
      end
      return neighbours
    end

    -- Node do not have parent, we return all neighbouring nodes
    return finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel, clearance)
  end

  --[[
    Searches for a jump point (or a turning point) in a specific direction.
    This is a generic translation of the algorithm 2 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf
    The current expanded node is a jump point if near a forced node

    In case diagonal moves are forbidden, when lateral nodes (perpendicular to
    the direction of moves are walkable, we force them to be turning points in other
    to perform a straight move.
  --]]
  local function jump(finder, node, parent, endNode, clearance)
	if not node then return end

    local x,y = node._x, node._y
    local dx, dy = x - parent._x,y - parent._y

    -- If the node to be examined is unwalkable, return nil
    if not finder._grid:isWalkableAt(x,y,finder._walkable, clearance) then return end
		
    -- If the node to be examined is the endNode, return this node
    if node == endNode then return node end
    -- Diagonal search case
    if dx~=0 and dy~=0 then
      -- Current node is a jump point if one of his leftside/rightside neighbours ahead is forced
      if (finder._grid:isWalkableAt(x-dx,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x-dx,y,finder._walkable, clearance))) or
         (finder._grid:isWalkableAt(x+dx,y-dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y-dy,finder._walkable, clearance))) then
        return node
      end
    else
      -- Search along X-axis case
      if dx~=0 then
        if finder._allowDiagonal then
          -- Current node is a jump point if one of his upside/downside neighbours is forced
          if (finder._grid:isWalkableAt(x+dx,y+1,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance))) or
             (finder._grid:isWalkableAt(x+dx,y-1,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance) or finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance) then return node end
        end
      else
      -- Search along Y-axis case
        -- Current node is a jump point if one of his leftside/rightside neighbours is forced
        if finder._allowDiagonal then
          if (finder._grid:isWalkableAt(x+1,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance))) or
             (finder._grid:isWalkableAt(x-1,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance) or finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance) then return node end
        end
      end
    end

    -- Recursive horizontal/vertical search
    if dx~=0 and dy~=0 then
      if jump(finder,finder._grid:getNodeAt(x+dx,y),node,endNode, clearance) then return node end
      if jump(finder,finder._grid:getNodeAt(x,y+dy),node,endNode, clearance) then return node end
    end

    -- Recursive diagonal search
    if finder._allowDiagonal then
      if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) or finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
        return jump(finder,finder._grid:getNodeAt(x+dx,y+dy),node,endNode, clearance)
      end
    end
end

  --[[
    Searches for successors of a given node in the direction of each of its neighbours.
    This is a generic translation of the algorithm 1 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf

    Also, we notice that processing neighbours in a reverse order producing a natural
    looking path, as the pathfinder tends to keep heading in the same direction.
    In case a jump point was found, and this node happened to be diagonal to the
    node currently expanded in a straight mode search, we skip this jump point.
  --]]
  local function identifySuccessors(finder, openList, node, endNode, clearance, toClear)

    -- Gets the valid neighbours of the given node
    -- Looks for a jump point in the direction of each neighbour
    local neighbours = findNeighbours(finder,node, clearance)
    for i = #neighbours,1,-1 do

      local skip = false
      local neighbour = neighbours[i]
      local jumpNode = jump(finder,neighbour,node,endNode, clearance)
		
      -- : in case a diagonal jump point was found in straight mode, skip it.
      if jumpNode and not finder._allowDiagonal then
        if ((jumpNode._x ~= node._x) and (jumpNode._y ~= node._y)) then skip = true end
      end
		
      -- Performs regular A-star on a set of jump points
      if jumpNode and not skip then
        -- Update the jump node and move it in the closed list if it wasn't there
        if not jumpNode._closed then			
					local extraG = Heuristics.EUCLIDIAN(jumpNode, node)
					local newG = node._g + extraG
					if not jumpNode._opened or newG < jumpNode._g then
						toClear[jumpNode] = true -- Records this node to reset its properties later.
						jumpNode._g = newG
						jumpNode._h = jumpNode._h or
							(finder._heuristic(jumpNode, endNode))
						jumpNode._f = jumpNode._g+jumpNode._h
						jumpNode._parent = node
						if not jumpNode._opened then
							openList:push(jumpNode)
							jumpNode._opened = true
						else
							openList:heapify(jumpNode)
						end
					end					
				end
      end
    end
  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function(finder, startNode, endNode, clearance, toClear)

    startNode._g, startNode._f, startNode._h = 0,0,0
		local openList = Heap()
    openList:push(startNode)
    startNode._opened = true
    toClear[startNode] = true

    local node
    while not openList:empty() do
      -- Pops the lowest F-cost node, moves it in the closed list
      node = openList:pop()
      node._closed = true
        -- If the popped node is the endNode, return it
        if node == endNode then
          return node
        end
      -- otherwise, identify successors of the popped node
      identifySuccessors(finder, openList, node, endNode, clearance, toClear)
    end

    -- No path found, return nil
    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\thetastar.lua ---

-- ThetaStar implementation
-- See: http://aigamedev.com/open/tutorials/theta-star-any-angle-paths for reference

if (...) then
	
	local _PATH = (...):gsub('%.search.thetastar$','')

	-- Depandancies
	local Heuristics   = require (_PATH .. '.core.heuristics')
	local astar_search = require (_PATH .. '.search.astar')

	-- Internalization
	local ipairs = ipairs
	local huge, abs = math._huge, math.abs
	
	-- Line Of Sight (Bresenham's line marching algorithm)
	-- http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
	local lineOfSight = function (node, neighbour, finder, clearance)
		local x0, y0 = node._x, node._y
		local x1, y1 = neighbour._x, neighbour._y
		local dx = abs(x1-x0)
		local dy = abs(y1-y0)
		local err = dx - dy
		local sx = (x0 < x1) and 1 or -1
		local sy = (y0 < y1) and 1 or -1		

		while true do
			if not finder._grid:isWalkableAt(x0, y0, finder._walkable, finder._tunnel, clearance) then 
				return false 
			end
			if x0 == x1 and y0 == y1 then
				break
			end
			local e2 = 2*err
			if e2 > -dy then
				err = err - dy
				x0 = x0 + sx
			end
			if e2 < dx then
				err = err + dx
				y0 = y0 + sy
			end
		end
		return true
	end
	
	-- Theta star cost evaluation
	local function computeCost(node, neighbour, finder, clearance)
		local parent = node._parent or node
		local mpCost = Heuristics.EUCLIDIAN(neighbour, parent)
		if lineOfSight(parent, neighbour, finder, clearance) then
			if parent._g + mpCost < neighbour._g then
				neighbour._parent = parent
				neighbour._g = parent._g + mpCost
			end
		else
			local mCost = Heuristics.EUCLIDIAN(neighbour, node)
			if node._g + mCost < neighbour._g then
				neighbour._parent = node
				neighbour._g = node._g + mCost
			end
		end
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear, overrideHeuristic)
    return astar_search(finder, startNode, endNode, clearance, toClear, overrideHeuristic, computeCost)
	end

end


--- FILE: \lib\Jumper\specs\bheap_specs.lua ---

context('Module BHeap', function()	
	local BHeap 
	
	before(function()
		BHeap = require ('jumper.core.bheap')
	end)
	
	context('BHeap class', function()
	
		test('BHeap() instantiates a new heap object', function()
			assert_equal(getmetatable(BHeap()), BHeap)
		end)
		
		test('the new heap is empty', function()
			assert_true((BHeap()):empty())
		end)
		
		test('items can be pushed inside', function()
			local h = BHeap()
			h:push(1):push(2):push(3)
			assert_equal(h._size, 3)
		end)
		
		test('popping returns the lowest element by default (< operator)', function()
			local h = BHeap()
			h:push(1):push(2):push(0)
			
			assert_equal(h:pop(),0)
			assert_equal(h:pop(),1)
			assert_equal(h:pop(),2)
			assert_nil(h:pop())
		end)
		
		test('a heap can be cleared', function()
			local h = BHeap()
			assert_true(h:empty())
			
			h:push(1):push(2):push(3)
			assert_false(h:empty())
			
			h:clear()
			assert_true(h:empty())			
		end)
		
		test('one can define a custom sort function', function()
			local sort = function(a,b) return a>b end
			local h = BHeap(sort)
			h:push(1):push(2):push(3)
			
			assert_equal(h:pop(),3)
			assert_equal(h:pop(),2)
			assert_equal(h:pop(),1)
			assert_nil(h:pop())
		end)		

		test('items pushed can be objects, with a custom sort function', function()
			local sortNode = function(a, b) return a.cost < b.cost end
			local makeObj = function(cost) return {cost = cost} end
			local h = BHeap(sortNode)
			h:push(makeObj(1)):push(makeObj(2)):push(makeObj(3))
			
			assert_equal(h:pop().cost,1)
			assert_equal(h:pop().cost,2)
			assert_equal(h:pop().cost,3)
			assert_nil(h:pop())					
		end)
		
		test('pushing a alue that cannot be compared to the previous ones raises an error', function()
			local h = BHeap()
			h:push(false)
			assert_error(pcall(h.push, h, false))
			assert_error(pcall(h.push, h, true))		
			assert_error(pcall(h.push, h, {}))		
			assert_error(pcall(h.push, h, function() end))		
		end)
		
		test('pushing nil does nothing', function()
			local h = BHeap()
			h:push()
			
			assert_true(h:empty())
			h:push(1):push()
			
			assert_false(h:empty())
			assert_equal(h._size,1)
		end)
		
		test('popping an empty heap returns nil', function()
			local h = BHeap()
			assert_nil(h:pop())		
		end)
		
		test('BHeap:heapify() forces a sort of the heap', function()
		
			local h = BHeap()
			local sort = function(a,b) return a.value < b.value end
			local function makeObj(v) return {value = v} end
			local h = BHeap(sort)
			local A, B, C = makeObj(1), makeObj(2), makeObj(3)
			
			h:push(A):push(B):push(C)
			C.value = 0
			h:heapify(C)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,0)
			
			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,1)

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			h:push(A):push(B):push(C)
			C.value, B.value, A.value = 3, 2, 100
			h:heapify()

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,3)

			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,100)
		
		end)
		
		
	end)
	
end)


--- FILE: \lib\Jumper\specs\grid_specs.lua ---

context('Module Grid', function()
	local Grid, Node
	
	before(function()
		Grid = require ('jumper.grid')
		Node = require ('jumper.core.node')
  end)
	
  context('Grid:new() or Grid() returns a new Grid object', function()
		
		test('Grid:new() or Grid() returns a new Grid object', function()
			assert_equal(getmetatable(getmetatable(Grid:new({{0}}))),Grid)
			assert_equal(getmetatable(getmetatable(Grid({{0}}))),Grid)
		end)
			
		test('Grid:new() requires a collision map upon initialization', function()
			local map = {{0,0},{0,0}}
			assert_not_nil(Grid:new(map))
		end)
			
		test('The passed-in map can be a string', function()
			local map = '00\n00'
			assert_not_nil(Grid:new(map))
		end)
			
		test('passing nil to Grid:new() or Grid() causes an error', function()
			assert_error(pcall(Grid, Grid))
			assert_error(pcall(Grid.new, Grid))
		end)			
			
		test('Grid and map should have the same width', function()
			local map = '00\n00'
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map)
			assert_equal(grid:getWidth(), 2)
			assert_equal(grid2:getWidth(), 2)	
		end)	
		
		test('Grid and map should have the same height', function()
			local map = '00\n00\n00'
			local map2 = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map2)
			assert_equal(grid:getHeight(), 3)
			assert_equal(grid2:getHeight(), 4)	
		end)
		
		test('Grid:getBounds() returns the grid corners coordinates', function()
			local map = {{0,0,0},{0,0,0},{0,0,0},{0,0,0}}
			local grid = Grid(map)
			local lx,ly,rx,ry = grid:getBounds()
			assert_equal(lx,1)
			assert_equal(ly,1)
			assert_equal(rx,3)
			assert_equal(ry,4)
			
			local map = {}
			for y = 0,2 do map[y] = {}
				for x = 0,2 do map[y][x] = 0 end
			end
			grid = Grid(map)
			local lx,ly,rx,ry = grid:getBounds()
			assert_equal(lx,0)
			assert_equal(ly,0)
			assert_equal(rx,2)
			assert_equal(ry,2)			
		end)
		
		test('Each value on the map matches a node on the grid', function()
			local map = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			
			for y in pairs(map) do
				for x in pairs(map[y]) do
					local node = grid:getNodeAt(x,y)
					assert_not_nil(node)
					assert_equal(getmetatable(node), Node)
				end
			end
		end)
		
		test('the passed-in map should have a width greather than 0',function()
			assert_error(pcall(Grid, Grid, {{},{}}))
			assert_error(pcall(Grid, Grid, '\n\n'))
		end)

		test('the passed-in map should have a height greather than 0',function()
			assert_error(pcall(Grid, Grid, {}))
			assert_error(pcall(Grid, Grid, ''))
		end)
		
		test('the passed-in map should have rows with the same width',function()
			assert_error(pcall(Grid, Grid, {{0},{0,0}}))
			assert_error(pcall(Grid, Grid, '00\n000'))
		end)

		test('values in the map should only be integers or strings',function()
			assert_error(pcall(Grid, Grid, {{0.1,0,0},{0,0,0}}))
			assert_error(pcall(Grid, Grid, {{0,function() end,0},{0,0,0}}))
		end)
		
	end)
	
	context('Grid types', function()
		
		test('passing a 2nd arg to Grid:new() or Grid() returns a safe-memory grid', function()
			local grid = Grid({{0}})
			local pgrid = Grid({{0}},true)
			assert_not_equal(getmetatable(grid), getmetatable(pgrid))
			assert_equal(getmetatable(getmetatable(grid)), getmetatable(getmetatable(pgrid)))
		end)
		
		test('those grids are memory safe, as nodes are cached on purpose', function()
			local map = {{0,0,0},{0,0,0},{0,0,0}}
			local pgrid = Grid(map, true)
			
			assert_equal(#pgrid:getNodes(), 0)
			local count = 0
			for node in pgrid:iter() do
				assert_equal(getmetatable(node), Node)
				count = count+1
			end
			assert_equal(count, pgrid:getWidth()*pgrid:getHeight())
		end)
		
	end)
	
	context('Grid:isWalkablkeAt', function()
		
			test('returns whether or not a node is walkable',function()
				local map = {{0,0},{0,0},{0,1},{0,0}}
				local grid = Grid(map)			
				local walkable = 1
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						if map[y][x] == walkable then
							assert_true(grid:isWalkableAt(x,y,walkable))
						else
							assert_false(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
				map = 'WXW\nWWW\n'
				grid = Grid(map)			
				walkable = 'W'
				
				for y = 1,2 do
					for x = 1,3 do
						if x==2 and y==1 then
							assert_false(grid:isWalkableAt(x,y,walkable))
						else
							assert_true(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
			end)

			test('All nodes are walkable when no walkability rule was set', function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						assert_true(grid:isWalkableAt(x,y,walkable))
					end
				end
			end)
	
	end)
		
	context('Grid:getMap()', function()
		
			test('returns the collision map',function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				assert_equal(grid:getMap(), map)
			end)
		
			test('returns the array parsed from a given string',function()
				local map = '00\n00'
				local grid = Grid(map)
				assert_equal(type(grid:getMap()), 'table')
				assert_not_equal(grid:getMap(), map)
			end)
		
	end)
	
	context('Grid:getNodeAt()', function()
			local map, grid
			before(function()
				map = {
					{0,0,0,0},
					{0,0,0,0},
				}
				grid = Grid(map)
      end)
			
			test('returns the node at a given position', function()
				local node = grid:getNodeAt(1,1)
				assert_equal(getmetatable(node),Node)
				assert_equal(node._x,1)
				assert_equal(node._y,1)
			end)
			
			test('returns nil if the node does not exist', function()
				assert_nil(grid:getNodeAt(0,0))
				assert_nil(grid:getNodeAt(5,1))
			end)

			test('returns nil if one of its args is missing', function()
				assert_nil(grid:getNodeAt(0))
				assert_nil(grid:getNodeAt())
			end)			
		
	end)
		
	context('Grid:getNodes()', function()
	
		test('returns the array of nodes', function()
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local nodes = grid:getNodes()
			
			assert_equal(type(nodes), 'table')	
			for y in pairs(nodes) do
				for x in pairs(nodes[y]) do
					assert_equal(getmetatable(nodes[y][x]),Node)
				end
			end 
		end)
	
	end)
	
	context('grid:getNeighbours()', function()
		
			test('returns neighbours of a given node', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable = 0
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 2)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
			end)
			
			test('passing true as a third arg includes ajacent nodes', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable, allowDiag = 0, true
				
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable, allowDiag)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 3)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
				assert_equal(nb[3], grid:getNodeAt(2,2))
			end)

			test('passing arg tunnel includes adjacent nodes that cannot be reached diagonnally', function()
				local map = {{0,0,0},{1,0,0},{0,2,0}}
				local grid = Grid(map)
				local walkable, allowDiag, tunnel = 0, true, true
				
				local node = grid:getNodeAt(1,3)
				local nb = grid:getNeighbours(node, walkable, allowDiag, tunnel)
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 1)
				assert_equal(nb[1], grid:getNodeAt(2,2))				
			end)
			
	end)
		
	context('Grid:iter()', function()
			
			test('iterates on all nodes in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
			
			test('can iterate only on a rectangle of nodes', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter(2,2,3,3) do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])					
					assert_gte(n._x, 2)
					assert_gte(n._y, 2)
					assert_lte(n._x, 3)
					assert_lte(n._y, 3)
					assert_nil(record[n])
					record[n] = true
				end
			end)			
			
	end)
	
	context('Grid:around()', function()
			
			test('iterates on nodes following a square outline pattern', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(2,2),1) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)
			
			test('arg spacing defaults to 1 when not given', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(2,2)) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)

			test('skips unexisting nodes', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{2,1},{2,2},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(1,1)) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)				
		
	end)	
		
	context('Grid:each()', function()
			
			test('calls a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:each(f, 3)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n.value,3)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)
		
	context('Grid:eachRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:eachRange(1,1,2,2,f,3)
				for n in grid:iter() do
					if n._x <= 2 and n._y <= 2 then
						assert_equal(n.value,3)
					else
						assert_nil(n.value)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
		
	context('Grid:imap()', function()
			
			test('Maps a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imap(f, 5)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n.v,5)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)

	context('Grid:imapRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}				
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imapRange(3,3,4,4,f,7)
				for n in grid:iter() do
					if n._x >= 3 and n._y >= 3 then
						assert_equal(n.v,7)
					else
						assert_nil(n.v)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
	
end)


--- FILE: \lib\Jumper\specs\heuristics_specs.lua ---

context('Module Heuristics', function()
	local H, Node
	
	before(function()
		H = require ('jumper.core.heuristics')
		Node = require ('jumper.core.node')
  end)
	
  context('MANHATTAN distance', function()
	
    test('is a function',function()
			assert_type(H.MANHATTAN, 'function')
    end)
	
		test('evaluates as |dx|+|dy|', function()
			assert_equal(H.MANHATTAN(Node(0,0), Node(0,0)), 0)
			assert_equal(H.MANHATTAN(Node(1,1), Node(1,3)), 2)
			assert_equal(H.MANHATTAN(Node(0,0), Node(2,1)), 3)
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.MANHATTAN,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.MANHATTAN))
		end)		
		
  end)

  context('EUCLIDIAN distance', function()
	
    test('is a function',function()
			assert_type(H.EUCLIDIAN, 'function')
    end)
	
		test('evaluates as SQUAREROOT(dx*dx + dy*dy)', function()
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(0,0)), 0)
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(2,2)), math.sqrt(8))
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(5,3)), math.sqrt(34))		
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.EUCLIDIAN,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.EUCLIDIAN))
		end)		
		
  end)
  
	context('DIAGONAL distance', function()
	
    test('is a function',function()
			assert_type(H.DIAGONAL, 'function')
    end)
	
		test('evaluates as MAX(|dx|+|dy|)', function()
			assert_equal(H.DIAGONAL(Node(0,0), Node(0,0)), 0)
			assert_equal(H.DIAGONAL(Node(0,0), Node(2,2)), 2)
			assert_equal(H.DIAGONAL(Node(0,0), Node(1,2)), 2)
			assert_equal(H.DIAGONAL(Node(0,0), Node(3,1)), 3)	
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.DIAGONAL,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.DIAGONAL))
		end)		
		
  end)

	context('CARDINTCARD distance', function()
	
    test('is a function',function()
			assert_type(H.CARDINTCARD, 'function')
    end)
		
		test('evaluates as (SQRT(2)-1)*MIN(|dx|+|dy|)+MAX(|dx|+|dy|)', function()
			assert_equal(H.CARDINTCARD(Node(0,0), Node(0,0)), 0)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(1,1))-(math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(1,2))-(1+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(-3,1))-(2+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(2,2))-(2*math.sqrt(2)),1e-6)
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.CARDINTCARD,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.CARDINTCARD))
		end)		
		
  end)
	
end)


--- FILE: \lib\Jumper\specs\node_specs.lua ---

context('Module Node', function()
	local Node
	
	before(function()
		Node = require ('jumper.core.node')
  end)
	
  context('The Node Class', function()
	
    test('Node:new() or Node() returns a Node object',function()
			assert_equal(getmetatable(Node:new(0,0)),Node)
			assert_equal(getmetatable(Node(0,0)),Node)
    end)
	
		test('A Node has x and y attributes', function()
			local node = Node:new(1,3)
			assert_equal(node._x, 1)
			assert_equal(node._y, 3)
		end)
		
		test('x and y attributes can be retrieved through methods', function()
			local node = Node:new(5,6)
			assert_equal(node:getX(), 5)
			assert_equal(node:getY(), 6)
			
			local x, y = node:getPos()
			assert_equal(x, 5)
			assert_equal(y, 6)
		end)		
		
		test('Nodes can be compared, if they both have an F-cost', function()
		  local nodeA, nodeB = Node(1,2), Node(1,2)
			nodeA._f, nodeB._f = 1, 2
			assert_less_than(nodeA, nodeB)
			
			nodeA._f = 3
			assert_less_than(nodeB, nodeA)
		end)	
		
  end)

end)


--- FILE: \lib\Jumper\specs\pathfinder_specs.lua ---

context('Module Pathfinder', function()
	local PF, H, Grid, Path, map, grid
	
	before(function()
		PF = require ('jumper.pathfinder')
		Grid = require ('jumper.grid')
		H = require ('jumper.core.heuristics')
		Path = require ('jumper.core.path')
		map = {{0,0,0},{0,0,0},{0,0,0}}
		grid = Grid(map)
  end)
	
  context('Pathfinder:new() or Pathfinder()', function()
		
		test('Inits a new Pathfinder object', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR')), PF)
			assert_equal(getmetatable(PF:new(grid, 'ASTAR')), PF)
		end)
		
		test('First arg is a grid object', function()
			assert_error(pcall(PF, PF))
			assert_error(pcall(PF, PF, map))
			assert_equal(getmetatable(PF(grid)), PF)
		end)
		
		test('Second arg, when given must be a valid finderName', function()
			assert_error(pcall(PF, PF, grid, 'finder'))
			for i, finder in ipairs(PF:getFinders()) do
				assert_equal(getmetatable(PF(grid, finder)), PF)
			end
		end)
		
		test('Defaults to \'ASTAR\' when not given', function()
			local pf = PF(grid)
			assert_equal(getmetatable(pf), PF)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Third arg walkable can be a string, function, int or nil', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR', 'A')), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', function() end)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', 1)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', nil)), PF)
			assert_error(pcall(PF, PF, grid, 'ASTAR', 2.2))
			assert_error(pcall(PF, PF, grid, 'ASTAR', {}))
		end)
		
	end)
	
	context('Pathfinder:getGrid()', function()
		
		test('returns the grid object used by the Pathfinder', function()
			local pf = PF(grid)
			assert_equal(pf:getGrid(), grid)
		end)
		
	end)
	
	context('Pathfinder:setGrid()', function()
	
		test('Sets the grid object on which the Pathfinder performs', function()
			local pf = PF(grid)
			local newGrid = Grid('00000\n00000')
			
			assert_equal(pf:getGrid(), grid)
			pf:setGrid(newGrid)
			assert_equal(pf:getGrid(), newGrid)
		end)
		
		test('passing nil raises an error', function()
			local pf = PF(grid)
			assert_error(pcall(pf.setGrid, pf, nil))
		end)
		
	end)
	
	context('Pathfinder:getWalkable()', function()
	
		test('returns the walkable parameter', function()
			local pf = PF(grid, 'ASTAR', 1)
			assert_equal(pf:getWalkable(), 1)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
	end)
	
	context('Pathfinder:setWalkable()', function()
	
		test('sets the string, function, nil or int walkable value', function()
			local pf = PF(grid, 'ASTAR')
			assert_nil(pf:getWalkable())
			
			pf:setWalkable('A')
			assert_equal(pf:getWalkable(), 'A')
			
			pf:setWalkable(2)
			assert_equal(pf:getWalkable(), 2)
			
			local f = function() end
			pf:setWalkable(f)
			assert_equal(pf:getWalkable(), f)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
		test('raises an error when passed-in value is not a string, int, nil or function', function()
			local pf = PF(grid)			
			assert_error(pcall(pf.setWalkable, pf, {}))
			assert_error(pcall(pf.setWalkable, pf, 0.4))
		end)
		
	end)	
	
	context('Pathfinder:getFinder()', function()
		
		test('returns the finder name used', function()
			local pf = PF(grid, 'JPS')
			assert_equal(pf:getFinder(), 'JPS')
		end)
		
	end)
	
	context('Pathfinder:setFinder()', function()

		test('sets the finder to be used', function()
			local pf = PF(grid)
			pf:setFinder('DFS')
			assert_equal(pf:getFinder(), 'DFS')
		end)
		
		test('Upon init, the default finder, when not given, is \'ASTAR\'', function()
			local pf = PF(grid)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)

		test('Passing nil sets \'ASTAR\` as the finder if no previous finder was set, is \'ASTAR\'', function()
			local pf = PF(grid)
			pf:setFinder()
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Passing nil has no effect if a finder was set previously', function()
			local pf = PF(grid, 'JPS')
			pf:setFinder()
			assert_equal(pf:getFinder(), 'JPS')
		end)			
	
	end)
	
	context('Pathfinder:getFinders()', function()
		
		test('returns the list of all existing finders', function()
			local fs = PF:getFinders()
			local pf = PF(grid)
			
			assert_greater_than(#fs, 0)
			for i,finder in ipairs(fs) do
				pf:setFinder(finder)
				assert_equal(pf:getFinder(), finder)
			end
		end)
		
	end)
	
	context('Pathfinder:getHeuristic()', function()
		
		test('returns the heuristic function used', function()
			local pf = PF(grid)
			assert_not_nil(pf:getHeuristic())
		end)
		
		test('default heuristic is \'MANHATTAN\'', function()
			local pf = PF(grid)
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
	end)
	
	context('Pathfinder:setHeuristic()', function()
		
		test('sets the heuristic function to be used', function()
			local pf = PF(grid)
			pf:setHeuristic('MANHATTAN')
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
		test('handles custom heuristic functions', function()
			local pf = PF(grid)
			local f = function() end
			pf:setHeuristic(f)
			assert_equal(pf:getHeuristic(),f)
		end)
		
		test('passing nil produces an error',function()
			local pf = PF(grid)
			assert_error(pcall(pf.setHeuristic, pf))
		end)
		
	end)

	context('Pathfinder:getHeuristics()', function()
		
		test('returns all available heuristics', function()
			local hs = PF:getHeuristics()
			assert_greater_than(#hs, 0)
			local pf = PF(grid)
			for i, heur in ipairs(hs) do
				pf:setHeuristic(heur)
				assert_equal(pf:getHeuristic(), H[heur])
			end
		end)
		
	end)
	
	context('Pathfinder:getMode()', function()
	
		test('returns the actual search mode', function()
			local pf = PF(grid)
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(),'DIAGONAL')
		end)

		test('default search mode is  \'DIAGONAL\'', function()
			local pf = PF(grid)
			assert_equal(pf:getMode(),'DIAGONAL')
		end)
		
	end)
	
	context('Pathfinder:setMode()', function()
		
		test('sets the search mode', function()
			local pf = PF(grid)		
			pf:setMode('ORTHOGONAL')
			assert_equal(pf:getMode(), 'ORTHOGONAL')
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(), 'DIAGONAL')	
		end)
		
		test('passing nil or any other invalid arg causes an error', function()
			local pf = PF(grid)		
			
			assert_error(pcall(pf.setMode, pf))		
			assert_error(pcall(pf.setMode, pf, 'ORTHO'))		
			assert_error(pcall(pf.setMode, pf, function() end))	
		end)
		
	end)
	
	context('Pathfinder:getModes()', function()
		
		test('returns all available modes', function()
			local ms = PF:getModes()
			assert_equal(#ms, 2)
			local pf = PF(grid)
			
			for i, mode in ipairs(ms) do
				pf:setMode(mode)
				assert_equal(pf:getMode(),mode)
			end
		end)
		
	end)
		
	context('Pathfinder:setTunnelling()', function()
		
		test('Enables or disables tunnelling feature', function()
			PF:setTunnelling(true)
			assert_true(PF:getTunnelling())
			PF:setTunnelling(false)
			assert_false(PF:getTunnelling())
		end)
		
		test('Enables or disables tunnelling feature', function()
			PF:setTunnelling(true)
			assert_true(PF:getTunnelling())
			PF:setTunnelling(false)
			assert_false(PF:getTunnelling())
		end)
		
		test('When on, finder goes through walls heading diagonally', function()
			local map = {{0,0,0},{1,0,0},{0,2,0}}
			local grid = Grid(map)
			local finder = PF(grid, 'ASTAR',0)
			finder:setTunnelling(true)
			local path = finder:getPath(1,3,3,1)
			assert_equal(path._nodes[1]._x,1)
			assert_equal(path._nodes[1]._y,3)
			assert_equal(path._nodes[2]._x,2)
			assert_equal(path._nodes[2]._y,2)
			assert_equal(path._nodes[3]._x,3)
			assert_equal(path._nodes[3]._y,1)			
		end)
		
	end)
	
	context('Pathfinder:getTunnelling()', function()
		
		test('Returns the actual state of tunnelling feature', function()
			assert_false(PF:getTunnelling())
		end)
		
	end)

	context('Pathfinder:annotateGrid()', function()
		
		test('Calculates clearance for the entire grid', function()
			local map = {
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,1,0,0,0,0,0,0},
			{0,0,1,0,0,0,0,0,2,0},
			{0,0,1,1,1,0,0,2,0,0},
			{0,0,0,1,1,0,2,0,0,2},
			{0,0,0,0,1,0,0,0,0,2},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0}
		}
		local clearances = {
			{6,6,5,5,4,4,4,3,2,1},
			{6,5,5,4,4,3,3,3,2,1},
			{6,5,4,4,3,3,2,2,2,1},
			{6,5,4,3,3,2,2,1,1,1},
			{6,5,4,3,2,2,1,1,0,1},
			{5,5,4,3,2,1,1,0,1,1},
			{4,4,4,3,2,1,0,2,1,0},
			{3,3,3,3,3,3,3,2,1,0},
			{2,2,2,2,2,2,2,2,2,1},
			{1,1,1,1,1,1,1,1,1,1}
		}
		local grid = Grid(map)
		local walkable = function(v) return v~=2 end
		local finder = PF(grid, 'ASTAR', walkable)
		finder:annotateGrid()
		for node in grid:iter() do
			assert_equal(node:getClearance(walkable), clearances[node._y][node._x])
		end			
		end)
		
	end)

	context('Pathfinder:clearAnnotations()', function()
		
		test('Clears cached clearance values for the entire grid', function()
			local map = {{0,1,0},{0,0,0},{1,1,0}}
			local grid = Grid(map)
			local walkable = 0
			local finder = PF(grid, 'ASTAR', walkable)
			finder:annotateGrid()
			finder:clearAnnotations()
			for node in grid:iter() do
				assert_nil(node:getClearance(walkable))
			end			
		end)
		
	end)
	
	context('Pathfinder:getPath()', function()
		
		test('returns a path', function()
			local pf = PF(grid, 'ASTAR', 0)
			local path = pf:getPath(1,1,3,3)
			assert_equal(getmetatable(path), Path)
		end)
		
		test('start and end locations must exist on the map', function()
			local pf = PF(grid, 'ASTAR', 0)
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
			assert_error(pcall(pf.getPath, pf, 1, 1, 4, 4))
			assert_error(pcall(pf.getPath, pf, 0,0, 4, 4))
		end)
		
		test('goal location must be walkable', function()
			local pf = PF(grid, 'ASTAR', 0)
			map[3][3] = 1
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
		end)
		
	end)	
	
end)


--- FILE: \lib\Jumper\specs\path_specs.lua ---

context('Module Path', function()
	local Path, Node
	
	before(function()
		Path = require ('jumper.core.path')
		Node = require ('jumper.core.node')
  end)
	
  context('The Path Class', function()
	
    test('Path:new() or Path() returns a Path object',function()
			assert_equal(getmetatable(Path:new()),Path)
			assert_equal(getmetatable(Path()),Path)
    end)
		
    test('Path:iter() iterates on nodes forming the path',function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(getmetatable(node), Node)
				assert_equal(node._x, i)
				assert_equal(node._y, i)
				assert_equal(count, i)
			end
    end)		
		
		test('Path:iter() is aliased as Path:nodes()',function()
			assert_equal(Path.iter, Path.nodes)
		end)
		
		test('Path:getLength() returns the length of the path', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,0) end
			assert_equal(p:getLength(),9)
			
			p = Path()
			for j = 1,10 do p._nodes[#p._nodes+1] = Node(0,j) end
			assert_equal(p:getLength(),9)

			p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			assert_less_than(p:getLength()-9*math.sqrt(2),1e-6)			
		end)
		
		test('Path:fill() interpolates a path', function()
			local p = Path()
			for i = 1,9,2 do p._nodes[#p._nodes+1] = Node(i,i) end
			p._grid = {getNodeAt = function(self,x,y) return {_x = x, _y = y} end}
			p:fill()
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(node._x, i)
				assert_equal(node._y, i)
				assert_equal(count, i)
			end			
			
		end)
		
		test('Interpolation does not affect the total path length', function()
			local p = Path()
			for i = 1,10,3 do p._nodes[#p._nodes+1] = Node(i,i) end
			local len = p:getLength()
			p._grid = {getNodeAt = function(self,x,y) return {_x = x, _y = y} end}			
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		

		test('Path:filter() compresses a path', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			p:filter()
			
			assert_equal(p._nodes[1]._x,1)
			assert_equal(p._nodes[1]._y,1)
			assert_equal(p._nodes[2]._x,10)
			assert_equal(p._nodes[2]._y,10)
			for i = 3,10 do
				assert_nil(p._nodes[i])
			end
			
		end)

		test('Compression does not affect the total path length', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			local len = p:getLength()
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		
		
  end)

end)


--- FILE: \src\main_game.lua ---

-- src/main_game.lua
local Gamestate = require "lib.hump.gamestate"

function love.load()
    Gamestate.registerEvents()
    Gamestate.switch(require("src.states.MenuState"))
end


--- FILE: \src\entities\Ally.lua ---

---Modulos
local Sprite = require("src.systems.Sprite")
local animation = require("src.systems.animation")

local allyTypes = {
    ["soldado"] = {
        speed = 50, health = 100, cost = 10, damage = 10, color = {0, 0.8, 0},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"1/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"1/Attack.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"1/Preattack.png", 48, 48, 1)
        -- )
    },
    ["tank"]    = {
        speed = 30, health = 300, cost = 30, damage = 25, color = {0.8, 0, 0},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"2/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"2/Attack.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"2/Preattack.png", 48, 48, 1)
        -- )
    },
    ["ninja"]   = {
        speed = 80, health = 70,  cost = 15, damage = 5,  color = {0, 0, 0.8},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"3/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"3/Attack.png", 72, 48, 1),
        -- animation:newAnimation(spritePath+"3/Preattack.png", 48, 48, 1)
        -- )
    },
}

---Início do módulo de aliados
local Ally = {
}
Ally.__index = Ally

-- Define os tipos de aliados com seus atributos


-- Construtor do Ally
function Ally.create(type, x, y)
    local stats = allyTypes[type]
    assert(stats, "Tipo de aliado inválido: " .. tostring(type))

    local allySpritePath = string.format("assets/allies/defenders/%s/", type)
    local ally = {
        type = type,
        x = x,
        y = y,
        speed = stats.speed,
        health = stats.health,
        maxHealth = stats.health,
        damage = stats.damage,
        cost = stats.cost,
        color = stats.color,
        alive = true,
        attackCooldown = 1,  -- 1 segundo entre ataques
        timeSinceAttack = 0,
        sprite = Sprite:newSprite(
            animation:newAnimation(allySpritePath.."Idle.png", 48, 48, 1),
            animation:newAnimation(allySpritePath.."Attack.png", 48, 48, 1),
            animation:newAnimation(allySpritePath.."Preattack.png", 48, 48, 1),
            true
        ),
    }

    return setmetatable(ally, Ally)
end

-- Atualiza posição e ataque
function Ally:update(dt, enemies)
    if not self.alive then return end

    self.sprite:update(dt)
    self.timeSinceAttack = self.timeSinceAttack + dt

    -- Verifica se há inimigos próximos para atacar
    local attacked = false
    for _, enemy in ipairs(enemies) do
        if enemy.alive and math.abs(self.x - enemy.x) < 25 then
            -- Atacar se estiver perto o suficiente
            if self.timeSinceAttack >= self.attackCooldown then
                -- self.sprite:setState(Sprite.attack)
                enemy:takeDamage(self.damage)
                self.timeSinceAttack = 0
            end
            else
                self.sprite:setState(Sprite.attack)
                attacked = true
            break
        end
    end

    -- Se não atacou, continua andando
    if not attacked then
        self.x = self.x + self.speed * dt
        self.sprite:setState(Sprite.idle)
    end
end

-- Desenha aliado e barra de vida
function Ally:draw()
    if not self.alive then return end

    -- Corpo
    -- love.graphics.setColor(self.color)
    -- love.graphics.rectangle("fill", self.x, self.y, 20, 20)
    self.sprite:draw(self.x, self.y)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", self.x, self.y - 5, 20, 3)

    love.graphics.setColor(0, 1, 0)
    local lifeWidth = (self.health / self.maxHealth) * 20
    love.graphics.rectangle("fill", self.x, self.y - 5, lifeWidth, 3)

    -- Reset cor
    love.graphics.setColor(1, 1, 1)
end

-- Sofrer dano
function Ally:takeDamage(dmg)
    self.health = self.health - dmg
    if self.health <= 0 then
        self.alive = false
    end
end

-- Retorna o custo do tipo
function Ally.getCost(type)
    return type and allyTypes[type].cost or math.huge
end

return Ally


--- FILE: \src\entities\Enemy.lua ---

-- src/entities/Enemy.lua

-- 1. Importa a classe base Unit
local Unit = require("src.entities.Unit")

-- 2. Cria a classe Enemy e a faz herdar de Unit
local Enemy = {}
setmetatable(Enemy, {__index = Unit})
Enemy.__index = Enemy

-- Tabela de atributos com o valor da recompensa ('reward')
local enemyTypes = {
    ["soldado"] = { speed = 50, health = 100, cost = 10, damage = 10, color = {0.8, 0.5, 0}, reward = 5 },
    ["tank"]    = { speed = 30, health = 300, cost = 30, damage = 25, color = {0.5, 0.2, 0.2}, reward = 15 },
    ["ninja"]   = { speed = 80, health = 70,  cost = 15, damage = 5,  color = {0.3, 0.3, 0.3}, reward = 10 },
}

-- Construtor do Enemy
function Enemy.create(type, x, y)
    local stats = enemyTypes[type]
    assert(stats, "Tipo de inimigo inválido: " .. tostring(type))

    local config = {
        x = x, y = y,
        speed = stats.speed,
        health = stats.health,
        damage = stats.damage,
        cost = stats.cost,
        color = stats.color
    }

    local enemy = Unit:new(config)
    setmetatable(enemy, Enemy)
    enemy.type = type
    
    -- Garante que a recompensa seja armazenada na instância do inimigo
    enemy.reward = stats.reward or 0
    
    return enemy
end

-- Atualiza a lógica do Enemy
function Enemy:update(dt, allies, structure)
    if not self.alive then return end

    self.timeSinceAttack = self.timeSinceAttack + dt
    local attacked = false

    -- Prioridade 1: Atacar aliados próximos
    for _, ally in ipairs(allies) do
        if ally.alive and math.abs(self.x - ally.x) < 25 then
            if self.timeSinceAttack >= self.attackCooldown then
                ally:takeDamage(self.damage)
                self.timeSinceAttack = 0
            end
            attacked = true
            break
        end
    end

    -- Prioridade 2: Se não atacou um aliado, verifica se pode atacar a estrutura
    if not attacked and structure and structure.alive and math.abs(self.x - structure.x) < 40 then
        if self.timeSinceAttack >= self.attackCooldown then
            structure:takeDamage(self.damage)
            self.timeSinceAttack = 0
        end
        attacked = true
    end

    -- Se não atacou ninguém, continua andando para a esquerda
    if not attacked then
        self.x = self.x - self.speed * dt
    end
end

-- Função estática para obter o custo
function Enemy.getCost(type)
    return enemyTypes[type] and enemyTypes[type].cost or math.huge
end

-- ######################################################################
-- A LINHA MAIS IMPORTANTE DO ARQUIVO!
-- Garante que o 'require' receba a tabela 'Enemy' e não 'true'.
-- ######################################################################
return Enemy


--- FILE: \src\entities\Projectile.lua ---

-- Conceito para Projectile.lua
local Projectile = {}

function Projectile.create(x, y, target, damage)
    -- ...
    -- Calcula a velocidade em direção ao alvo
    local angle = math.atan2(target.y - y, target.x - x)
    proj.velocityX = math.cos(angle) * speed
    proj.velocityY = math.sin(angle) * speed
    -- ...
end

function Projectile:update(dt)
    self.x = self.x + self.velocityX * dt
    self.y = self.y + self.velocityY * dt
    -- Lógica de colisão com alvos
end


--- FILE: \src\entities\Structure.lua ---

-- Structure.lua
local Sprite = require("src.systems.Sprite")
local animation = require("src.systems.animation")

local Structure = {}
Structure.__index = Structure

-- Tipos de estruturas pré-definidas (pode expandir depois)
local StructureTypes = {
    ["base"] = { width = 32, height = 128, health = 200, cost = 50, attackDamage = 0, attackRange = 0, attackSpeed = 0, color = {1, 1, 1} },
    -- Você pode adicionar mais tipos aqui no futuro
}

-- Construtor
function Structure.create(type, x, y)
    local stats = StructureTypes[type]
    assert(stats, "Tipo de estrutura inválido: " .. tostring(type))

    local structurePath = "assets/allies/tower/"
    local structure = {
        type = type,
        x = x,
        y = y,
        width = stats.width,
        height = stats.height,
        health = stats.health,
        maxHealth = stats.health,
        cost = stats.cost,
        alive = true,
        attackDamage = stats.attackDamage,
        attackRange = stats.attackRange,
        attackSpeed = stats.attackSpeed,
        timeSinceLastAttack = 0,
        color = stats.color,
        sprite = Sprite:newSprite(
        animation:newAnimation(structurePath.."1.png", 70, 130, 1),
        animation:newAnimation(structurePath.."2.png", 70, 130, 1),
        animation:newAnimation(structurePath.."3.png", 70, 130, 1),
        true
    )
    }

    return setmetatable(structure, Structure)
end

-- Atualiza estrutura
function Structure:update(dt)
    if not self.alive then return end

    self.sprite:update(dt)

    if self.attackDamage > 0 and self.attackRange > 0 then
        self.timeSinceLastAttack = self.timeSinceLastAttack + dt
        if self.timeSinceLastAttack >= (1 / self.attackSpeed) then
            self:performAttack()
            self.timeSinceLastAttack = 0
        end
    end

    if self.health <= 0 then
        self.health = 0
        self.alive = false
        self:onDeath()
    end
end

-- Desenha estrutura e vida
function Structure:draw()
    if not self.alive then return end

    self.sprite:draw(self.x, self.y)

    -- Barra de vida
    local barWidth = 40
    local barHeight = 5
    local currentWidth = (self.health / self.maxHealth) * barWidth
    love.graphics.setColor(0.2, 0.2, 0.2, 0.8)
    love.graphics.rectangle("fill", self.x - barWidth / 2, self.y - 5 / 2 - 10, barWidth, barHeight)
    love.graphics.setColor(0, 1, 0)
    love.graphics.rectangle("fill", self.x - barWidth / 2, self.y - 5 / 2 - 10, currentWidth, barHeight)

    love.graphics.setColor(1, 1, 1) -- Reset cor
end

-- Recebe dano
function Structure:takeDamage(amount)
    if not self.alive then return end

    self.health = self.health - amount
    if self.health <= 0 then
        self.health = 0
        self.alive = false
        self:onDeath()
    end
end

-- Ataque (placeholder)
function Structure:performAttack()
    -- Implementação futura se quiser ataque automático
end

-- Ao morrer
function Structure:onDeath()
    print(self.type .. " at (" .. self.x .. ", " .. self.y .. ") has been destroyed!")
end

-- Custo
function Structure.getCost(type)
    return StructureTypes[type] and StructureTypes[type].cost or math.huge
end

return Structure


--- FILE: \src\entities\Unit.lua ---

-- src/entities/Unit.lua
local Unit = {}
Unit.__index = Unit

function Unit:new(config)
    local unit = {}
    
    unit.x = config.x or 0
    unit.y = config.y or 0
    unit.speed = config.speed or 50
    unit.health = config.health or 100
    unit.maxHealth = config.health or 100
    unit.damage = config.damage or 10
    unit.cost = config.cost or 0
    unit.color = config.color or {1, 1, 1}
    unit.alive = true
    unit.attackCooldown = 1
    unit.timeSinceAttack = 0

    return setmetatable(unit, self)
end

function Unit:takeDamage(dmg)
    self.health = self.health - dmg
    if self.health <= 0 then
        self.health = 0
        self.alive = false
    end
end

function Unit:draw()
    if not self.alive then return end

    -- Corpo
    love.graphics.setColor(self.color)
    love.graphics.rectangle("fill", self.x, self.y, 20, 20)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", self.x, self.y - 5, 20, 3)

    love.graphics.setColor(0, 1, 0)
    local lifeWidth = (self.health / self.maxHealth) * 20
    love.graphics.rectangle("fill", self.x, self.y - 5, lifeWidth, 3)

    love.graphics.setColor(1, 1, 1)
end

-- Outras funções que são comuns a Ally e Enemy podem vir aqui.

return Unit


--- FILE: \src\states\BaseState.lua ---



--- FILE: \src\states\GameOverState.lua ---

local Gamestate = require "lib.hump.gamestate"

local gameover = {}

function gameover:load()
end

function gameover:draw()
    love.graphics.printf("GAME OVER - Pressione Espaço para Voltar ao Menu", 0, 300, love.graphics.getWidth(), "center")
end

function gameover:keypressed(key)
    if key == "space" then
        Gamestate.switch(require("src.states.MenuState"))
    end
end

return gameover


--- FILE: \src\states\MenuState.lua ---

local Gamestate = require "lib.hump.gamestate"
local menu = {}
menu.__index = menu


function menu:loadAssets()
    Background = love.graphics.newImage("assets/background/menu_1.png")
end

function menu:load()
    menu:loadAssets()
    return menu
end

function menu:draw()
    love.graphics.draw(Background, 0, 0)
    love.graphics.printf("MENU - Pressione Enter para Jogar", 0, 300, love.graphics.getWidth(), "center")
end

function menu:keypressed(key)
    if key == "return" then
        Gamestate.switch(require("src.states.PlayState"):load())
    end
end

return menu:load()


--- FILE: \src\states\PlayState.lua ---

-- src/states/PlayState.lua
local Gamestate = require "lib.hump.gamestate"

local Ally = require("src.entities.Ally")
local Enemy = require("src.entities.Enemy")
local Structure = require("src.entities.Structure")
local Button = require("src.ui.Button")

local PlayState = {}
PlayState.__index = PlayState

-- ############### NOVA FUNÇÃO AUXILIAR ###############
-- Esta função cria/recria os botões do painel de upgrade.
-- Ela será chamada apenas quando precisarmos atualizar a UI dos upgrades.
function PlayState:rebuildUpgradeUI()
    self.uiUpgradeElements = {} -- Limpa a lista antiga
    if not self.isUpgradePanelOpen then return end -- Se o painel está fechado, não faz nada

    local yPos = 120
    for key, upgrade in pairs(self.upgrades) do
        local cost = math.floor(upgrade.baseCost * (upgrade.costMultiplier ^ upgrade.level))
        local text = upgrade.name .. " (Lvl " .. upgrade.level .. ")\nCusto: $" .. cost
        
        local currentKey = key
        local btn = Button.create(200, yPos, love.graphics.getWidth() - 400, 60, text, function()
            self:purchaseUpgrade(currentKey)
        end)
        
        table.insert(self.uiUpgradeElements, btn)
        yPos = yPos + 80
    end
end
-- ######################################################

function PlayState:load()
    local state = {
        allies = {},
        enemies = {},
        structures = {},
        uiSpawnElements = {},
        uiUpgradeElements = {}, -- Começa vazia
        isUpgradePanelOpen = false,
        money = 150,
        enemySpawnTimer = 0,
        enemySpawnInterval = 5
    }
    setmetatable(state, PlayState)

    state.upgrades = {
        soldierDamage = { name = "Dano Soldado", level = 0, baseCost = 50, costMultiplier = 1.6, value = 5 },
        income = { name = "Renda Passiva", level = 0, baseCost = 100, costMultiplier = 2, value = 2 },
        baseHealth = { name = "Vida da Base", level = 0, baseCost = 75, costMultiplier = 1.8, value = 250 }
    }

    local playerStructure = Structure.create("base", 80, love.graphics.getHeight() - 198)
    table.insert(state.structures, playerStructure)

    local function spawnAlly(allyType)
        local bonusDamage = state.upgrades.soldierDamage.level * state.upgrades.soldierDamage.value
        local bonusHealth = 0
        local allyCost = Ally.getCost(allyType)
        if state.money >= allyCost then
            table.insert(state.allies, Ally.create(allyType, 120, love.graphics.getHeight() - 100, bonusDamage, bonusHealth))
            state.money = state.money - allyCost
        end
    end

    table.insert(state.uiSpawnElements, Button.create(10, 100, 120, 40, "Soldado", function() spawnAlly("soldado") end))
    table.insert(state.uiSpawnElements, Button.create(10, 150, 120, 40, "Tank", function() spawnAlly("tank") end))
    table.insert(state.uiSpawnElements, Button.create(10, 200, 120, 40, "Ninja", function() spawnAlly("ninja") end))
    
    -- ############### MUDANÇA NA LÓGICA DO BOTÃO ###############
    -- Agora, além de mudar a flag, ele chama a função para construir a UI.
    table.insert(state.uiSpawnElements, Button.create(10, 280, 120, 50, "UPGRADES", function()
        state.isUpgradePanelOpen = not state.isUpgradePanelOpen
        state:rebuildUpgradeUI()
    end))

    return state
end

function PlayState:purchaseUpgrade(upgradeType)
    local upgrade = self.upgrades[upgradeType]
    if not upgrade then return end
    local cost = math.floor(upgrade.baseCost * (upgrade.costMultiplier ^ upgrade.level))

    if self.money >= cost then
        self.money = self.money - cost
        upgrade.level = upgrade.level + 1

        if upgradeType == "baseHealth" then
            local structure = self.structures[1]
            structure.maxHealth = structure.maxHealth + upgrade.value
            structure.health = structure.health + upgrade.value
        end
        print("Upgrade '" .. upgrade.name .. "' comprado! Nível: " .. upgrade.level)
        
        -- ############### ATUALIZA A UI APÓS A COMPRA ###############
        self:rebuildUpgradeUI()
    else
        print("Dinheiro insuficiente para o upgrade: " .. upgrade.name)
    end
end

function PlayState:update(dt)
    -- print("No início do update, o tipo de Enemy é: " .. type(Enemy)) -- <<< ADICIONE ESTA LINHA

    local playerStructure = self.structures[1]
    if not playerStructure.alive then
        Gamestate.switch(require("src.states.GameOverState"))
        return
    end

    if not self.isUpgradePanelOpen then
        playerStructure:update(dt)

        -- Atualiza aliados
        for i = #self.allies, 1, -1 do
            local ally = self.allies[i]
            ally:update(dt, self.enemies)
            if not ally.alive or ally.x > love.graphics.getWidth() then
                table.remove(self.allies, i)
            end
        end

        -- Atualiza inimigos
        for i = #self.enemies, 1, -1 do
            local enemy = self.enemies[i] -- Note o 'e' minúsculo, que é o correto.
            enemy:update(dt, self.allies, playerStructure)

            -- Verifica se o inimigo morreu ou saiu da tela
            if not enemy.alive or enemy.x < 0 then
                -- Se o inimigo foi derrotado (e não apenas saiu da tela), dá a recompensa.
                if not enemy.alive then
                    self.money = self.money + (enemy.reward or 0)
                end
                -- Remove o inimigo do jogo
                table.remove(self.enemies, i)
            end
        end

        -- Lógica de economia e spawn
        local incomeValue = 5 + (self.upgrades.income.level * self.upgrades.income.value)
        self.money = self.money + incomeValue * dt
        
        self.enemySpawnTimer = self.enemySpawnTimer + dt
        if self.enemySpawnTimer >= self.enemySpawnInterval then
            self:spawnEnemy()
            self.enemySpawnTimer = 0
        end
    end
    
    -- Atualiza UI
    for _, element in ipairs(self.uiSpawnElements) do element:update(dt) end
    if self.isUpgradePanelOpen then
        for _, element in ipairs(self.uiUpgradeElements) do element:update(dt) end
    end
end

function PlayState:draw()
    love.graphics.clear(0.4, 0.5, 0.6)

    for _, s in ipairs(self.structures) do s:draw() end
    for _, a in ipairs(self.allies) do a:draw() end
    for _, e in ipairs(self.enemies) do e:draw() end

    local incomeValue = 5 + (self.upgrades.income.level * self.upgrades.income.value)
    love.graphics.print("Dinheiro: $" .. math.floor(self.money), 10, 10)
    love.graphics.print("Renda: $" .. incomeValue .. "/s", 10, 30)
    for _, element in ipairs(self.uiSpawnElements) do element:draw() end
    
    -- ############### FUNÇÃO DRAW SIMPLIFICADA ###############
    -- Agora ela apenas desenha, sem criar nada.
    if self.isUpgradePanelOpen then
        love.graphics.setColor(0, 0, 0, 0.7)
        love.graphics.rectangle("fill", 150, 50, love.graphics.getWidth() - 300, love.graphics.getHeight() - 100)
        love.graphics.setColor(1, 1, 1)
        love.graphics.printf("Painel de Upgrades", 150, 60, love.graphics.getWidth() - 300, "center")
        
        for _, element in ipairs(self.uiUpgradeElements) do element:draw() end
    end

    love.graphics.setColor(1, 1, 1)
end

function PlayState:mousepressed(x, y, button)
    if button ~= 1 then return end

    if self.isUpgradePanelOpen then
        for _, element in ipairs(self.uiUpgradeElements) do element:mousepressed(x, y, button) end
    end
    for _, element in ipairs(self.uiSpawnElements) do element:mousepressed(x, y, button) end
end

function PlayState:keypressed(key)
    if key == "escape" then
        Gamestate.switch(require("src.states.MenuState"))
    end
end

function PlayState:spawnEnemy()
    print("No início do spawnEnemy, o tipo de Enemy é: " .. type(Enemy)) -- <<< ADICIONE ESTA LINHA

    local enemyTypes = {"soldado", "tank", "ninja"}
    local randomType = enemyTypes[love.math.random(#enemyTypes)]
    local x = love.graphics.getWidth() + 20
    local y = love.graphics.getHeight() - 100
    
    -- Esta linha usa 'Enemy' (maiúsculo), que é a referência correta ao módulo.
    table.insert(self.enemies, Enemy.create(randomType, x, y))
end

return PlayState


--- FILE: \src\systems\animation.lua ---

---@class Animation
---@field spriteSheet love.Image
---@field quads table
---@field duration number
---@field currentTime number
local Animation = {}
Animation.__index = Animation


---@param imagePath string
---@param width integer
---@param height integer
---@param duration integer
---@return Animation obj
function Animation:newAnimation(imagePath, width, height, duration)
    local image = love.graphics.newImage(imagePath)
    local obj = {
        spriteSheet = image,
        quads = {}
    }
    setmetatable(obj, Animation)
    for y = 0, image:getHeight() - height, height do
        for x = 0, image:getWidth() - width, width do
            table.insert(obj.quads, love.graphics.newQuad(x, y, width, height, image:getDimensions()))
        end
    end

    obj.duration = duration or 1
    obj.currentTime = 0
    return obj
end

function Animation:_draw(x, y, flipped)
    local spriteNum = math.floor(self.currentTime / self.duration * #self.quads) + 1
    if spriteNum > #self.quads then spriteNum = #self.quads end
    local quad = self.quads[spriteNum]
    local sx = flipped and -1 or 1
    local ox = 0
    if flipped then
        local _, _, w, _ = quad:getViewport()
        ox = w
    end
    love.graphics.draw(self.spriteSheet, quad, x + ox, y, 0, sx, 1)
end


function Animation:_update(dt)
    self.currentTime = self.currentTime + dt
    if self.currentTime >= self.duration then
        self.currentTime = self.currentTime - self.duration
    end
end

function Animation:reset() self.currentTime = 0 end

return Animation


--- FILE: \src\systems\CollisionHandler.lua ---



--- FILE: \src\systems\Sprite.lua ---

---@class Sprite
---@field currentState number
---@field flipped boolean
local Sprite = {
    idle = 1, attack = 2, preAttack = 3
}
Sprite.__index = Sprite


---@param idle Animation
---@param attack Animation
---@param preAttack Animation
---@param flipped boolean
---@return Sprite
function Sprite:newSprite(idle, attack, preAttack, flipped)
    local obj = {
        idle,
        attack,
        preAttack,
        currentState = Sprite.idle,
        flipped = flipped
    }
    setmetatable(obj, Sprite)
    return obj
end

---@param state integer
function Sprite:setState(state)
    if self.currentState ~= state then
        self[self.currentState]:reset()
        self.currentState = state
    end
end

function Sprite:draw(x, y)
    self[self.currentState]:_draw(x, y, self.flipped)
end

function Sprite:update(dt)
    self[self.currentState]:_update(dt)
end

return Sprite


--- FILE: \src\systems\WaveManager.lua ---

-- Conceito para WaveManager.lua
local WaveManager = {}
-- ... (código do construtor)

function WaveManager:update(dt, enemies)
    if self.waveInProgress then
        -- Lógica de spawnar inimigos da wave atual
    elseif #enemies == 0 then
        -- Todos os inimigos morreram, inicia timer para próxima wave
        self.timer = self.timer + dt
        if self.timer > self.timeBetweenWaves then
            self:startNextWave()
        end
    end
end

function WaveManager:startNextWave()
    self.waveNumber = self.waveNumber + 1
    -- Aumenta a dificuldade: mais inimigos, inimigos mais fortes, etc.
end


--- FILE: \src\ui\Button.lua ---

-- src/ui/Button.lua
local Button = {}
Button.__index = Button

function Button.create(x, y, width, height, text, onClick)
    local btn = {
        x = x, y = y,
        width = width, height = height,
        text = text or "",
        onClick = onClick or function() end,
        isHovered = false
    }
    return setmetatable(btn, Button)
end

function Button:update(dt)
    local mx, my = love.mouse.getPosition()
    self.isHovered = mx > self.x and mx < self.x + self.width and
                     my > self.y and my < self.y + self.height
end

function Button:draw()
    if self.isHovered then
        love.graphics.setColor(0.5, 0.5, 0.5) -- Cinza quando hover
    else
        love.graphics.setColor(0.3, 0.3, 0.3) -- Cinza escuro normal
    end
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    
    love.graphics.setColor(1, 1, 1)
    love.graphics.printf(self.text, self.x, self.y + self.height / 4, self.width, "center")
end

function Button:mousepressed(x, y, button)
    if button == 1 and self.isHovered then
        self.onClick()
    end
end

return Button


--- FILE: \src\ui\Shop.lua ---



--- FILE: \src\utils\math.lua ---



--- FILE: \conf.lua ---

function love.conf(t)
	t.title = "Archer vs Mage"
	t.window.icon = "assets/icon.png"
	t.version = "11.5"
	t.window.width = 800
	t.window.height = 600
	t.console = true


	-- t.window.minheight = 500
	-- t.window.minwidth = 500
	-- t.window.resizable = true
	-- t.window.borderless = true
	-- t.window.vsync = 1
	-- t.window.display = 2
	-- t.window.fullscreen = true
end


--- FILE: \main.lua ---

local game = require("src/main_game")


--- FILE: \lib\anim8\anim8.lua ---

local anim8 = {
  _VERSION     = 'anim8 v2.3.1',
  _DESCRIPTION = 'An animation library for LÖVE',
  _URL         = 'https://github.com/kikito/anim8',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique García Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local Grid = {}

local _frames = {}

local function assertPositiveInteger(value, name)
  if type(value) ~= 'number' then error(("%s should be a number, was %q"):format(name, tostring(value))) end
  if value < 1 then error(("%s should be a positive number, was %d"):format(name, value)) end
  if value ~= math.floor(value) then error(("%s should be an integer, was %f"):format(name, value)) end
end

local function createFrame(self, x, y)
  local fw, fh = self.frameWidth, self.frameHeight
  return love.graphics.newQuad(
    self.left + (x-1) * fw + x * self.border,
    self.top  + (y-1) * fh + y * self.border,
    fw,
    fh,
    self.imageWidth,
    self.imageHeight
  )
end

local function getGridKey(...)
  return table.concat( {...} ,'-' )
end

local function getOrCreateFrame(self, x, y)
  if x < 1 or x > self.width or y < 1 or y > self.height then
    error(("There is no frame for x=%d, y=%d"):format(x, y))
  end
  local key = self._key
  _frames[key]       = _frames[key]       or {}
  _frames[key][x]    = _frames[key][x]    or {}
  _frames[key][x][y] = _frames[key][x][y] or createFrame(self, x, y)
  return _frames[key][x][y]
end

local function parseInterval(str)
  if type(str) == "number" then return str,str,1 end
  str = str:gsub('%s', '') -- remove spaces
  local min, max = str:match("^(%d+)-(%d+)$")
  assert(min and max, ("Could not parse interval from %q"):format(str))
  min, max = tonumber(min), tonumber(max)
  local step = min <= max and 1 or -1
  return min, max, step
end

function Grid:getFrames(...)
  local result, args = {}, {...}
  local minx, maxx, stepx, miny, maxy, stepy

  for i=1, #args, 2 do
    minx, maxx, stepx = parseInterval(args[i])
    miny, maxy, stepy = parseInterval(args[i+1])
    for y = miny, maxy, stepy do
      for x = minx, maxx, stepx do
        result[#result+1] = getOrCreateFrame(self,x,y)
      end
    end
  end

  return result
end

local Gridmt = {
  __index = Grid,
  __call  = Grid.getFrames
}

local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)
  assertPositiveInteger(frameWidth,  "frameWidth")
  assertPositiveInteger(frameHeight, "frameHeight")
  assertPositiveInteger(imageWidth,  "imageWidth")
  assertPositiveInteger(imageHeight, "imageHeight")

  left   = left   or 0
  top    = top    or 0
  border = border or 0

  local key  = getGridKey(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)

  local grid = setmetatable(
    { frameWidth  = frameWidth,
      frameHeight = frameHeight,
      imageWidth  = imageWidth,
      imageHeight = imageHeight,
      left        = left,
      top         = top,
      border      = border,
      width       = math.floor(imageWidth/frameWidth),
      height      = math.floor(imageHeight/frameHeight),
      _key        = key
    },
    Gridmt
  )
  return grid
end

-----------------------------------------------------------

local Animation = {}

local function cloneArray(arr)
  local result = {}
  for i=1,#arr do result[i] = arr[i] end
  return result
end

local function parseDurations(durations, frameCount)
  local result = {}
  if type(durations) == 'number' then
    for i=1,frameCount do result[i] = durations end
  else
    local min, max, step
    for key,duration in pairs(durations) do
      assert(type(duration) == 'number', "The value [" .. tostring(duration) .. "] should be a number")
      min, max, step = parseInterval(key)
      for i = min,max,step do result[i] = duration end
    end
  end

  if #result < frameCount then
    error("The durations table has length of " .. tostring(#result) .. ", but it should be >= " .. tostring(frameCount))
  end

  return result
end

local function parseIntervals(durations)
  local result, time = {0},0
  for i=1,#durations do
    time = time + durations[i]
    result[i+1] = time
  end
  return result, time
end

local Animationmt = { __index = Animation }
local nop = function() end

local function newAnimation(frames, durations, onLoop)
  local td = type(durations);
  if (td ~= 'number' or durations <= 0) and td ~= 'table' then
    error("durations must be a positive number. Was " .. tostring(durations) )
  end
  onLoop = onLoop or nop
  durations = parseDurations(durations, #frames)
  local intervals, totalDuration = parseIntervals(durations)
  return setmetatable({
      frames         = cloneArray(frames),
      durations      = durations,
      intervals      = intervals,
      totalDuration  = totalDuration,
      onLoop         = onLoop,
      timer          = 0,
      position       = 1,
      status         = "playing",
      flippedH       = false,
      flippedV       = false
    },
    Animationmt
  )
end

function Animation:clone()
  local newAnim = newAnimation(self.frames, self.durations, self.onLoop)
  newAnim.flippedH, newAnim.flippedV = self.flippedH, self.flippedV
  return newAnim
end

function Animation:flipH()
  self.flippedH = not self.flippedH
  return self
end

function Animation:flipV()
  self.flippedV = not self.flippedV
  return self
end

local function seekFrameIndex(intervals, timer)
  local high, low, i = #intervals-1, 1, 1

  while(low <= high) do
    i = math.floor((low + high) / 2)
    if     timer >= intervals[i+1] then low  = i + 1
    elseif timer <  intervals[i]   then high = i - 1
    else
      return i
    end
  end

  return i
end

function Animation:update(dt)
  if self.status ~= "playing" then return end

  self.timer = self.timer + dt
  local loops = math.floor(self.timer / self.totalDuration)
  if loops ~= 0 then
    self.timer = self.timer - self.totalDuration * loops
    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]
    f(self, loops)
  end

  self.position = seekFrameIndex(self.intervals, self.timer)
end

function Animation:pause()
  self.status = "paused"
end

function Animation:gotoFrame(position)
  self.position = position
  self.timer = self.intervals[self.position]
end

function Animation:pauseAtEnd()
  self.position = #self.frames
  self.timer = self.totalDuration
  self:pause()
end

function Animation:pauseAtStart()
  self.position = 1
  self.timer = 0
  self:pause()
end

function Animation:resume()
  self.status = "playing"
end

function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)
  love.graphics.draw(image, self:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky))
end

function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)
  local frame = self.frames[self.position]
  if self.flippedH or self.flippedV then
    r,sx,sy,ox,oy,kx,ky = r or 0, sx or 1, sy or 1, ox or 0, oy or 0, kx or 0, ky or 0
    local _,_,w,h = frame:getViewport()

    if self.flippedH then
      sx = sx * -1
      ox = w - ox
      kx = kx * -1
      ky = ky * -1
    end

    if self.flippedV then
      sy = sy * -1
      oy = h - oy
      kx = kx * -1
      ky = ky * -1
    end
  end
  return frame, x, y, r, sx, sy, ox, oy, kx, ky
end

function Animation:getDimensions()
  local _,_,w,h = self.frames[self.position]:getViewport()
  return w,h
end

-----------------------------------------------------------

anim8.newGrid       = newGrid
anim8.newAnimation  = newAnimation

return anim8


--- FILE: \lib\anim8\spec\love-mocks.lua ---

-- mocks for LÖVE functions
local unpack = _G.unpack or table.unpack

local Quadmt = {
  __eq = function(a,b)
    if #a ~= #b then return false end
    for i,v in ipairs(a) do
      if b[i] ~= v then return false end
    end
    return true
  end,
  __tostring = function(self)
    local buffer = {}
    for i,v in ipairs(self) do
      buffer[i] = tostring(v)
    end
    return "quad: {" .. table.concat(buffer, ",") .. "}"
  end,
  getViewport = function(self)
    return unpack(self)
  end
}

Quadmt.__index = Quadmt

_G.love = {
  graphics = {
    newQuad = function(...)
      return setmetatable({...}, Quadmt)
    end,
    draw = function()
    end,
    getLastDrawq = function()
    end
  }
}


--- FILE: \lib\anim8\spec\anim8\animation_spec.lua ---

require 'spec.love-mocks'

local anim8        = require 'anim8'
local newAnimation = anim8.newAnimation

describe("anim8", function()
  describe("newAnimation", function()

    it("Throws an error if durations is not a positive number or a table", function()
      assert.error(function() newAnimation({}, 'foo') end)
      assert.error(function() newAnimation({}, -1)    end)
      assert.error(function() newAnimation({}, 0)     end)
    end)

    it("sets the basic stuff", function()
      local a = newAnimation({1,2,3}, 4)
      assert.equal(0,         a.timer)
      assert.equal(1,         a.position)
      assert.equal("playing", a.status)
      assert.same({1,2,3}, a.frames)
      assert.same({4,4,4}, a.durations)
      assert.same({0,4,8,12}, a.intervals)
      assert.equal(12, a.totalDuration)
    end)
    it("makes a clone of the frame table", function()
      local frames = {1,2,3}
      local a = newAnimation(frames, 4)
      assert.same(frames, a.frames)
      assert.not_equal (frames, a.frames)
    end)

    describe("when parsing the durations", function()
      it("reads a simple array", function()
        local a = newAnimation({1,2,3,4}, {5,6,7,8})
        assert.same({5,6,7,8}, a.durations)
      end)
      it("reads a hash with strings or numbers", function()
        local a = newAnimation({1,2,3,4}, {['1-3']=1, [4]=4})
        assert.same({1,1,1,4}, a.durations)
      end)
      it("reads mixed-up durations", function()
        local a = newAnimation({1,2,3,4}, {5, ['2-4']=2})
        assert.same({5,2,2,2}, a.durations)
      end)
      describe("when given erroneous imput", function()
        it("throws errors for keys that are not integers or strings", function()
          assert.error(function() newAnimation({1}, {[{}]=1}) end)
          assert.error(function() newAnimation({1}, {[print]=1}) end)
          assert.error(function() newAnimation({1}, {print}) end)
        end)
        it("throws errors when frames are missing durations", function()
          assert.error(function() newAnimation({1,2,3,4,5}, {["1-3"]=1}) end)
          assert.error(function() newAnimation({1,2,3,4,5}, {1,2,3,4}) end)
        end)
      end)
    end)
  end)

  describe("Animation", function()
    describe(":update", function()
      it("moves to the next frame #focus", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(0.5)
        assert.equal(1, a.position)
        a:update(0.5)
        assert.equal(2, a.position)
      end)
      it("moves several frames if needed", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(2.1)
        assert.equal(3, a.position)
      end)

      describe("When the last frame is spent", function()
        it("goes back to the first frame in animations", function()
          local a = newAnimation({1,2,3,4}, 1)
          a:update(4.1)
          assert.equal(1, a.position)
        end)
      end)

      describe("When there are different durations per frame", function()
        it("moves the frame correctly", function()
          local a = newAnimation({1,2,3,4}, {1,2,1,1})
          a:update(1.1)
          assert.equal(2, a.position)
          a:update(1.1)
          assert.equal(2, a.position)
          a:update(1.1)
          assert.equal(3, a.position)
        end)
      end)

      describe("When the animation loops", function()
        it("invokes the onloop callback", function()
          local looped = false;
          local a = newAnimation({1,2,3}, 1, function() looped = true end)
          assert.False(looped)
          a:update(4)
          assert.True(looped)
        end)
        it("accepts the callback as a string", function()
          local a = newAnimation({1,2,3}, 1, 'foo')
          a.foo = function(self) self.looped = true end
          assert.Nil(a.looped)
          a:update(4)
          assert.True(a.looped)

        end)
        it("counts the loops", function()
          local count = 0;
          local a = newAnimation({1,2,3}, 1, function(_, x) count = count + x end)
          a:update(4)
          assert.equals(count, 1)
          a:update(7)
          assert.equals(count, 3)
        end)
        it("counts negative loops", function()
          local count = 0;
          local a = newAnimation({1,2,3}, 1, function(_, x) count = count + x end)
          a:update(-2)
          assert.equals(count, -1)
          a:update(-6)
          assert.equals(count, -3)
        end)
      end)
    end)

    describe(":pause", function()
      it("stops animations from happening", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:pause()
        a:update(1)
        assert.equal(2, a.position)
      end)
    end)

    describe(":resume", function()
      it("reanudates paused animations", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:pause()
        a:resume()
        a:update(1)
        assert.equal(3, a.position)
      end)
    end)

    describe(":gotoFrame", function()
      it("moves the position and time to the frame specified", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:update(1.1)
        a:gotoFrame(1)
        assert.equal(1, a.position)
        assert.equal(0, a.timer)
      end)
    end)

    describe(":pauseAtEnd", function()
      it("goes to the last frame, and pauses", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:pauseAtEnd()
        assert.equal(4, a.position)
        assert.equal(4, a.timer)
        assert.equal('paused', a.status)
      end)
    end)

    describe(":pauseAtStart", function()
      it("goes to the first frame, and pauses", function()
        local a = newAnimation({1,2,3,4}, 1)
        a:pauseAtStart()
        assert.equal(1, a.position)
        assert.equal(0, a.timer)
        assert.equal('paused', a.status)
      end)
    end)

    describe(":draw", function()
      it("invokes love.graphics.draw with the expected parameters", function()
        spy.on(love.graphics, 'draw')
        local img, frame1, frame2, frame3 = {},{},{},{}
        local a   = newAnimation({frame1, frame2, frame3}, 1)
        a:draw(img, 1,2,3,4,5,6,7,8,9)
        assert.spy(love.graphics.draw).was.called_with(img, frame1, 1,2,3,4,5,6,7,8,9)
      end)
    end)

    describe(":clone", function()
      it("returns a new animation with the same properties - but reset to the initial frame", function()
        local frames = {1,2,3,4}
        local a = newAnimation(frames, 1)
        a:update(1)
        a:pause()
        local b = a:clone()
        assert.not_equal(frames, b.frames)
        assert.same(frames, b.frames)
        assert.same(a.durations, b.durations)
        assert.equal(0, b.timer)
        assert.equal(1, b.position)
        assert.equal("playing", b.status )

        assert.False(b.flippedH)
        assert.False(b.flippedV)

        a:flipV()
        assert.True(a:clone().flippedV)

        a:flipH()
        assert.True(a:clone().flippedH)

      end)
    end)

    describe(":getDimensions", function()
      it("returns the width and height of the current frame", function()
        local frame1 = love.graphics.newQuad(0,0,10,10)
        local frame2 = love.graphics.newQuad(0,0,20,30)
        local frame3 = love.graphics.newQuad(0,0,5,15)

        local a = newAnimation({frame1, frame2, frame3}, 1)

        assert.same({10,10}, {a:getDimensions()})
        a:update(1.1)
        assert.same({20,30}, {a:getDimensions()})
        a:update(1)
        assert.same({5,15}, {a:getDimensions()})
        a:update(1)
        assert.same({10,10}, {a:getDimensions()})
      end)
    end)

    describe(":flipH and :flipV", function()
      local img, frame, a
      before_each(function()
        spy.on(love.graphics, 'draw')
        img = {}
        frame = love.graphics.newQuad(1,2,3,4) -- x,y,width, height
        a     = newAnimation({frame}, 1)
      end)
      it("defaults to non-flipped", function()
        assert.False(a.flippedH)
        assert.False(a.flippedV)
      end)

      it("Flips the animation horizontally (does not create a clone)", function()
        a:flipH()
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, -5,6,3-7,8,-9,-10)

        assert.equal(a, a:flipH())
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,6,7,8,9,10)
      end)

      it("Flips the animation vertically (does not create a clone)", function()
        a:flipV()
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,-6,7,4-8,-9,-10)

        assert.equal(a, a:flipV())
        a:draw(img, 10, 20, 0, 5,6,7,8,9,10)
        assert.spy(love.graphics.draw).was.called_with(img, frame, 10, 20, 0, 5,6,7,8,9,10)
      end)
    end)
  end)
end)


--- FILE: \lib\anim8\spec\anim8\grid_spec.lua ---

require 'spec.love-mocks'

local anim8 = require 'anim8'

local newQuad   = love.graphics.newQuad
local newGrid   = anim8.newGrid

describe("anim8", function()

  describe("newGrid", function()
    it("throws error if any of its parameters is not a positive integer", function()
      assert.error(function() newGrid() end)
      assert.error(function() newGrid(1) end)
      assert.error(function() newGrid(1,1,1,-1) end)
      assert.error(function() newGrid(0,1,1,1) end)
      assert.error(function() newGrid(1,1,'a',1) end)
    end)

    it("preserves the values", function()
      local g = newGrid(1,2,3,4,5,6,7)
      assert.equal(1, g.frameWidth)
      assert.equal(2, g.frameHeight)
      assert.equal(3, g.imageWidth)
      assert.equal(4, g.imageHeight)
      assert.equal(5, g.left)
      assert.equal(6, g.top)
      assert.equal(7, g.border)
    end)

    it("calculates width and height", function()
      local g = newGrid(32,32,64,256)
      assert.equal(2, g.width)
      assert.equal(8, g.height)
    end)

    it("presets border and offsets to 0", function()
      local g = newGrid(32,32,64,256)
      assert.equal(0, g.left)
      assert.equal(0, g.top)
      assert.equal(0, g.border)
    end)
  end)

  describe("Grid", function()
    describe("getFrames", function()
      local g, nq
      before_each(function()
        g = newGrid(16,16,64,64)
        nq = function(x,y) return newQuad(x,y, 16,16, 64,64) end
      end)

      describe("with 2 integers", function()
        it("returns a single frame", function()
          assert.equal(nq(0,0), g:getFrames(1,1)[1])
        end)
        it("returns another single frame", function()
          assert.equal(nq(32,16), g:getFrames(3,2)[1])
        end)
        it("throws an error if the frame does not exist", function()
          assert.error(function() g:getFrames(10,10) end)
        end)
      end)

      describe("with several pairs of integers", function()
        it("returns a list of frames", function()
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(0,32), nq(16,16), nq(32,0)}, frames)
        end)
        it("takes into account border widths", function()
          g = newGrid(16,16,64,64,0,0,1)
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(1,35), nq(18,18), nq(35,1)}, frames)
        end)
        it("takes into account left and top", function()
          g = newGrid(16,16,64,64,10,20)
          local frames = g:getFrames(1,3, 2,2, 3,1)
          assert.same({nq(10,52), nq(26,36), nq(42,20)}, frames)
        end)
      end)

      describe("with a string and a integer", function()
        it("returns a list of frames", function()
          local frames = g:getFrames('1-2', 2)
          assert.equal(nq(0,16) , frames[1])
          assert.equal(nq(16,16), frames[2])
        end)
        it("throws an error for invalid strings", function()
          assert.error(function() g:getFrames('foo', 1) end)
          assert.error(function() g:getFrames('foo-bar', 1) end)
          assert.error(function() g:getFrames('1-foo', 1) end)
        end)
        it("throws an error for valid strings representing too big indexes", function()
          assert.error(function() g:getFrames('1000-1') end)
        end)
      end)

      describe("with several strings", function()
        it("returns a list of frames", function()
          local frames = g:getFrames('1-2',2, 3,2)
          assert.same({nq(0,16), nq(16,16), nq(32,16)}, frames)
        end)
        it("parses rows first, then columns", function()
          local frames = g:getFrames('1-3','1-3')
          assert.same({ nq(0,0),  nq(16,0),  nq(32,0),
                        nq(0,16), nq(16,16), nq(32,16),
                        nq(0,32), nq(16,32), nq(32,32)
                      },
                      frames)
        end)
        it("counts backwards if the first number in the string is greater than the second one", function()
          local frames = g:getFrames('3-1',2)
          assert.same({nq(32,16), nq(16,16), nq(0,16)}, frames)
        end)
      end)


      describe("with a non-number or string", function()
        it("throws an error", function()
          assert.error(function() g:getFrames({1,10}) end)
        end)
      end)

      describe("When two similar grids are requested for the same quad", function()
        it("is not created twice", function()
          local g2 = newGrid(16,16,64,64)
          local q1 = setmetatable(g:getFrames(1,1)[1], nil)
          local q2 = setmetatable(g2:getFrames(1,1)[1], nil)
          assert.equal(q1, q2)
        end)
      end)

    end)

    describe("()", function()
      it("is a shortcut to :getFrames", function()
        local g = newGrid(16,16,64,64)
        assert.equal(g:getFrames(1,1)[1], g(1,1)[1])
      end)
    end)
  end)
end)


--- FILE: \lib\bump.lua\bump.lua ---

local bump = {
  _VERSION     = 'bump v3.1.7',
  _URL         = 'https://github.com/kikito/bump.lua',
  _DESCRIPTION = 'A collision detection library for Lua',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2014 Enrique García Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

------------------------------------------
-- Auxiliary functions
------------------------------------------
local DELTA = 1e-10 -- floating-point margin of error

local abs, floor, ceil, min, max = math.abs, math.floor, math.ceil, math.min, math.max

local function sign(x)
  if x > 0 then return 1 end
  if x == 0 then return 0 end
  return -1
end

local function nearest(x, a, b)
  if abs(a - x) < abs(b - x) then return a else return b end
end

local function assertType(desiredType, value, name)
  if type(value) ~= desiredType then
    error(name .. ' must be a ' .. desiredType .. ', but was ' .. tostring(value) .. '(a ' .. type(value) .. ')')
  end
end

local function assertIsPositiveNumber(value, name)
  if type(value) ~= 'number' or value <= 0 then
    error(name .. ' must be a positive integer, but was ' .. tostring(value) .. '(' .. type(value) .. ')')
  end
end

local function assertIsRect(x,y,w,h)
  assertType('number', x, 'x')
  assertType('number', y, 'y')
  assertIsPositiveNumber(w, 'w')
  assertIsPositiveNumber(h, 'h')
end

local defaultFilter = function()
  return 'slide'
end

------------------------------------------
-- Rectangle functions
------------------------------------------

local function rect_getNearestCorner(x,y,w,h, px, py)
  return nearest(px, x, x+w), nearest(py, y, y+h)
end

-- This is a generalized implementation of the liang-barsky algorithm, which also returns
-- the normals of the sides where the segment intersects.
-- Returns nil if the segment never touches the rect
-- Notice that normals are only guaranteed to be accurate when initially ti1, ti2 == -math.huge, math.huge
local function rect_getSegmentIntersectionIndices(x,y,w,h, x1,y1,x2,y2, ti1,ti2)
  ti1, ti2 = ti1 or 0, ti2 or 1
  local dx, dy = x2-x1, y2-y1
  local nx, ny
  local nx1, ny1, nx2, ny2 = 0,0,0,0
  local p, q, r

  for side = 1,4 do
    if     side == 1 then nx,ny,p,q = -1,  0, -dx, x1 - x     -- left
    elseif side == 2 then nx,ny,p,q =  1,  0,  dx, x + w - x1 -- right
    elseif side == 3 then nx,ny,p,q =  0, -1, -dy, y1 - y     -- top
    else                  nx,ny,p,q =  0,  1,  dy, y + h - y1 -- bottom
    end

    if p == 0 then
      if q <= 0 then return nil end
    else
      r = q / p
      if p < 0 then
        if     r > ti2 then return nil
        elseif r > ti1 then ti1,nx1,ny1 = r,nx,ny
        end
      else -- p > 0
        if     r < ti1 then return nil
        elseif r < ti2 then ti2,nx2,ny2 = r,nx,ny
        end
      end
    end
  end

  return ti1,ti2, nx1,ny1, nx2,ny2
end

-- Calculates the minkowsky difference between 2 rects, which is another rect
local function rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)
  return x2 - x1 - w1,
         y2 - y1 - h1,
         w1 + w2,
         h1 + h2
end

local function rect_containsPoint(x,y,w,h, px,py)
  return px - x > DELTA      and py - y > DELTA and
         x + w - px > DELTA  and y + h - py > DELTA
end

local function rect_isIntersecting(x1,y1,w1,h1, x2,y2,w2,h2)
  return x1 < x2+w2 and x2 < x1+w1 and
         y1 < y2+h2 and y2 < y1+h1
end

local function rect_getSquareDistance(x1,y1,w1,h1, x2,y2,w2,h2)
  local dx = x1 - x2 + (w1 - w2)/2
  local dy = y1 - y2 + (h1 - h2)/2
  return dx*dx + dy*dy
end

local function rect_detectCollision(x1,y1,w1,h1, x2,y2,w2,h2, goalX, goalY)
  goalX = goalX or x1
  goalY = goalY or y1

  local dx, dy      = goalX - x1, goalY - y1
  local x,y,w,h     = rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)

  local overlaps, ti, nx, ny

  if rect_containsPoint(x,y,w,h, 0,0) then -- item was intersecting other
    local px, py    = rect_getNearestCorner(x,y,w,h, 0, 0)
    local wi, hi    = min(w1, abs(px)), min(h1, abs(py)) -- area of intersection
    ti              = -wi * hi -- ti is the negative area of intersection
    overlaps = true
  else
    local ti1,ti2,nx1,ny1 = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, math.huge)

    -- item tunnels into other
    if ti1
    and ti1 < 1
    and (abs(ti1 - ti2) >= DELTA) -- special case for rect going through another rect's corner
    and (0 < ti1 + DELTA
      or 0 == ti1 and ti2 > 0)
    then
      ti, nx, ny = ti1, nx1, ny1
      overlaps   = false
    end
  end

  if not ti then return end

  local tx, ty

  if overlaps then
    if dx == 0 and dy == 0 then
      -- intersecting and not moving - use minimum displacement vector
      local px, py = rect_getNearestCorner(x,y,w,h, 0,0)
      if abs(px) < abs(py) then py = 0 else px = 0 end
      nx, ny = sign(px), sign(py)
      tx, ty = x1 + px, y1 + py
    else
      -- intersecting and moving - move in the opposite direction
      local ti1, _
      ti1,_,nx,ny = rect_getSegmentIntersectionIndices(x,y,w,h, 0,0,dx,dy, -math.huge, 1)
      if not ti1 then return end
      tx, ty = x1 + dx * ti1, y1 + dy * ti1
    end
  else -- tunnel
    tx, ty = x1 + dx * ti, y1 + dy * ti
  end

  return {
    overlaps  = overlaps,
    ti        = ti,
    move      = {x = dx, y = dy},
    normal    = {x = nx, y = ny},
    touch     = {x = tx, y = ty},
    itemRect  = {x = x1, y = y1, w = w1, h = h1},
    otherRect = {x = x2, y = y2, w = w2, h = h2}
  }
end

------------------------------------------
-- Grid functions
------------------------------------------

local function grid_toWorld(cellSize, cx, cy)
  return (cx - 1)*cellSize, (cy-1)*cellSize
end

local function grid_toCell(cellSize, x, y)
  return floor(x / cellSize) + 1, floor(y / cellSize) + 1
end

-- grid_traverse* functions are based on "A Fast Voxel Traversal Algorithm for Ray Tracing",
-- by John Amanides and Andrew Woo - http://www.cse.yorku.ca/~amana/research/grid.pdf
-- It has been modified to include both cells when the ray "touches a grid corner",
-- and with a different exit condition

local function grid_traverse_initStep(cellSize, ct, t1, t2)
  local v = t2 - t1
  if     v > 0 then
    return  1,  cellSize / v, ((ct + v) * cellSize - t1) / v
  elseif v < 0 then
    return -1, -cellSize / v, ((ct + v - 1) * cellSize - t1) / v
  else
    return 0, math.huge, math.huge
  end
end

local function grid_traverse(cellSize, x1,y1,x2,y2, f)
  local cx1,cy1        = grid_toCell(cellSize, x1,y1)
  local cx2,cy2        = grid_toCell(cellSize, x2,y2)
  local stepX, dx, tx  = grid_traverse_initStep(cellSize, cx1, x1, x2)
  local stepY, dy, ty  = grid_traverse_initStep(cellSize, cy1, y1, y2)
  local cx,cy          = cx1,cy1

  f(cx, cy)

  -- The default implementation had an infinite loop problem when
  -- approaching the last cell in some occassions. We finish iterating
  -- when we are *next* to the last cell
  while abs(cx - cx2) + abs(cy - cy2) > 1 do
    if tx < ty then
      tx, cx = tx + dx, cx + stepX
      f(cx, cy)
    else
      -- Addition: include both cells when going through corners
      if tx == ty then f(cx + stepX, cy) end
      ty, cy = ty + dy, cy + stepY
      f(cx, cy)
    end
  end

  -- If we have not arrived to the last cell, use it
  if cx ~= cx2 or cy ~= cy2 then f(cx2, cy2) end

end

local function grid_toCellRect(cellSize, x,y,w,h)
  local cx,cy = grid_toCell(cellSize, x, y)
  local cr,cb = ceil((x+w) / cellSize), ceil((y+h) / cellSize)
  return cx, cy, cr - cx + 1, cb - cy + 1
end

------------------------------------------
-- Responses
------------------------------------------

local touch = function(world, col, x,y,w,h, goalX, goalY, filter)
  return col.touch.x, col.touch.y, {}, 0
end

local cross = function(world, col, x,y,w,h, goalX, goalY, filter)
  local cols, len = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local slide = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move  = col.touch, col.move
  if move.x ~= 0 or move.y ~= 0 then
    if col.normal.x ~= 0 then
      goalX = tch.x
    else
      goalY = tch.y
    end
  end

  col.slide = {x = goalX, y = goalY}

  x,y = tch.x, tch.y
  local cols, len  = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

local bounce = function(world, col, x,y,w,h, goalX, goalY, filter)
  goalX = goalX or x
  goalY = goalY or y

  local tch, move = col.touch, col.move
  local tx, ty = tch.x, tch.y

  local bx, by = tx, ty

  if move.x ~= 0 or move.y ~= 0 then
    local bnx, bny = goalX - tx, goalY - ty
    if col.normal.x == 0 then bny = -bny else bnx = -bnx end
    bx, by = tx + bnx, ty + bny
  end

  col.bounce   = {x = bx,  y = by}
  x,y          = tch.x, tch.y
  goalX, goalY = bx, by

  local cols, len    = world:project(col.item, x,y,w,h, goalX, goalY, filter)
  return goalX, goalY, cols, len
end

------------------------------------------
-- World
------------------------------------------

local World = {}
local World_mt = {__index = World}

-- Private functions and methods

local function sortByWeight(a,b) return a.weight < b.weight end

local function sortByTiAndDistance(a,b)
  if a.ti == b.ti then
    local ir, ar, br = a.itemRect, a.otherRect, b.otherRect
    local ad = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, ar.x,ar.y,ar.w,ar.h)
    local bd = rect_getSquareDistance(ir.x,ir.y,ir.w,ir.h, br.x,br.y,br.w,br.h)
    return ad < bd
  end
  return a.ti < b.ti
end

local function addItemToCell(self, item, cx, cy)
  self.rows[cy] = self.rows[cy] or setmetatable({}, {__mode = 'v'})
  local row = self.rows[cy]
  row[cx] = row[cx] or {itemCount = 0, x = cx, y = cy, items = setmetatable({}, {__mode = 'k'})}
  local cell = row[cx]
  self.nonEmptyCells[cell] = true
  if not cell.items[item] then
    cell.items[item] = true
    cell.itemCount = cell.itemCount + 1
  end
end

local function removeItemFromCell(self, item, cx, cy)
  local row = self.rows[cy]
  if not row or not row[cx] or not row[cx].items[item] then return false end

  local cell = row[cx]
  cell.items[item] = nil
  cell.itemCount = cell.itemCount - 1
  if cell.itemCount == 0 then
    self.nonEmptyCells[cell] = nil
  end
  return true
end

local function getDictItemsInCellRect(self, cl,ct,cw,ch)
  local items_dict = {}
  for cy=ct,ct+ch-1 do
    local row = self.rows[cy]
    if row then
      for cx=cl,cl+cw-1 do
        local cell = row[cx]
        if cell and cell.itemCount > 0 then -- no cell.itemCount > 1 because tunneling
          for item,_ in pairs(cell.items) do
            items_dict[item] = true
          end
        end
      end
    end
  end

  return items_dict
end

local function getCellsTouchedBySegment(self, x1,y1,x2,y2)

  local cells, cellsLen, visited = {}, 0, {}

  grid_traverse(self.cellSize, x1,y1,x2,y2, function(cx, cy)
    local row  = self.rows[cy]
    if not row then return end
    local cell = row[cx]
    if not cell or visited[cell] then return end

    visited[cell] = true
    cellsLen = cellsLen + 1
    cells[cellsLen] = cell
  end)

  return cells, cellsLen
end

local function getInfoAboutItemsTouchedBySegment(self, x1,y1, x2,y2, filter)
  local cells, len = getCellsTouchedBySegment(self, x1,y1,x2,y2)
  local cell, rect, l,t,w,h, ti1,ti2, tii0,tii1
  local visited, itemInfo, itemInfoLen = {},{},0
  for i=1,len do
    cell = cells[i]
    for item in pairs(cell.items) do
      if not visited[item] then
        visited[item]  = true
        if (not filter or filter(item)) then
          rect           = self.rects[item]
          l,t,w,h        = rect.x,rect.y,rect.w,rect.h

          ti1,ti2 = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, 0, 1)
          if ti1 and ((0 < ti1 and ti1 < 1) or (0 < ti2 and ti2 < 1)) then
            -- the sorting is according to the t of an infinite line, not the segment
            tii0,tii1    = rect_getSegmentIntersectionIndices(l,t,w,h, x1,y1, x2,y2, -math.huge, math.huge)
            itemInfoLen  = itemInfoLen + 1
            itemInfo[itemInfoLen] = {item = item, ti1 = ti1, ti2 = ti2, weight = min(tii0,tii1)}
          end
        end
      end
    end
  end
  table.sort(itemInfo, sortByWeight)
  return itemInfo, itemInfoLen
end

local function getResponseByName(self, name)
  local response = self.responses[name]
  if not response then
    error(('Unknown collision type: %s (%s)'):format(name, type(name)))
  end
  return response
end


-- Misc Public Methods

function World:addResponse(name, response)
  self.responses[name] = response
end

function World:project(item, x,y,w,h, goalX, goalY, filter)
  assertIsRect(x,y,w,h)

  goalX = goalX or x
  goalY = goalY or y
  filter  = filter  or defaultFilter

  local collisions, len = {}, 0

  local visited = {}
  if item ~= nil then visited[item] = true end

  -- This could probably be done with less cells using a polygon raster over the cells instead of a
  -- bounding rect of the whole movement. Conditional to building a queryPolygon method
  local tl, tt = min(goalX, x),       min(goalY, y)
  local tr, tb = max(goalX + w, x+w), max(goalY + h, y+h)
  local tw, th = tr-tl, tb-tt

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, tl,tt,tw,th)

  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  for other,_ in pairs(dictItemsInCellRect) do
    if not visited[other] then
      visited[other] = true

      local responseName = filter(item, other)
      if responseName then
        local ox,oy,ow,oh   = self:getRect(other)
        local col           = rect_detectCollision(x,y,w,h, ox,oy,ow,oh, goalX, goalY)

        if col then
          col.other    = other
          col.item     = item
          col.type     = responseName

          len = len + 1
          collisions[len] = col
        end
      end
    end
  end

  table.sort(collisions, sortByTiAndDistance)

  return collisions, len
end

function World:countCells()
  local count = 0
  for _,row in pairs(self.rows) do
    for _,_ in pairs(row) do
      count = count + 1
    end
  end
  return count
end

function World:hasItem(item)
  return not not self.rects[item]
end

function World:getItems()
  local items, len = {}, 0
  for item,_ in pairs(self.rects) do
    len = len + 1
    items[len] = item
  end
  return items, len
end

function World:countItems()
  local len = 0
  for _ in pairs(self.rects) do len = len + 1 end
  return len
end

function World:getRect(item)
  local rect = self.rects[item]
  if not rect then
    error('Item ' .. tostring(item) .. ' must be added to the world before getting its rect. Use world:add(item, x,y,w,h) to add it first.')
  end
  return rect.x, rect.y, rect.w, rect.h
end

function World:toWorld(cx, cy)
  return grid_toWorld(self.cellSize, cx, cy)
end

function World:toCell(x,y)
  return grid_toCell(self.cellSize, x, y)
end


--- Query methods

function World:queryRect(x,y,w,h, filter)

  assertIsRect(x,y,w,h)

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cl,ct,cw,ch)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_isIntersecting(x,y,w,h, rect.x, rect.y, rect.w, rect.h)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:queryPoint(x,y, filter)
  local cx,cy = self:toCell(x,y)
  local dictItemsInCellRect = getDictItemsInCellRect(self, cx,cy,1,1)

  local items, len = {}, 0

  local rect
  for item,_ in pairs(dictItemsInCellRect) do
    rect = self.rects[item]
    if (not filter or filter(item))
    and rect_containsPoint(rect.x, rect.y, rect.w, rect.h, x, y)
    then
      len = len + 1
      items[len] = item
    end
  end

  return items, len
end

function World:querySegment(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local items = {}
  for i=1, len do
    items[i] = itemInfo[i].item
  end
  return items, len
end

function World:querySegmentWithCoords(x1, y1, x2, y2, filter)
  local itemInfo, len = getInfoAboutItemsTouchedBySegment(self, x1, y1, x2, y2, filter)
  local dx, dy        = x2-x1, y2-y1
  local info, ti1, ti2
  for i=1, len do
    info  = itemInfo[i]
    ti1   = info.ti1
    ti2   = info.ti2

    info.weight  = nil
    info.x1      = x1 + dx * ti1
    info.y1      = y1 + dy * ti1
    info.x2      = x1 + dx * ti2
    info.y2      = y1 + dy * ti2
  end
  return itemInfo, len
end


--- Main methods

function World:add(item, x,y,w,h)
  local rect = self.rects[item]
  if rect then
    error('Item ' .. tostring(item) .. ' added to the world twice.')
  end
  assertIsRect(x,y,w,h)

  self.rects[item] = {x=x,y=y,w=w,h=h}

  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      addItemToCell(self, item, cx, cy)
    end
  end

  return item
end

function World:remove(item)
  local x,y,w,h = self:getRect(item)

  self.rects[item] = nil
  local cl,ct,cw,ch = grid_toCellRect(self.cellSize, x,y,w,h)
  for cy = ct, ct+ch-1 do
    for cx = cl, cl+cw-1 do
      removeItemFromCell(self, item, cx, cy)
    end
  end
end

function World:update(item, x2,y2,w2,h2)
  local x1,y1,w1,h1 = self:getRect(item)
  w2,h2 = w2 or w1, h2 or h1
  assertIsRect(x2,y2,w2,h2)

  if x1 ~= x2 or y1 ~= y2 or w1 ~= w2 or h1 ~= h2 then

    local cellSize = self.cellSize
    local cl1,ct1,cw1,ch1 = grid_toCellRect(cellSize, x1,y1,w1,h1)
    local cl2,ct2,cw2,ch2 = grid_toCellRect(cellSize, x2,y2,w2,h2)

    if cl1 ~= cl2 or ct1 ~= ct2 or cw1 ~= cw2 or ch1 ~= ch2 then

      local cr1, cb1 = cl1+cw1-1, ct1+ch1-1
      local cr2, cb2 = cl2+cw2-1, ct2+ch2-1
      local cyOut

      for cy = ct1, cb1 do
        cyOut = cy < ct2 or cy > cb2
        for cx = cl1, cr1 do
          if cyOut or cx < cl2 or cx > cr2 then
            removeItemFromCell(self, item, cx, cy)
          end
        end
      end

      for cy = ct2, cb2 do
        cyOut = cy < ct1 or cy > cb1
        for cx = cl2, cr2 do
          if cyOut or cx < cl1 or cx > cr1 then
            addItemToCell(self, item, cx, cy)
          end
        end
      end

    end

    local rect = self.rects[item]
    rect.x, rect.y, rect.w, rect.h = x2,y2,w2,h2

  end
end

function World:move(item, goalX, goalY, filter)
  local actualX, actualY, cols, len = self:check(item, goalX, goalY, filter)

  self:update(item, actualX, actualY)

  return actualX, actualY, cols, len
end

function World:check(item, goalX, goalY, filter)
  filter = filter or defaultFilter

  local visited = {[item] = true}
  local visitedFilter = function(itm, other)
    if visited[other] then return false end
    return filter(itm, other)
  end

  local cols, len = {}, 0

  local x,y,w,h = self:getRect(item)

  local projected_cols, projected_len = self:project(item, x,y,w,h, goalX,goalY, visitedFilter)

  while projected_len > 0 do
    local col = projected_cols[1]
    len       = len + 1
    cols[len] = col

    visited[col.other] = true

    local response = getResponseByName(self, col.type)

    goalX, goalY, projected_cols, projected_len = response(
      self,
      col,
      x, y, w, h,
      goalX, goalY,
      visitedFilter
    )
  end

  return goalX, goalY, cols, len
end


-- Public library functions

bump.newWorld = function(cellSize)
  cellSize = cellSize or 64
  assertIsPositiveNumber(cellSize, 'cellSize')
  local world = setmetatable({
    cellSize       = cellSize,
    rects          = {},
    rows           = {},
    nonEmptyCells  = {},
    responses = {}
  }, World_mt)

  world:addResponse('touch', touch)
  world:addResponse('cross', cross)
  world:addResponse('slide', slide)
  world:addResponse('bounce', bounce)

  return world
end

bump.rect = {
  getNearestCorner              = rect_getNearestCorner,
  getSegmentIntersectionIndices = rect_getSegmentIntersectionIndices,
  getDiff                       = rect_getDiff,
  containsPoint                 = rect_containsPoint,
  isIntersecting                = rect_isIntersecting,
  getSquareDistance             = rect_getSquareDistance,
  detectCollision               = rect_detectCollision
}

bump.responses = {
  touch  = touch,
  cross  = cross,
  slide  = slide,
  bounce = bounce
}

return bump


--- FILE: \lib\bump.lua\spec\bump_spec.lua ---

local bump = require 'bump'

describe('bump', function()

  describe('newWorld', function()
    it('creates a world', function()
      assert.truthy(bump.newWorld())
    end)

    it('defaults the cellSize to 64', function()
      assert.equal(bump.newWorld().cellSize, 64)
    end)

    it('can set the cellSize', function()
      assert.equal(bump.newWorld(32).cellSize, 32)
    end)

    it('throws an error if cellsize is not a positive number', function()
      assert.error(function() bump.newWorld(-10) end)
      assert.error(function() bump.newWorld("") end)
    end)
  end)

end)


--- FILE: \lib\bump.lua\spec\rect_spec.lua ---

local rect = require('bump').rect

describe('bump.rect', function()

  describe('detectCollision', function()
    local detect = rect.detectCollision
    describe('when item is static', function()

      describe('when itemRect does not intersect otherRect', function()
        it('returns nil', function()
          local c = detect(0,0,1,1, 5,5,1,1, 0,0)
          assert.is_nil(c)
        end)
      end)

      describe('when itemRect overlaps otherRect', function()
        it('returns overlaps, normal, move, ti, diff, itemRect, otherRect', function()
          local c = detect(0,0,7,6, 5,5,1,1, 0, 0)

          assert.is_true(c.overlaps)
          assert.equals(c.ti, -2)
          assert.same(c.move, {x = 0, y = 0})
          assert.same(c.itemRect, {x=0,y=0,w=7,h=6})
          assert.same(c.otherRect, {x=5,y=5,w=1,h=1})
          assert.same(c.normal, {x=0, y=-1})

        end)
      end)

    end)

    describe('when item is moving', function()
      describe('when itemRect does not intersect otherRect', function()
        it('returns nil', function()
          local c = detect(0,0,1,1, 5,5,1,1, 0,1)
          assert.is_nil(c)
        end)
      end)
      describe('when itemRect intersects otherRect', function()
        it('detects collisions from the left', function()
          local c = detect(1,1,1,1, 5,0,1,1, 6,0)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=-1, y=0})
        end)
        it('detects collisions from the right', function()
          local c = detect(6,0,1,1, 1,0,1,1, 1,1)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.8)
          assert.same(c.normal, {x=1, y=0})
        end)
        it('detects collisions from the top', function()
          local c = detect(0,0,1,1, 0,4,1,1, 0,5)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=0, y=-1})
        end)
        it('detects collisions from the bottom', function()
          local c = detect(0,4,1,1, 0,0,1,1, 0,-1)
          assert.is_false(c.overlaps)
          assert.equal(c.ti, 0.6)
          assert.same(c.normal, {x=0, y=1})
        end)
      end)
      it('does not get caught by nasty corner cases', function()
        assert.is_nil(detect( 0,16,16,16, 16,0,16,16, -1,15))
      end)
    end)
  end)
end)



--- FILE: \lib\bump.lua\spec\responses_spec.lua ---

local bump            = require('bump')
local detect          = bump.rect.detectCollision
local responses  = bump.responses

local world = bump.newWorld()

local touch = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y}
end

local slide = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  responses.slide(world, col, x, y, w, h, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y, col.slide.x, col.slide.y}
end

local bounce = function(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  local col = detect(x,y,w,h, ox,oy,ow,oh, goalX, goalY)
  responses.bounce(world, col, x, y, w, h, goalX, goalY)
  return {col.touch.x, col.touch.y, col.normal.x, col.normal.y, col.bounce.x, col.bounce.y }
end

describe('bump.responses', function()
  describe('touch', function()
    describe('when resolving collisions', function()
      describe('on overlaps', function()
        describe('when there is no movement', function()
          it('returns the left,top coordinates of the minimum displacement on static items', function()

            --                                          -2-1 0 1 2 3 4 5 6 7 8 9 10
            --      -2 -1 0 1 2 3 4 5 6 7 8 9           -2 · ┌–––┐ · ┌–––┐ · ┌–––┐ ·
            --      -1  ┌–––┐ · ┌–––┐ · ┌–––┐           -1 · │0-1│ · │0-1│ · │0-1│ ·
            --       0  │ ┌–––––––––––––––┐ │ 1  2  3    0 · └–┌–––––––––––––––┐–┘ ·
            --       1  └–│–┘ · └–––┘ · └–│–┘            1 · · │ · · · · · · · │ · ·
            --       2  · │ · · · · · · · │ ·            2 · · │ · · · · · · · │ · ·
            --       3  ┌–│–┐ · ┌–––┐ · ┌–│–┐            3 ┌–––│ · · · · · · · │–––┐
            --       4  │ │ │ · │ · │ · │ │ │ 4  5  6    4 -1 0│ · · · · · · · │1 0│
            --       5  └–│–┘ · └–––┘ · └–│–┘            5 └–––│ · · · · · · · │–––┘
            --       6  · │ · · · · · · · │ ·            6 · · │ · · · · · · · │ · ·
            --       7  ┌–│–┐ · ┌–––┐ · ┌–│–┐            7 · · │ · · · · · · · │ · ·
            --       8  │ └–––––––––––––––┘ │ 7  8  9    8 · ┌–└–––––––––––––––┘–┐ ·
            --       9  └–––┘ · └–––┘ · └–––┘            9 · │0 1│ · ╎0 1╎ · │0 1│ ·
            --      10                                  10 · └–––┘ · └╌╌╌┘ · └–––┘ ·

            assert.same(touch(-1,-1,2,2, 0,0,8,8), {-1,-2, 0, -1}) -- 1
            assert.same(touch( 3,-1,2,2, 0,0,8,8), { 3,-2, 0, -1}) -- 2
            assert.same(touch( 7,-1,2,2, 0,0,8,8), { 7,-2, 0, -1}) -- 3

            assert.same(touch(-1, 3,2,2, 0,0,8,8), {-2, 3, -1, 0}) -- 4
            assert.same(touch( 3, 3,2,2, 0,0,8,8), { 3, 8,  0, 1}) -- 5
            assert.same(touch( 7, 3,2,2, 0,0,8,8), { 8, 3,  1, 0}) -- 6

            assert.same(touch(-1, 7,2,2, 0,0,8,8), {-1, 8,  0, 1}) -- 7
            assert.same(touch( 3, 7,2,2, 0,0,8,8), { 3, 8,  0, 1}) -- 8
            assert.same(touch( 7, 7,2,2, 0,0,8,8), { 7, 8,  0, 1}) -- 9

          end)
        end)

        describe('when the item is moving', function()
          it('returns the left,top coordinates of the overlaps with the movement line, opposite direction', function()
            assert.same(touch(3,3,2,2, 0,0,8,8, 4, 3), { -2,  3, -1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 2, 3), {  8,  3,  1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 2, 3), {  8,  3,  1,  0})
            assert.same(touch(3,3,2,2, 0,0,8,8, 3, 4), {  3, -2,  0, -1})
            assert.same(touch(3,3,2,2, 0,0,8,8, 3, 2), {  3,  8,  0,  1})
          end)
        end)
      end)

      describe('on tunnels', function()
        it('returns the coordinates of the item when it starts touching the other, and the normal', function()
          assert.same(touch(-3, 3,2,2, 0,0,8,8, 3,3), { -2,  3, -1,  0})
          assert.same(touch( 9, 3,2,2, 0,0,8,8, 3,3), {  8,  3,  1,  0})
          assert.same(touch( 3,-3,2,2, 0,0,8,8, 3,3), {  3, -2,  0, -1})
          assert.same(touch( 3, 9,2,2, 0,0,8,8, 3,3), {  3,  8,  0,  1})
        end)
      end)
    end)
  end)

  describe('slide', function()
    it('slides on overlaps', function()
      assert.same(slide(3,3,2,2, 0,0,8,8, 4, 5), { 0.5, -2, 0,-1, 4, -2})
      assert.same(slide(3,3,2,2, 0,0,8,8, 5, 4), { -2, 0.5, -1,0, -2, 4})
      assert.same(slide(3,3,2,2, 0,0,8,8, 2, 1), { 5.5, 8, 0,1, 2, 8})
      assert.same(slide(3,3,2,2, 0,0,8,8, 1, 2), { 8, 5.5, 1,0, 8, 2})
    end)

    it('slides over tunnels', function()
      assert.same(slide(10,10,2,2, 0,0,8,8, 1, 4), { 7, 8, 0, 1, 1, 8})
      assert.same(slide(10,10,2,2, 0,0,8,8, 4, 1), { 8, 7, 1, 0, 8, 1})

      -- perfect corner case:
      assert.same(slide(10,10,2,2, 0,0,8,8, 1, 1), { 8, 8, 1, 0, 8, 1})
    end)
  end)

  describe('bounce', function()
    it('bounces on overlaps', function()
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 4, 5), { 0.5, -2, 0,-1, 4, -9})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 5, 4), { -2, 0.5, -1,0, -9, 4})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 2, 1), { 5.5, 8, 0,1, 2, 15})
      assert.same(bounce( 3, 3,2,2, 0,0,8,8, 1, 2), { 8, 5.5, 1,0, 15,2})
    end)

    it('bounces over tunnels', function()
      assert.same(bounce(10,10,2,2, 0,0,8,8, 1, 4), { 7, 8, 0, 1, 1, 12})
      assert.same(bounce(10,10,2,2, 0,0,8,8, 4, 1), { 8, 7, 1, 0, 12, 1})

      -- perfect corner case:
      assert.same(bounce(10,10,2,2, 0,0,8,8, 1, 1), { 8, 8, 1, 0, 15, 1})
    end)
  end)
end)


--- FILE: \lib\bump.lua\spec\World_spec.lua ---

local bump = require 'bump'

describe('World', function()
  local world

  before_each(function()
    world = bump.newWorld()
  end)

  local collect = function(t, field_name)
    local res = {}
    for i,v in ipairs(t) do res[i] = v[field_name] end
    return res
  end

  local sorted = function(array)
    table.sort(array)
    return array
  end

  describe(':add', function()
    it('requires something + 4 numbers', function()
      assert.error(function() world:add({}) end)
      assert.error(function() world:add({}, 40) end)
      assert.error(function() world:add() end)
    end)

    it('returns the added item', function()
      local item = {}
      assert.equals(item, world:add(item, 1,1,1,1))
    end)

    it('throws an error if the object was already added', function()
      local obj = world:add({}, 0,0,10,10)
      assert.error(function() world:add(obj, 0,0,10,10) end)
    end)

    describe('when the world is empty', function()
      it('creates as many cells as needed to hold the item', function()
        world:add({}, 0,0,10,10) -- adss one cell
        assert.equal(world:countCells(), 1)

        world:add({}, 100,100,10,10) -- adds a separate single cell
        assert.equal(world:countCells(), 2)

        world:add({}, 0,0,100,10) -- occupies 2 cells, but just adds one (the other is already added)
        assert.equal(world:countCells(), 3)

        world:add({}, 0,0,100,10) -- occupies 2 cells, but just adds one (the other is already added)
        assert.equal(world:countCells(), 3)

        world:add({}, 300,300,64,64) -- adds 8 new cells
        assert.equal(world:countCells(), 7)
      end)
    end)
  end)

  describe(':update', function()

    describe('when the object is not there', function()
      it('throws an error', function()
        assert.is_error(function() world:update({}, 0,0) end)
      end)
    end)

    it('updates the object', function()
      local a = world:add({}, 0,0,10,10)
      world:update(a, 40,40, 20,20)
      assert.same({world:getRect(a)}, {40,40,20,20})
    end)

    describe('when no width or height is given', function()
      it('takes width and height from its previous value', function()
        local a = world:add({}, 0,0,10,10)
        world:update(a, 5,5)
        assert.same({5,5,10,10}, {world:getRect(a)})
      end)
    end)

    describe('when the object stays in the same group of cells', function()
      it('does not invoke remove and add', function()
        local a = world:add({}, 0,0,10,10)

        spy.on(world, 'remove')
        spy.on(world, 'add')

        world:update(a, 1,1, 11,11)

        assert.spy(world.remove).was.called(0)
        assert.spy(world.add).was.called(0)
      end)
    end)
  end)

  describe(':project', function()
    it('throws an error if when not given a rect', function()
      assert.error(function() world:project() end)
    end)

    describe('when the world is empty', function()
      it('returns an empty list of collisions', function()
        assert.same(world:project({}, 1,2,3,4), {})
      end)
    end)

    describe('when the world is not empty', function()
      it('returns a list of collisions', function()
        world:add({'a'}, 0,0,10,10)
        world:add({'c'}, 14,16,10,10)
        assert.same(#world:project({}, 4,6,10,10), 1)
      end)

      describe('when next futureX & Y are passed', function()
        it('still handles intersections as before', function()
          world:add({'a'}, 0,0, 2,2)
          assert.same(#world:project({}, 1,1,2,2, 1, 1), 1)
        end)

        it('detects and tags tunneling correctly', function()
          world:add({'a'},  1,0, 2,1)
          assert.same(#world:project({}, -5,0,4,1, 5,0), 1)
        end)

        it('detects the case where an object was touching another without intersecting, and then penetrates', function()
          world:add({'b'}, 0,0,32,100)
          assert.same(#world:project({}, 32,50,20,20, 30,50), 1)
        end)

        it('returns a list of collisions sorted by ti', function()
          world:add({'b'}, 70,0, 10,10)
          world:add({'c'}, 50,0, 10,10)
          world:add({'d'}, 90,0, 10,10)

          local col = world:project({}, 110,0,10,10, 10,0)

          assert.same(collect(col, 'ti'), {0.1, 0.3, 0.5})
        end)
      end) -- when FutureX & Y are passed

      describe('the filter param', function()
        it('deactivates collisions when filter returns false', function()
          world:add({'b'}, 70,0, 10,10)
          world:add({'c'}, 50,0, 10,10)
          local d = world:add({'d'}, 90,0, 10,10)

          local cols = world:project({}, 110,0, 10,10, 10, 0, function(item, obj)
            return obj ~= d and "touch"
          end)

          assert.same(#cols, 2)
        end)
      end)
    end) -- when the world is not empty
  end) -- :project

  describe(':remove', function()
    it('throws an error if the item does not exist', function()
      assert.error(function() world:remove({}) end)
    end)
    it('makes the item disappear from the world', function()
      local a = world:add({'a'}, 0,0, 10,10)
      assert.same(#world:project({}, 5,0,1,1), 1)
      world:remove(a)
      assert.same(#world:project({}, 5,0,1,1), 0)
    end)
    it('marks empty cells & rows for deallocation', function()
      world:add({'a'}, 0,0, 10, 10)
      local b = world:add({'b'}, 200,200, 10,10)
      assert.same(world:countCells(), 2)
      world:remove(b)
      assert.same(world:countCells(), 2)
      collectgarbage('collect')
      assert.same(world:countCells(), 1)
    end)
  end)

  describe(':toCell', function()
    it('returns the coordinates of the cell containing a point', function()
      assert.same({world:toCell(0,0)}, {1,1})
      assert.same({world:toCell(63.9,63.9)}, {1,1})
      assert.same({world:toCell(64,64)}, {2,2})
      assert.same({world:toCell(-1,-1)}, {0,0})
    end)
  end)

  describe(':toWorld', function()
    it('returns the world left,top corner of the given cell', function()
      assert.same({world:toWorld(1,1)}, {0,0})
      assert.same({world:toWorld(2,2)}, {64,64})
      assert.same({world:toWorld(-1,1)}, {-128,0})
    end)
  end)

  describe(':queryRect', function()
    it('throws an error when given an invalid rect', function()
      assert.error(function() world:queryRect(0,0,-1,-1) end)
    end)
    it('returns nothing when the world is empty', function()
      assert.same(world:queryRect(0,0,1,1), {})
    end)
    describe('when the world has items', function()
      local a, b, c, d
      before_each(function()
        a = world:add('a', 10,0, 10,10)
        b = world:add('b', 70,0, 10,10)
        c = world:add('c', 50,0, 10,10)
        d = world:add('d', 90,0, 10,10)
      end)

      it('returns the items inside/partially inside the given rect', function()
        assert.same(sorted(world:queryRect(55, 5, 20, 20)), {b,c})
        assert.same(sorted(world:queryRect(0, 5, 100, 20)), {a,b,c,d})
      end)

      it('only returns the items for which filter returns true', function()
        local filter = function(other) return other == a or other == b or other == d end
        assert.same(sorted(world:queryRect(55, 5, 20, 20, filter)), {b})
        assert.same(sorted(world:queryRect(0, 5, 100, 20, filter)), {a,b,d})
      end)
    end)
  end)

  describe(':queryPoint', function()
    it('returns nothing when the world is empty', function()
      assert.same(world:queryPoint(0,0), {})
    end)
    describe('when the world has items', function()
      local a, b, c
      before_each(function()
        a = world:add('a', 10,0, 10,10)
        b = world:add('b', 15,0, 10,10)
        c = world:add('c', 20,0, 10,10)
      end)

      it('returns the items inside/partially inside the given rect', function()
        assert.same(sorted(world:queryPoint( 4,5)), {})
        assert.same(sorted(world:queryPoint(14,5)), {a})
        assert.same(sorted(world:queryPoint(16,5)), {a,b})
        assert.same(sorted(world:queryPoint(21,5)), {b,c})
        assert.same(sorted(world:queryPoint(26,5)), {c})
        assert.same(sorted(world:queryPoint(31,5)), {})
      end)

      it('the items are ignored when filter is present and returns false for them', function()
        local filter = function(other) return other ~= b end
        assert.same(sorted(world:queryPoint( 4,5, filter)), {})
        assert.same(sorted(world:queryPoint(14,5, filter)), {a})
        assert.same(sorted(world:queryPoint(16,5, filter)), {a})
        assert.same(sorted(world:queryPoint(21,5, filter)), {c})
        assert.same(sorted(world:queryPoint(26,5, filter)), {c})
        assert.same(sorted(world:queryPoint(31,5, filter)), {})
      end)
    end)
  end)

  describe(':querySegment', function()
    it('returns nothing when the world is empty', function()
      assert.same(world:querySegment(0,0,1,1), {})
    end)

    it('does not touch borders', function()
      world:add({'a'}, 10,0, 5,5)
      world:add({'c'}, 20,0, 5,5)

      assert.same(world:querySegment(0,5,  10,0),  {})
      assert.same(world:querySegment(15,5, 20,0),  {})
      assert.same(world:querySegment(26,5, 25,0),  {})
    end)

    describe("when the world has items", function()
      local a, b, c
      before_each(function()
        a = world:add('a',  5,0, 5,10)
        b = world:add('b', 15,0, 5,10)
        c = world:add('c', 25,0, 5,10)
      end)

      it('returns the items touched by the segment, sorted by touch order', function()
        assert.same(world:querySegment(0,5, 11,5),  {a})
        assert.same(world:querySegment(0,5, 17,5),  {a,b})
        assert.same(world:querySegment(0,5, 30,5),  {a,b,c})
        assert.same(world:querySegment(17,5, 26,5), {b,c})
        assert.same(world:querySegment(22,5, 26,5), {c})

        assert.same(world:querySegment(11,5, 0,5),  {a})
        assert.same(world:querySegment(17,5, 0,5),  {b,a})
        assert.same(world:querySegment(30,5, 0,5),  {c,b,a})
        assert.same(world:querySegment(26,5, 17,5), {c,b})
        assert.same(world:querySegment(26,5, 22,5), {c})
      end)

      it('filters out items when filter does not return true for them', function()
        local filter = function(other) return other ~= a and other ~= c end

        assert.same(world:querySegment(0,5, 11,5, filter),  {})
        assert.same(world:querySegment(0,5, 17,5, filter),  {b})
        assert.same(world:querySegment(0,5, 30,5, filter),  {b})
        assert.same(world:querySegment(17,5, 26,5, filter), {b})
        assert.same(world:querySegment(22,5, 26,5, filter), {})

        assert.same(world:querySegment(11,5, 0,5, filter),  {})
        assert.same(world:querySegment(17,5, 0,5, filter),  {b})
        assert.same(world:querySegment(30,5, 0,5, filter),  {b})
        assert.same(world:querySegment(26,5, 17,5, filter), {b})
        assert.same(world:querySegment(26,5, 22,5, filter), {})
      end)
    end)
  end)

  describe(":hasItem", function()
    it('returns wether the world has an item', function()
      local item = {}

      assert.is_false(world:hasItem(item))
      world:add(item, 0,0,1,1)
      assert.is_true(world:hasItem(item))
    end)
    it('does not throw errors with non-tables or nil', function()

      assert.is_false(world:hasItem(false))
      assert.is_false(world:hasItem(1))
      assert.is_false(world:hasItem("hello"))
      assert.is_false(world:hasItem())
    end)
  end)

  describe(":getItems", function()
    it('returns all the items in the world', function()
      local a,b = 'a','b'
      world:add(a, 1,1,1,1)
      world:add(b, 2,2,2,2)
      local items, len = world:getItems()
      table.sort(items)
      assert.same({'a', 'b'}, items)
      assert.equals(2, len)
    end)
  end)

  describe(":countItems", function()
    it('counts the items in the world', function()
      world:add({}, 1,1,1,1)
      world:add({}, 2,2,2,2)
      local count = world:countItems()
      assert.equals(2, count)
    end)
  end)

  describe(":move", function()
    describe('when there are no collisions', function()
      it('it moves the object, and returns zero collisions', function()
        local item = world:add({}, 0,0,1,1)
        assert.same({1,1,{},0}, {world:move(item, 1,1)})
      end)
    end)

    describe('when touching', function()
      it('returns a collision with the first item it touches', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,1)
        world:add('c', 0,3,1,1)
        local x,y,cols,len = world:move(a, 0,5, function() return 'touch' end)
        assert.same({x,y}, {0,1})
        assert.equals(1, len)
        assert.same(collect(cols, 'other'), {'b'})
        assert.same(collect(cols, 'type'),  {'touch'})
        assert.same({0,1,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when crossing', function()
      it('returns a collision with every item it crosses', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,1)
        world:add('c', 0,3,1,1)
        local x,y,cols,len = world:move(a, 0,5, function() return 'cross' end)
        assert.same({x,y}, {0,5})
        assert.equals(2, len)
        assert.same(collect(cols, 'other'), {'b', 'c'})
        assert.same(collect(cols, 'type'),  {'cross', 'cross'})
        assert.same({0,5,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when sliding', function()
      it('slides with every element', function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,2)
        world:add('c', 2,1,1,1)
        local x,y,cols,len = world:move(a, 5,5, function() return 'slide' end)
        assert.same({x,y}, {1,5})
        assert.equals(1, len)
        assert.same(collect(cols, 'other'), {'c'})
        assert.same(collect(cols, 'type'),  {'slide'})
        assert.same({1,5,1,1}, {world:getRect(a)})
      end)
    end)

    describe('when bouncing', function()
      it('bounces on each element',function()
        local a  = world:add('a', 0,0,1,1)
        world:add('b', 0,2,1,2)
        local x,y,cols,len = world:move(a, 0,5, function() return 'bounce' end)
        assert.same({x,y}, {0,-3})
        assert.equal(1, len)
        assert.same(collect(cols, 'other'), {'b'})
        assert.same(collect(cols, 'type'),  {'bounce'})
        assert.same({0,-3,1,1}, {world:getRect(a)})
      end)
    end)
  end)
end)


--- FILE: \lib\hump\camera.lua ---

--[[
Copyright (c) 2010-2015 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local _PATH = (...):match('^(.*[%./])[^%.%/]+$') or ''
local cos, sin = math.cos, math.sin

local camera = {}
camera.__index = camera

-- Movement interpolators (for camera locking/windowing)
camera.smooth = {}

function camera.smooth.none()
	return function(dx,dy) return dx,dy end
end

function camera.smooth.linear(speed)
	assert(type(speed) == "number", "Invalid parameter: speed = "..tostring(speed))
	return function(dx,dy, s)
		-- normalize direction
		local d = math.sqrt(dx*dx+dy*dy)
		local dts = math.min((s or speed) * love.timer.getDelta(), d) -- prevent overshooting the goal
		if d > 0 then
			dx,dy = dx/d, dy/d
		end

		return dx*dts, dy*dts
	end
end

function camera.smooth.damped(stiffness)
	assert(type(stiffness) == "number", "Invalid parameter: stiffness = "..tostring(stiffness))
	return function(dx,dy, s)
		local dts = love.timer.getDelta() * (s or stiffness)
		return dx*dts, dy*dts
	end
end


local function new(x,y, zoom, rot, smoother)
	x,y  = x or love.graphics.getWidth()/2, y or love.graphics.getHeight()/2
	zoom = zoom or 1
	rot  = rot or 0
	smoother = smoother or camera.smooth.none() -- for locking, see below
	return setmetatable({x = x, y = y, scale = zoom, rot = rot, smoother = smoother}, camera)
end

function camera:lookAt(x,y)
	self.x, self.y = x, y
	return self
end

function camera:move(dx,dy)
	self.x, self.y = self.x + dx, self.y + dy
	return self
end

function camera:position()
	return self.x, self.y
end

function camera:rotate(phi)
	self.rot = self.rot + phi
	return self
end

function camera:rotateTo(phi)
	self.rot = phi
	return self
end

function camera:zoom(mul)
	self.scale = self.scale * mul
	return self
end

function camera:zoomTo(zoom)
	self.scale = zoom
	return self
end

function camera:attach(x,y,w,h, noclip)
	x,y = x or 0, y or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	self._sx,self._sy,self._sw,self._sh = love.graphics.getScissor()
	if not noclip then
		love.graphics.setScissor(x,y,w,h)
	end

	local cx,cy = x+w/2, y+h/2
	love.graphics.push()
	love.graphics.translate(cx, cy)
	love.graphics.scale(self.scale)
	love.graphics.rotate(self.rot)
	love.graphics.translate(-self.x, -self.y)
end

function camera:detach()
	love.graphics.pop()
	love.graphics.setScissor(self._sx,self._sy,self._sw,self._sh)
end

function camera:draw(...)
	local x,y,w,h,noclip,func
	local nargs = select("#", ...)
	if nargs == 1 then
		func = ...
	elseif nargs == 5 then
		x,y,w,h,func = ...
	elseif nargs == 6 then
		x,y,w,h,noclip,func = ...
	else
		error("Invalid arguments to camera:draw()")
	end

	self:attach(x,y,w,h,noclip)
	func()
	self:detach()
end

-- world coordinates to camera coordinates
function camera:cameraCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = ((x,y) - (self.x, self.y)):rotated(self.rot) * self.scale + center
	local c,s = cos(self.rot), sin(self.rot)
	x,y = x - self.x, y - self.y
	x,y = c*x - s*y, s*x + c*y
	return x*self.scale + w/2 + ox, y*self.scale + h/2 + oy
end

-- camera coordinates to world coordinates
function camera:worldCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = (((x,y) - center) / self.scale):rotated(-self.rot) + (self.x,self.y)
	local c,s = cos(-self.rot), sin(-self.rot)
	x,y = (x - w/2 - ox) / self.scale, (y - h/2 - oy) / self.scale
	x,y = c*x - s*y, s*x + c*y
	return x+self.x, y+self.y
end

function camera:mousePosition(ox,oy,w,h)
	local mx,my = love.mouse.getPosition()
	return self:worldCoords(mx,my, ox,oy,w,h)
end

-- camera scrolling utilities
function camera:lockX(x, smoother, ...)
	local dx, dy = (smoother or self.smoother)(x - self.x, self.y, ...)
	self.x = self.x + dx
	return self
end

function camera:lockY(y, smoother, ...)
	local dx, dy = (smoother or self.smoother)(self.x, y - self.y, ...)
	self.y = self.y + dy
	return self
end

function camera:lockPosition(x,y, smoother, ...)
	return self:move((smoother or self.smoother)(x - self.x, y - self.y, ...))
end

function camera:lockWindow(x, y, x_min, x_max, y_min, y_max, smoother, ...)
	-- figure out displacement in camera coordinates
	x,y = self:cameraCoords(x,y)
	local dx, dy = 0,0
	if x < x_min then
		dx = x - x_min
	elseif x > x_max then
		dx = x - x_max
	end
	if y < y_min then
		dy = y - y_min
	elseif y > y_max then
		dy = y - y_max
	end

	-- transform displacement to movement in world coordinates
	local c,s = cos(-self.rot), sin(-self.rot)
	dx,dy = (c*dx - s*dy) / self.scale, (s*dx + c*dy) / self.scale

	-- move
	self:move((smoother or self.smoother)(dx,dy,...))
end

-- the module
return setmetatable({new = new, smooth = camera.smooth},
	{__call = function(_, ...) return new(...) end})


--- FILE: \lib\hump\class.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function include_helper(to, from, seen)
	if from == nil then
		return to
	elseif type(from) ~= 'table' then
		return from
	elseif seen[from] then
		return seen[from]
	end

	seen[from] = to
	for k,v in pairs(from) do
		k = include_helper({}, k, seen) -- keys might also be tables
		if to[k] == nil then
			to[k] = include_helper({}, v, seen)
		end
	end
	return to
end

-- deeply copies `other' into `class'. keys in `other' that are already
-- defined in `class' are omitted
local function include(class, other)
	return include_helper(class, other, {})
end

-- returns a deep copy of `other'
local function clone(other)
	return setmetatable(include({}, other), getmetatable(other))
end

local function new(class)
	-- mixins
	class = class or {}  -- class can be nil
	local inc = class.__includes or {}
	if getmetatable(inc) then inc = {inc} end

	for _, other in ipairs(inc) do
		if type(other) == "string" then
			other = _G[other]
		end
		include(class, other)
	end

	-- class implementation
	class.__index = class
	class.init    = class.init    or class[1] or function() end
	class.include = class.include or include
	class.clone   = class.clone   or clone

	-- constructor call
	return setmetatable(class, {__call = function(c, ...)
		local o = setmetatable({}, c)
		o:init(...)
		return o
	end})
end

-- interface for cross class-system compatibility (see https://github.com/bartbes/Class-Commons).
if class_commons ~= false and not common then
	common = {}
	function common.class(name, prototype, parent)
		return new{__includes = {prototype, parent}}
	end
	function common.instance(class, ...)
		return class(...)
	end
end


-- the module
return setmetatable({new = new, include = include, clone = clone},
	{__call = function(_,...) return new(...) end})


--- FILE: \lib\hump\gamestate.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function __NULL__() end

 -- default gamestate produces error on every callback
local state_init = setmetatable({leave = __NULL__},
		{__index = function() error("Gamestate not initialized. Use Gamestate.switch()") end})
local stack = {state_init}
local initialized_states = setmetatable({}, {__mode = "k"})
local state_is_dirty = true

local GS = {}
function GS.new(t) return t or {} end -- constructor - deprecated!

local function change_state(stack_offset, to, ...)
	local pre = stack[#stack]

	-- initialize only on first call
	;(initialized_states[to] or to.init or __NULL__)(to)
	initialized_states[to] = __NULL__

	stack[#stack+stack_offset] = to
	state_is_dirty = true
	return (to.enter or __NULL__)(to, pre, ...)
end

function GS.switch(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call switch with colon operator")
	;(stack[#stack].leave or __NULL__)(stack[#stack])
	return change_state(0, to, ...)
end

function GS.push(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call push with colon operator")
	return change_state(1, to, ...)
end

function GS.pop(...)
	assert(#stack > 1, "No more states to pop!")
	local pre, to = stack[#stack], stack[#stack-1]
	stack[#stack] = nil
	;(pre.leave or __NULL__)(pre)
	state_is_dirty = true
	return (to.resume or __NULL__)(to, pre, ...)
end

function GS.current()
	return stack[#stack]
end

-- XXX: don't overwrite love.errorhandler by default:
--      this callback is different than the other callbacks
--      (see http://love2d.org/wiki/love.errorhandler)
--      overwriting thi callback can result in random crashes (issue #95)
local all_callbacks = { 'draw', 'update' }

-- fetch event callbacks from love.handlers
for k in pairs(love.handlers) do
	all_callbacks[#all_callbacks+1] = k
end

function GS.registerEvents(callbacks)
	local registry = {}
	callbacks = callbacks or all_callbacks
	for _, f in ipairs(callbacks) do
		registry[f] = love[f] or __NULL__
		love[f] = function(...)
			registry[f](...)
			return GS[f](...)
		end
	end
end

-- forward any undefined functions
setmetatable(GS, {__index = function(_, func)
	-- call function only if at least one 'update' was called beforehand
	-- (see issue #46)
	if not state_is_dirty or func == 'update' then
		state_is_dirty = false
		return function(...)
			return (stack[#stack][func] or __NULL__)(stack[#stack], ...)
		end
	end
	return __NULL__
end})

return GS


--- FILE: \lib\hump\signal.lua ---

--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Registry = {}
Registry.__index = function(self, key)
	return Registry[key] or (function()
		local t = {}
		rawset(self, key, t)
		return t
	end)()
end

function Registry:register(s, f)
	self[s][f] = f
	return f
end

function Registry:emit(s, ...)
	for f in pairs(self[s]) do
		f(...)
	end
end

function Registry:remove(s, ...)
	local f = {...}
	for i = 1,select('#', ...) do
		self[s][f[i]] = nil
	end
end

function Registry:clear(...)
	local s = {...}
	for i = 1,select('#', ...) do
		self[s[i]] = {}
	end
end

function Registry:emitPattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:emit(s, ...) end
	end
end

function Registry:registerPattern(p, f)
	for s in pairs(self) do
		if s:match(p) then self:register(s, f) end
	end
	return f
end

function Registry:removePattern(p, ...)
	for s in pairs(self) do
		if s:match(p) then self:remove(s, ...) end
	end
end

function Registry:clearPattern(p)
	for s in pairs(self) do
		if s:match(p) then self[s] = {} end
	end
end

-- instancing
function Registry.new()
	return setmetatable({}, Registry)
end

-- default instance
local default = Registry.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Registry) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end

return setmetatable(module, {__call = Registry.new})


--- FILE: \lib\hump\timer.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local Timer = {}
Timer.__index = Timer

local function _nothing_() end

local function updateTimerHandle(handle, dt)
		-- handle: {
		--   time = <number>,
		--   after = <function>,
		--   during = <function>,
		--   limit = <number>,
		--   count = <number>,
		-- }
		handle.time = handle.time + dt
		handle.during(dt, math.max(handle.limit - handle.time, 0))

		while handle.time >= handle.limit and handle.count > 0 do
			if handle.after(handle.after) == false then
				handle.count = 0
				break
			end
			handle.time = handle.time - handle.limit
			handle.count = handle.count - 1
		end
end

function Timer:update(dt)
	-- timers may create new timers, which leads to undefined behavior
	-- in pairs() - so we need to put them in a different table first
	local to_update = {}
	for handle in pairs(self.functions) do
		to_update[handle] = handle
	end

	for handle in pairs(to_update) do
		if self.functions[handle] then
			updateTimerHandle(handle, dt)
			if handle.count == 0 then
				self.functions[handle] = nil
			end
		end
	end
end

function Timer:during(delay, during, after)
	local handle = { time = 0, during = during, after = after or _nothing_, limit = delay, count = 1 }
	self.functions[handle] = true
	return handle
end

function Timer:after(delay, func)
	return self:during(delay, _nothing_, func)
end

function Timer:every(delay, after, count)
	local count = count or math.huge -- exploit below: math.huge - 1 = math.huge
	local handle = { time = 0, during = _nothing_, after = after, limit = delay, count = count }
	self.functions[handle] = true
	return handle
end

function Timer:cancel(handle)
	self.functions[handle] = nil
end

function Timer:clear()
	self.functions = {}
end

function Timer:script(f)
	local co = coroutine.wrap(f)
	co(function(t)
		self:after(t, co)
		coroutine.yield()
	end)
end

Timer.tween = setmetatable({
	-- helper functions
	out = function(f) -- 'rotates' a function
		return function(s, ...) return 1 - f(1-s, ...) end
	end,
	chain = function(f1, f2) -- concatenates two functions
		return function(s, ...) return (s < .5 and f1(2*s, ...) or 1 + f2(2*s-1, ...)) * .5 end
	end,

	-- useful tweening functions
	linear = function(s) return s end,
	quad   = function(s) return s*s end,
	cubic  = function(s) return s*s*s end,
	quart  = function(s) return s*s*s*s end,
	quint  = function(s) return s*s*s*s*s end,
	sine   = function(s) return 1-math.cos(s*math.pi/2) end,
	expo   = function(s) return 2^(10*(s-1)) end,
	circ   = function(s) return 1 - math.sqrt(1-s*s) end,

	back = function(s,bounciness)
		bounciness = bounciness or 1.70158
		return s*s*((bounciness+1)*s - bounciness)
	end,

	bounce = function(s) -- magic numbers ahead
		local a,b = 7.5625, 1/2.75
		return math.min(a*s^2, a*(s-1.5*b)^2 + .75, a*(s-2.25*b)^2 + .9375, a*(s-2.625*b)^2 + .984375)
	end,

	elastic = function(s, amp, period)
		amp, period = amp and math.max(1, amp) or 1, period or .3
		return (-amp * math.sin(2*math.pi/period * (s-1) - math.asin(1/amp))) * 2^(10*(s-1))
	end,
}, {

-- register new tween
__call = function(tween, self, len, subject, target, method, after, ...)
	-- recursively collects fields that are defined in both subject and target into a flat list
	local function tween_collect_payload(subject, target, out)
		for k,v in pairs(target) do
			local ref = subject[k]
			assert(type(v) == type(ref), 'Type mismatch in field "'..k..'".')
			if type(v) == 'table' then
				tween_collect_payload(ref, v, out)
			else
				local ok, delta = pcall(function() return (v-ref)*1 end)
				assert(ok, 'Field "'..k..'" does not support arithmetic operations')
				out[#out+1] = {subject, k, delta}
			end
		end
		return out
	end

	method = tween[method or 'linear'] -- see __index
	local payload, t, args = tween_collect_payload(subject, target, {}), 0, {...}

	local last_s = 0
	return self:during(len, function(dt)
		t = t + dt
		local s = method(math.min(1, t/len), unpack(args))
		local ds = s - last_s
		last_s = s
		for _, info in ipairs(payload) do
			local ref, key, delta = unpack(info)
			ref[key] = ref[key] + delta * ds
		end
	end, after)
end,

-- fetches function and generated compositions for method `key`
__index = function(tweens, key)
	if type(key) == 'function' then return key end

	assert(type(key) == 'string', 'Method must be function or string.')
	if rawget(tweens, key) then return rawget(tweens, key) end

	local function construct(pattern, f)
		local method = rawget(tweens, key:match(pattern))
		if method then return f(method) end
		return nil
	end

	local out, chain = rawget(tweens,'out'), rawget(tweens,'chain')
	return construct('^in%-([^-]+)$', function(...) return ... end)
	       or construct('^out%-([^-]+)$', out)
	       or construct('^in%-out%-([^-]+)$', function(f) return chain(f, out(f)) end)
	       or construct('^out%-in%-([^-]+)$', function(f) return chain(out(f), f) end)
	       or error('Unknown interpolation method: ' .. key)
end})

-- Timer instancing
function Timer.new()
	return setmetatable({functions = {}, tween = Timer.tween}, Timer)
end

-- default instance
local default = Timer.new()

-- module forwards calls to default instance
local module = {}
for k in pairs(Timer) do
	if k ~= "__index" then
		module[k] = function(...) return default[k](default, ...) end
	end
end
module.tween = setmetatable({}, {
	__index = Timer.tween,
	__newindex = function(k,v) Timer.tween[k] = v end,
	__call = function(t, ...) return default:tween(...) end,
})

return setmetatable(module, {__call = Timer.new})


--- FILE: \lib\hump\vector-light.lua ---

--[[
Copyright (c) 2012-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local function str(x,y)
	return "("..tonumber(x)..","..tonumber(y)..")"
end

local function mul(s, x,y)
	return s*x, s*y
end

local function div(s, x,y)
	return x/s, y/s
end

local function add(x1,y1, x2,y2)
	return x1+x2, y1+y2
end

local function sub(x1,y1, x2,y2)
	return x1-x2, y1-y2
end

local function permul(x1,y1, x2,y2)
	return x1*x2, y1*y2
end

local function dot(x1,y1, x2,y2)
	return x1*x2 + y1*y2
end

local function det(x1,y1, x2,y2)
	return x1*y2 - y1*x2
end

local function eq(x1,y1, x2,y2)
	return x1 == x2 and y1 == y2
end

local function lt(x1,y1, x2,y2)
	return x1 < x2 or (x1 == x2 and y1 < y2)
end

local function le(x1,y1, x2,y2)
	return x1 <= x2 and y1 <= y2
end

local function len2(x,y)
	return x*x + y*y
end

local function len(x,y)
	return sqrt(x*x + y*y)
end

local function fromPolar(angle, radius)
	radius = radius or 1
	return cos(angle)*radius, sin(angle)*radius
end

local function randomDirection(len_min, len_max)
	len_min = len_min or 1
	len_max = len_max or len_min

	assert(len_max > 0, "len_max must be greater than zero")
	assert(len_max >= len_min, "len_max must be greater than or equal to len_min")

	return fromPolar(math.random()*2*math.pi,
	                 math.random() * (len_max-len_min) + len_min)
end

local function toPolar(x, y)
	return atan2(y,x), len(x,y)
end

local function dist2(x1,y1, x2,y2)
	return len2(x1-x2, y1-y2)
end

local function dist(x1,y1, x2,y2)
	return len(x1-x2, y1-y2)
end

local function normalize(x,y)
	local l = len(x,y)
	if l > 0 then
		return x/l, y/l
	end
	return x,y
end

local function rotate(phi, x,y)
	local c, s = cos(phi), sin(phi)
	return c*x - s*y, s*x + c*y
end

local function perpendicular(x,y)
	return -y, x
end

local function project(x,y, u,v)
	local s = (x*u + y*v) / (u*u + v*v)
	return s*u, s*v
end

local function mirror(x,y, u,v)
	local s = 2 * (x*u + y*v) / (u*u + v*v)
	return s*u - x, s*v - y
end

-- ref.: http://blog.signalsondisplay.com/?p=336
local function trim(maxLen, x, y)
	local s = maxLen * maxLen / len2(x, y)
	s = s > 1 and 1 or math.sqrt(s)
	return x * s, y * s
end

local function angleTo(x,y, u,v)
	if u and v then
		return atan2(y, x) - atan2(v, u)
	end
	return atan2(y, x)
end

-- the module
return {
	str = str,

	fromPolar       = fromPolar,
	toPolar         = toPolar,
	randomDirection = randomDirection,

	-- arithmetic
	mul    = mul,
	div    = div,
	idiv   = idiv,
	add    = add,
	sub    = sub,
	permul = permul,
	dot    = dot,
	det    = det,
	cross  = det,

	-- relation
	eq = eq,
	lt = lt,
	le = le,

	-- misc operations
	len2          = len2,
	len           = len,
	dist2         = dist2,
	dist          = dist,
	normalize     = normalize,
	rotate        = rotate,
	perpendicular = perpendicular,
	project       = project,
	mirror        = mirror,
	trim          = trim,
	angleTo       = angleTo,
}


--- FILE: \lib\hump\vector.lua ---

--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local assert = assert
local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local vector = {}
vector.__index = vector

local function new(x,y)
	return setmetatable({x = x or 0, y = y or 0}, vector)
end
local zero = new(0,0)

local function fromPolar(angle, radius)
	radius = radius or 1
	return new(cos(angle) * radius, sin(angle) * radius)
end

local function randomDirection(len_min, len_max)
	len_min = len_min or 1
	len_max = len_max or len_min

	assert(len_max > 0, "len_max must be greater than zero")
	assert(len_max >= len_min, "len_max must be greater than or equal to len_min")
	
	return fromPolar(math.random() * 2*math.pi,
	                 math.random() * (len_max-len_min) + len_min)
end

local function isvector(v)
	return type(v) == 'table' and type(v.x) == 'number' and type(v.y) == 'number'
end

function vector:clone()
	return new(self.x, self.y)
end

function vector:unpack()
	return self.x, self.y
end

function vector:__tostring()
	return "("..tonumber(self.x)..","..tonumber(self.y)..")"
end

function vector.__unm(a)
	return new(-a.x, -a.y)
end

function vector.__add(a,b)
	assert(isvector(a) and isvector(b), "Add: wrong argument types (<vector> expected)")
	return new(a.x+b.x, a.y+b.y)
end

function vector.__sub(a,b)
	assert(isvector(a) and isvector(b), "Sub: wrong argument types (<vector> expected)")
	return new(a.x-b.x, a.y-b.y)
end

function vector.__mul(a,b)
	if type(a) == "number" then
		return new(a*b.x, a*b.y)
	elseif type(b) == "number" then
		return new(b*a.x, b*a.y)
	else
		assert(isvector(a) and isvector(b), "Mul: wrong argument types (<vector> or <number> expected)")
		return a.x*b.x + a.y*b.y
	end
end

function vector.__div(a,b)
	assert(isvector(a) and type(b) == "number", "wrong argument types (expected <vector> / <number>)")
	return new(a.x / b, a.y / b)
end

function vector.__eq(a,b)
	return a.x == b.x and a.y == b.y
end

function vector.__lt(a,b)
	return a.x < b.x or (a.x == b.x and a.y < b.y)
end

function vector.__le(a,b)
	return a.x <= b.x and a.y <= b.y
end

function vector.permul(a,b)
	assert(isvector(a) and isvector(b), "permul: wrong argument types (<vector> expected)")
	return new(a.x*b.x, a.y*b.y)
end

function vector:toPolar()
	return new(atan2(self.x, self.y), self:len())
end

function vector:len2()
	return self.x * self.x + self.y * self.y
end

function vector:len()
	return sqrt(self.x * self.x + self.y * self.y)
end

function vector.dist(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return sqrt(dx * dx + dy * dy)
end

function vector.dist2(a, b)
	assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
	local dx = a.x - b.x
	local dy = a.y - b.y
	return (dx * dx + dy * dy)
end

function vector:normalizeInplace()
	local l = self:len()
	if l > 0 then
		self.x, self.y = self.x / l, self.y / l
	end
	return self
end

function vector:normalized()
	return self:clone():normalizeInplace()
end

function vector:rotateInplace(phi)
	local c, s = cos(phi), sin(phi)
	self.x, self.y = c * self.x - s * self.y, s * self.x + c * self.y
	return self
end

function vector:rotated(phi)
	local c, s = cos(phi), sin(phi)
	return new(c * self.x - s * self.y, s * self.x + c * self.y)
end

function vector:perpendicular()
	return new(-self.y, self.x)
end

function vector:projectOn(v)
	assert(isvector(v), "invalid argument: cannot project vector on " .. type(v))
	-- (self * v) * v / v:len2()
	local s = (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x, s * v.y)
end

function vector:mirrorOn(v)
	assert(isvector(v), "invalid argument: cannot mirror vector on " .. type(v))
	-- 2 * self:projectOn(v) - self
	local s = 2 * (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
	return new(s * v.x - self.x, s * v.y - self.y)
end

function vector:cross(v)
	assert(isvector(v), "cross: wrong argument types (<vector> expected)")
	return self.x * v.y - self.y * v.x
end

-- ref.: http://blog.signalsondisplay.com/?p=336
function vector:trimInplace(maxLen)
	local s = maxLen * maxLen / self:len2()
	s = (s > 1 and 1) or math.sqrt(s)
	self.x, self.y = self.x * s, self.y * s
	return self
end

function vector:angleTo(other)
	if other then
		return atan2(self.y, self.x) - atan2(other.y, other.x)
	end
	return atan2(self.y, self.x)
end

function vector:trimmed(maxLen)
	return self:clone():trimInplace(maxLen)
end


-- the module
return setmetatable({
	new             = new,
	fromPolar       = fromPolar,
	randomDirection = randomDirection,
	isvector        = isvector,
	zero            = zero
}, {
	__call = function(_, ...) return new(...) end
})


--- FILE: \lib\hump\spec\timer_spec.lua ---

local timer = require 'timer'()

describe('hump.timer', function()
  it('runs a function during a specified time', function()
    local delta, remaining

    timer:during(10, function(...) delta, remaining = ... end)

    timer:update(2)
    assert.are.equal(delta, 2)
    assert.are.equal(8, remaining)

    timer:update(5)
    assert.are.equal(delta, 5)
    assert.are.equal(3, remaining)

    timer:update(10)
    assert.are.equal(delta, 10)
    assert.are.equal(0, remaining)
  end)

  it('runs a function after a specified time', function()
    local finished1 = false
    local finished2 = false

    timer:after(3, function(...) finished1 = true end)
    timer:after(5, function(...) finished2 = true end)

    timer:update(4)
    assert.are.equal(true, finished1)
    assert.are.equal(false, finished2)

    timer:update(4)
    assert.are.equal(true, finished1)
    assert.are.equal(true, finished2)
  end)

  it('runs a function every so often', function()
    local count = 0

    timer:every(1, function(...) count = count + 1 end)

    timer:update(3)
    assert.are.equal(3, count)

    timer:update(7)
    assert.are.equal(10, count)
  end)

  it('can script timed events', function()
    local state

    timer:script(function(wait)
      state = 'foo'
      wait(1)
      state = 'bar'
    end)

    assert.are.equal('foo', state)
    timer:update(0.5)
    assert.are.equal('foo', state)
    timer:update(1)
    assert.are.equal('bar', state)
  end)

  it('cancels and clears timer functions', function()
    pending('to be tested...')
  end)

  it('tweens', function()
    pending('to be tested...')
  end)
end)


--- FILE: \lib\Jumper\examples\annotatedPathing.lua ---

-- Tests sample for clearance metrics calculation
-- See Figure 10 at http://aigamedev.com/open/tutorial/clearance-based-pathfinding/
-- Jump Point Search still has some flaws with clearance based pathfinding

local Grid = require 'jumper.grid'
local PF = require 'jumper.pathfinder'
local map = {
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,1,0,0,0,0,0,0},
	{0,0,1,0,0,0,0,0,2,0},
	{0,0,1,1,1,0,0,2,0,0},
	{0,0,0,1,1,0,2,0,0,2},
	{0,0,0,0,1,0,0,0,0,2},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0}
}
local grid = Grid(map)
local walkable = function(v) return v~=2 end
local finder = PF(grid, 'ASTAR',walkable)
finder:annotateGrid()
local finderNames = PF:getFinders()

local sx, sy = 1,1
local ex, ey = 9,9
local agent_size = 2

for i = 1,#finderNames do
	finder:setFinder(finderNames[i])
	local path = finder:getPath(sx, sy, ex, ey, agent_size)
	print(('Algorithm used: %s - Path %s')
		:format(finder:getFinder(), path and 'found' or 'not found'))
	if path then
		for node, count in path:nodes() do
			print(('  Step %d. (%d,%d)')
				:format(count, node:getPos()))
		end
	end
end



--- FILE: \lib\Jumper\examples\customHeuristics.lua ---

--- Example of use for Heuristics

local Grid = require ("jumper.grid")
local Pathfinder = require ("jumper.pathfinder")

local map = {
  {0,0,0,0,0,0},
  {0,0,0,0,0,0},
  {0,1,1,1,1,0},
  {0,0,0,0,0,0},
  {0,0,0,0,0,0},
}

local walkable = 0
local grid = Grid(map)
local myFinder = Pathfinder(grid, 'ASTAR', walkable)

-- Use Euclidian heuristic to evaluate distance
myFinder:setHeuristic('EUCLIDIAN')
myFinder:setHeuristic('DIAGONAL')
myFinder:setHeuristic('MANHATTAN')

-- Custom
local h = function(nodeA, nodeB)
	return (0.1 * (math.abs(nodeA:getX() - nodeB:getX()))
	      + 0.9 * (math.abs(nodeA:getY() - nodeB:getY())))
end
myFinder:setHeuristic(h)

local p = myFinder:getPath(1,1, 6,5)
for node, count in p:nodes() do
  print(('%d. Node(%d,%d)'):format(count, node:getX(), node:getY()))
end
print(('Path length: %.2f'):format(p:getLength()))

-- etc ...


--- FILE: \lib\Jumper\examples\makeClearance.lua ---

-- Tests sample for clearance metrics calculation
-- See Figure 10 at http://aigamedev.com/open/tutorial/clearance-based-pathfinding/
local Grid = require 'jumper.grid'
local PF = require 'jumper.pathfinder'
local map = {
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,1,0,0,0,0,0,0},
	{0,0,1,0,0,0,0,0,2,0},
	{0,0,1,1,1,0,0,2,0,0},
	{0,0,0,1,1,0,2,0,0,2},
	{0,0,0,0,1,0,0,0,0,2},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0}
}
local grid = Grid(map)
local walkable = function(v) return v~=2 end
local finder = PF(grid, 'ASTAR',walkable)
finder:annotateGrid()

for y = 1, #map do
	local s = ''
	for x = 1, #map[y] do
	  local node = grid:getNodeAt(x,y)
		s = (s .. ' ' .. node:getClearance(walkable))
	end
	print(s)
end

-- Expected output
--  6 6 5 5 4 4 4 3 2 1
--  6 5 5 4 4 3 3 3 2 1
--  6 5 4 4 3 3 2 2 2 1
--  6 5 4 3 3 2 2 1 1 1
--  6 5 4 3 2 2 1 1 0 1
--  5 5 4 3 2 1 1 0 1 1
--  4 4 4 3 2 1 0 2 1 0
--  3 3 3 3 3 3 3 2 1 0
--  2 2 2 2 2 2 2 2 2 1
--  1 1 1 1 1 1 1 1 1 1



--- FILE: \lib\Jumper\examples\simpleExample.lua ---

--- Very minimal usage example for Jumper

-- Set up a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
-- Calls the grid class
local Grid = require ("jumper.grid")
-- Calls the pathfinder class
local Pathfinder = require ("jumper.pathfinder")

-- Creates a grid object
local grid = Grid(map)

-- Creates a pathfinder object using Jump Point Search algorithm
local myFinder = Pathfinder(grid, 'JPS', walkable)

-- Define start and goal locations coordinates
local startx, starty = 1,1
local endx, endy = 5,1

-- Calculates the path, and its length
local path = myFinder:getPath(startx, starty, endx, endy)

-- Pretty-printing the results
if path then
  print(('Path found! Length: %.2f'):format(path:getLength()))
	for node, count in path:nodes() do
	  print(('Step: %d - x: %d - y: %d'):format(count, node:getX(), node:getY()))
	end
end


--- FILE: \lib\Jumper\jumper\grid.lua ---

--- The Grid class.
-- Implementation of the `grid` class.
-- The `grid` is a implicit graph which represents the 2D
-- world map layout on which the `pathfinder` object will run.
-- During a search, the `pathfinder` object needs to save some critical values. These values are cached within each `node`
-- object, and the whole set of nodes are tight inside the `grid` object itself.

if (...) then

	-- Dependencies
  local _PATH = (...):gsub('%.grid$','')

	-- Local references
  local Utils = require (_PATH .. '.core.utils')
  local Assert = require (_PATH .. '.core.assert')
  local Node = require (_PATH .. '.core.node')

	-- Local references
  local pairs = pairs
  local assert = assert
  local next = next
	local setmetatable = setmetatable
  local floor = math.floor
	local coroutine = coroutine

  -- Offsets for straights moves
  local straightOffsets = {
    {x = 1, y = 0} --[[W]], {x = -1, y =  0}, --[[E]]
    {x = 0, y = 1} --[[S]], {x =  0, y = -1}, --[[N]]
  }

  -- Offsets for diagonal moves
  local diagonalOffsets = {
    {x = -1, y = -1} --[[NW]], {x = 1, y = -1}, --[[NE]]
    {x = -1, y =  1} --[[SW]], {x = 1, y =  1}, --[[SE]]
  }

	--- The `Grid` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Grid(...)</code> _acts as a shortcut to_ <code>Grid:new(...)</code>.
	-- @type Grid
  local Grid = {}
  Grid.__index = Grid

  -- Specialized grids
  local PreProcessGrid = setmetatable({},Grid)
  local PostProcessGrid = setmetatable({},Grid)
  PreProcessGrid.__index = PreProcessGrid
  PostProcessGrid.__index = PostProcessGrid
  PreProcessGrid.__call = function (self,x,y)
    return self:getNodeAt(x,y)
  end
  PostProcessGrid.__call = function (self,x,y,create)
    if create then return self:getNodeAt(x,y) end
    return self._nodes[y] and self._nodes[y][x]
  end

  --- Inits a new `grid`
  -- @class function
  -- @tparam table|string map A collision map - (2D array) with consecutive indices (starting at 0 or 1)
	-- or a `string` with line-break chars (<code>\n</code> or <code>\r</code>) as row delimiters.
  -- @tparam[opt] bool cacheNodeAtRuntime When __true__, returns an empty `grid` instance, so that
	-- later on, indexing a non-cached `node` will cause it to be created and cache within the `grid` on purpose (i.e, when needed).
	-- This is a __memory-safe__ option, in case your dealing with some tight memory constraints.
	-- Defaults to __false__ when omitted.
  -- @treturn grid a new `grid` instance
	-- @usage
	-- -- A simple 3x3 grid
	-- local myGrid = Grid:new({{0,0,0},{0,0,0},{0,0,0}})
	--
	-- -- A memory-safe 3x3 grid
	-- myGrid = Grid('000\n000\n000', true)
  function Grid:new(map, cacheNodeAtRuntime)
		if type(map) == 'string' then
			assert(Assert.isStrMap(map), 'Wrong argument #1. Not a valid string map')
			map = Utils.strToMap(map)
		end
    assert(Assert.isMap(map),('Bad argument #1. Not a valid map'))
    assert(Assert.isBool(cacheNodeAtRuntime) or Assert.isNil(cacheNodeAtRuntime),
      ('Bad argument #2. Expected \'boolean\', got %s.'):format(type(cacheNodeAtRuntime)))
    if cacheNodeAtRuntime then
      return PostProcessGrid:new(map,walkable)
    end
    return PreProcessGrid:new(map,walkable)
  end

  --- Checks if `node` at [x,y] is __walkable__.
	-- Will check if `node` at location [x,y] both *exists* on the collision map and *is walkable*
  -- @class function
  -- @tparam int x the x-location of the node
  -- @tparam int y the y-location of the node
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- If this parameter is a function, it should be prototyped as __f(value)__ and return a `boolean`:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise. If this parameter is not given
  -- while location [x,y] __is valid__, this actual function returns __true__.
  -- @tparam[optchain] int clearance the amount of clearance needed. Defaults to 1 (normal clearance) when not given.
  -- @treturn bool __true__ if `node` exists and is __walkable__, __false__ otherwise
	-- @usage
	-- -- Always true
	-- print(myGrid:isWalkableAt(2,3))
	--
	-- -- True if node at [2,3] collision map value is 0
	-- print(myGrid:isWalkableAt(2,3,0))
	--
	-- -- True if node at [2,3] collision map value is 0 and has a clearance higher or equal to 2
	-- print(myGrid:isWalkableAt(2,3,0,2))
	--
  function Grid:isWalkableAt(x, y, walkable, clearance)
    local nodeValue = self._map[y] and self._map[y][x]
    if nodeValue then
      if not walkable then return true end
    else
			return false
    end
		local hasEnoughClearance = not clearance and true or false
		if not hasEnoughClearance then
			if not self._isAnnotated[walkable] then return false end
			local node = self:getNodeAt(x,y)
			local nodeClearance = node:getClearance(walkable)
			hasEnoughClearance = (nodeClearance >= clearance)
		end
    if self._eval then
			return walkable(nodeValue) and hasEnoughClearance
		end
    return ((nodeValue == walkable) and hasEnoughClearance)
  end

  --- Returns the `grid` width.
  -- @class function
  -- @treturn int the `grid` width
	-- @usage print(myGrid:getWidth())
  function Grid:getWidth()
    return self._width
  end

  --- Returns the `grid` height.
  -- @class function
  -- @treturn int the `grid` height
	-- @usage print(myGrid:getHeight())
  function Grid:getHeight()
     return self._height
  end

  --- Returns the collision map.
  -- @class function
  -- @treturn map the collision map (see @{Grid:new})
	-- @usage local map = myGrid:getMap()
  function Grid:getMap()
    return self._map
  end

  --- Returns the set of nodes.
  -- @class function
  -- @treturn {{node,...},...} an array of nodes
	-- @usage local nodes = myGrid:getNodes()
  function Grid:getNodes()
    return self._nodes
  end

  --- Returns the `grid` bounds. Returned values corresponds to the upper-left
	-- and lower-right coordinates (in tile units) of the actual `grid` instance.
  -- @class function
  -- @treturn int the upper-left corner x-coordinate
  -- @treturn int the upper-left corner y-coordinate
  -- @treturn int the lower-right corner x-coordinate
  -- @treturn int the lower-right corner y-coordinate
	-- @usage local left_x, left_y, right_x, right_y = myGrid:getBounds()
	function Grid:getBounds()
		return self._min_x, self._min_y,self._max_x, self._max_y
	end

  --- Returns neighbours. The returned value is an array of __walkable__ nodes neighbouring a given `node`.
  -- @class function
  -- @tparam node node a given `node`
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool allowDiagonal when __true__, allows adjacent nodes are included (8-neighbours).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool tunnel When __true__, allows the `pathfinder` to tunnel through walls when heading diagonally.
  -- @tparam[optchain] int clearance When given, will prune for the neighbours set all nodes having a clearance value lower than the passed-in value
	-- Defaults to __false__ when omitted.
  -- @treturn {node,...} an array of nodes neighbouring a given node
	-- @usage
	-- local aNode = myGrid:getNodeAt(5,6)
	-- local neighbours = myGrid:getNeighbours(aNode, 0, true)
  function Grid:getNeighbours(node, walkable, allowDiagonal, tunnel, clearance)
		local neighbours = {}
    for i = 1,#straightOffsets do
      local n = self:getNodeAt(
        node._x + straightOffsets[i].x,
        node._y + straightOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
        neighbours[#neighbours+1] = n
      end
    end

    if not allowDiagonal then return neighbours end

		tunnel = not not tunnel
    for i = 1,#diagonalOffsets do
      local n = self:getNodeAt(
        node._x + diagonalOffsets[i].x,
        node._y + diagonalOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
				if tunnel then
					neighbours[#neighbours+1] = n
				else
					local skipThisNode = false
					local n1 = self:getNodeAt(node._x+diagonalOffsets[i].x, node._y)
					local n2 = self:getNodeAt(node._x, node._y+diagonalOffsets[i].y)
					if ((n1 and n2) and not self:isWalkableAt(n1._x, n1._y, walkable, clearance) and not self:isWalkableAt(n2._x, n2._y, walkable, clearance)) then
						skipThisNode = true
					end
					if not skipThisNode then neighbours[#neighbours+1] = n end
				end
      end
    end

    return neighbours
  end

  --- Grid iterator. Iterates on every single node
  -- in the `grid`. Passing __lx, ly, ex, ey__ arguments will iterate
  -- only on nodes inside the bounding-rectangle delimited by those given coordinates.
  -- @class function
  -- @tparam[opt] int lx the leftmost x-coordinate of the rectangle. Default to the `grid` leftmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ly the topmost y-coordinate of the rectangle. Default to the `grid` topmost y-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ex the rightmost x-coordinate of the rectangle. Default to the `grid` rightmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ey the bottom-most y-coordinate of the rectangle. Default to the `grid` bottom-most y-coordinate (see @{Grid:getBounds}).
  -- @treturn node a `node` on the collision map, upon each iteration step
  -- @treturn int the iteration count
	-- @usage
	-- for node, count in myGrid:iter() do
	--   print(node:getX(), node:getY(), count)
	-- end
  function Grid:iter(lx,ly,ex,ey)
    local min_x = lx or self._min_x
    local min_y = ly or self._min_y
    local max_x = ex or self._max_x
    local max_y = ey or self._max_y

    local x, y
    y = min_y
    return function()
      x = not x and min_x or x+1
      if x > max_x then
        x = min_x
        y = y+1
      end
      if y > max_y then
        y = nil
      end
      return self._nodes[y] and self._nodes[y][x] or self:getNodeAt(x,y)
    end
  end

	--- Grid iterator. Iterates on each node along the outline (border) of a squared area
	-- centered on the given node.
	-- @tparam node node a given `node`
	-- @tparam[opt] int radius the area radius (half-length). Defaults to __1__ when not given.
	-- @treturn node a `node` at each iteration step
	-- @usage
	-- for node in myGrid:around(node, 2) do
	--   ...
	-- end
	function Grid:around(node, radius)
		local x, y = node._x, node._y
		radius = radius or 1
		local _around = Utils.around()
		local _nodes = {}
		repeat
			local state, x, y = coroutine.resume(_around,x,y,radius)
			local nodeAt = state and self:getNodeAt(x, y)
			if nodeAt then _nodes[#_nodes+1] = nodeAt end
		until (not state)
		local _i = 0
		return function()
			_i = _i+1
			return _nodes[_i]
		end
	end

  --- Each transformation. Calls the given function on each `node` in the `grid`,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:each(printNode)
  function Grid:each(f,...)
    for node in self:iter() do f(node,...) end
		return self
  end

  --- Each (in range) transformation. Calls a function on each `node` in the range of a rectangle of cells,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:eachRange(1,1,8,8,printNode)
  function Grid:eachRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do f(node,...) end
		return self
  end

  --- Map transformation.
	-- Calls function __f(node,...)__ on each `node` in a given range, passing the `node` as the first arg to function __f__ and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(nothing)
  function Grid:imap(f,...)
    for node in self:iter() do
      node = f(node,...)
    end
		return self
  end

  --- Map in range transformation.
	-- Calls function __f(node,...)__ on each `node` in a rectangle range, passing the `node` as the first argument to the function and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
	-- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(1,1,6,6,nothing)
  function Grid:imapRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do
      node = f(node,...)
    end
		return self
  end

  -- Specialized grids
  -- Inits a preprocessed grid
  function PreProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes, newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.arrayToNodes(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}
    return setmetatable(newGrid,PreProcessGrid)
  end

  -- Inits a postprocessed grid
  function PostProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes = {}
    newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.getArrayBounds(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}		
    return setmetatable(newGrid,PostProcessGrid)
  end

  --- Returns the `node` at location [x,y].
  -- @class function
  -- @name Grid:getNodeAt
  -- @tparam int x the x-coordinate coordinate
  -- @tparam int y the y-coordinate coordinate
  -- @treturn node a `node`
	-- @usage local aNode = myGrid:getNodeAt(2,2)

  -- Gets the node at location <x,y> on a preprocessed grid
  function PreProcessGrid:getNodeAt(x,y)
    return self._nodes[y] and self._nodes[y][x] or nil
  end

  -- Gets the node at location <x,y> on a postprocessed grid
  function PostProcessGrid:getNodeAt(x,y)
    if not x or not y then return end
    if Utils.outOfRange(x,self._min_x,self._max_x) then return end
    if Utils.outOfRange(y,self._min_y,self._max_y) then return end
    if not self._nodes[y] then self._nodes[y] = {} end
    if not self._nodes[y][x] then self._nodes[y][x] = Node:new(x,y) end
    return self._nodes[y][x]
  end

  return setmetatable(Grid,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end


--- FILE: \lib\Jumper\jumper\pathfinder.lua ---

--- The Pathfinder class

--
-- Implementation of the `pathfinder` class.

local _VERSION = ""
local _RELEASEDATE = ""

if (...) then

  -- Dependencies
  local _PATH = (...):gsub('%.pathfinder$','')
	local Utils     = require (_PATH .. '.core.utils')
	local Assert    = require (_PATH .. '.core.assert')
  local Heap      = require (_PATH .. '.core.bheap')
  local Heuristic = require (_PATH .. '.core.heuristics')
  local Grid      = require (_PATH .. '.grid')
  local Path      = require (_PATH .. '.core.path')

  -- Internalization
  local t_insert, t_remove = table.insert, table.remove
	local floor = math.floor
  local pairs = pairs
  local assert = assert
	local type = type
  local setmetatable, getmetatable = setmetatable, getmetatable

	--- Finders (search algorithms implemented). Refers to the search algorithms actually implemented in Jumper.
	--
	-- <li>[A*](http://en.wikipedia.org/wiki/A*_search_algorithm)</li>
	-- <li>[Dijkstra](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)</li>
	-- <li>[Theta Astar](http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/)</li>
	-- <li>[BFS](http://en.wikipedia.org/wiki/Breadth-first_search)</li>
	-- <li>[DFS](http://en.wikipedia.org/wiki/Depth-first_search)</li>
	-- <li>[JPS](http://harablog.wordpress.com/2011/09/07/jump-point-search/)</li>
	-- @finder Finders
	-- @see Pathfinder:getFinders
  local Finders = {
    ['ASTAR']     = require (_PATH .. '.search.astar'),
    ['DIJKSTRA']  = require (_PATH .. '.search.dijkstra'),
    ['THETASTAR'] = require (_PATH .. '.search.thetastar'),
    ['BFS']       = require (_PATH .. '.search.bfs'),
    ['DFS']       = require (_PATH .. '.search.dfs'),
    ['JPS']       = require (_PATH .. '.search.jps')
  }

  -- Will keep track of all nodes expanded during the search
  -- to easily reset their properties for the next pathfinding call
  local toClear = {}

	--- Search modes. Refers to the search modes. In ORTHOGONAL mode, 4-directions are only possible when moving,
	-- including North, East, West, South. In DIAGONAL mode, 8-directions are possible when moving,
	-- including North, East, West, South and adjacent directions.
	--
	-- <li>ORTHOGONAL</li>
	-- <li>DIAGONAL</li>
	-- @mode Modes
	-- @see Pathfinder:getModes
  local searchModes = {['DIAGONAL'] = true, ['ORTHOGONAL'] = true}

  -- Performs a traceback from the goal node to the start node
  -- Only happens when the path was found

	--- The `Pathfinder` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Pathfinder(...)</code> _acts as a shortcut to_ <code>Pathfinder:new(...)</code>.
	-- @type Pathfinder
  local Pathfinder = {}
  Pathfinder.__index = Pathfinder

  --- Inits a new `pathfinder`
  -- @class function
  -- @tparam grid grid a `grid`
  -- @tparam[opt] string finderName the name of the `Finder` (search algorithm) to be used for search.
	-- Defaults to `ASTAR` when not given (see @{Pathfinder:getFinders}).
  -- @tparam[optchain] string|int|func walkable the value for __walkable__ nodes.
  -- If this parameter is a function, it should be prototyped as __f(value)__, returning a boolean:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise.
  -- @treturn pathfinder a new `pathfinder` instance
	-- @usage
	-- -- Example one
	-- local finder = Pathfinder:new(myGrid, 'ASTAR', 0)
	--
	-- -- Example two
	-- local function walkable(value)
	--   return value > 0
	-- end
	-- local finder = Pathfinder(myGrid, 'JPS', walkable)
  function Pathfinder:new(grid, finderName, walkable)
    local newPathfinder = {}
    setmetatable(newPathfinder, Pathfinder)
	  newPathfinder:setGrid(grid)
    newPathfinder:setFinder(finderName)
    newPathfinder:setWalkable(walkable)
    newPathfinder:setMode('DIAGONAL')
    newPathfinder:setHeuristic('MANHATTAN')
    newPathfinder:setTunnelling(false)
    return newPathfinder
  end

	--- Evaluates [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)
	-- for the whole `grid`. It should be called only once, unless the collision map or the
	-- __walkable__ attribute changes. The clearance values are calculated and cached within the grid nodes.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:annotateGrid()
	function Pathfinder:annotateGrid()
		assert(self._walkable, 'Finder must implement a walkable value')
		for x=self._grid._max_x,self._grid._min_x,-1 do
			for y=self._grid._max_y,self._grid._min_y,-1 do
				local node = self._grid:getNodeAt(x,y)
				if self._grid:isWalkableAt(x,y,self._walkable) then
					local nr = self._grid:getNodeAt(node._x+1, node._y)
					local nrd = self._grid:getNodeAt(node._x+1, node._y+1)
					local nd = self._grid:getNodeAt(node._x, node._y+1)
					if nr and nrd and nd then
						local m = nrd._clearance[self._walkable] or 0
						m = (nd._clearance[self._walkable] or 0)<m and (nd._clearance[self._walkable] or 0) or m
						m = (nr._clearance[self._walkable] or 0)<m and (nr._clearance[self._walkable] or 0) or m
						node._clearance[self._walkable] = m+1
					else
						node._clearance[self._walkable] = 1
					end
				else node._clearance[self._walkable] = 0
				end
			end
		end
		self._grid._isAnnotated[self._walkable] = true
		return self
	end

	--- Removes [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)values.
	-- Clears cached clearance values for the current __walkable__.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:clearAnnotations()
	function Pathfinder:clearAnnotations()
		assert(self._walkable, 'Finder must implement a walkable value')
		for node in self._grid:iter() do
			node:removeClearance(self._walkable)
		end
		self._grid._isAnnotated[self._walkable] = false
		return self
	end

  --- Sets the `grid`. Defines the given `grid` as the one on which the `pathfinder` will perform the search.
  -- @class function
  -- @tparam grid grid a `grid`
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setGrid(myGrid)
  function Pathfinder:setGrid(grid)
    assert(Assert.inherits(grid, Grid), 'Wrong argument #1. Expected a \'grid\' object')
    self._grid = grid
    self._grid._eval = self._walkable and type(self._walkable) == 'function'
    return self
  end

  --- Returns the `grid`. This is a reference to the actual `grid` used by the `pathfinder`.
  -- @class function
  -- @treturn grid the `grid`
	-- @usage local myGrid = myFinder:getGrid()
  function Pathfinder:getGrid()
    return self._grid
  end

  --- Sets the __walkable__ value or function.
  -- @class function
  -- @tparam string|int|func walkable the value for walkable nodes.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- -- Value '0' is walkable
	-- myFinder:setWalkable(0)
	--
	-- -- Any value greater than 0 is walkable
	-- myFinder:setWalkable(function(n)
	--   return n>0
	-- end
  function Pathfinder:setWalkable(walkable)
    assert(Assert.matchType(walkable,'stringintfunctionnil'),
      ('Wrong argument #1. Expected \'string\', \'number\' or \'function\', got %s.'):format(type(walkable)))
    self._walkable = walkable
    self._grid._eval = type(self._walkable) == 'function'
    return self
  end

  --- Gets the __walkable__ value or function.
  -- @class function
  -- @treturn string|int|func the `walkable` value or function
	-- @usage local walkable = myFinder:getWalkable()
  function Pathfinder:getWalkable()
    return self._walkable
  end

  --- Defines the `finder`. It refers to the search algorithm used by the `pathfinder`.
  -- Default finder is `ASTAR`. Use @{Pathfinder:getFinders} to get the list of available finders.
  -- @class function
  -- @tparam string finderName the name of the `finder` to be used for further searches.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- --To use Breadth-First-Search
	-- myFinder:setFinder('BFS')
	-- @see Pathfinder:getFinders
  function Pathfinder:setFinder(finderName)
		if not finderName then
			if not self._finder then
				finderName = 'ASTAR'
			else return
			end
		end
    assert(Finders[finderName],'Not a valid finder name!')
    self._finder = finderName
    return self
  end

  --- Returns the name of the `finder` being used.
  -- @class function
  -- @treturn string the name of the `finder` to be used for further searches.
	-- @usage local finderName = myFinder:getFinder()
  function Pathfinder:getFinder()
    return self._finder
  end

  --- Returns the list of all available finders names.
  -- @class function
  -- @treturn {string,...} array of built-in finders names.
	-- @usage
	-- local finders = myFinder:getFinders()
	-- for i, finderName in ipairs(finders) do
	--   print(i, finderName)
	-- end
  function Pathfinder:getFinders()
    return Utils.getKeys(Finders)
  end

  --- Sets a heuristic. This is a function internally used by the `pathfinder` to find the optimal path during a search.
  -- Use @{Pathfinder:getHeuristics} to get the list of all available `heuristics`. One can also define
  -- his own `heuristic` function.
  -- @class function
  -- @tparam func|string heuristic `heuristic` function, prototyped as __f(dx,dy)__ or as a `string`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getHeuristics
	-- @see core.heuristics
	-- @usage myFinder:setHeuristic('MANHATTAN')
  function Pathfinder:setHeuristic(heuristic)
    assert(Heuristic[heuristic] or (type(heuristic) == 'function'),'Not a valid heuristic!')
    self._heuristic = Heuristic[heuristic] or heuristic
    return self
  end

  --- Returns the `heuristic` used. Returns the function itself.
  -- @class function
  -- @treturn func the `heuristic` function being used by the `pathfinder`
	-- @see core.heuristics
	-- @usage local h = myFinder:getHeuristic()
  function Pathfinder:getHeuristic()
    return self._heuristic
  end

  --- Gets the list of all available `heuristics`.
  -- @class function
  -- @treturn {string,...} array of heuristic names.
	-- @see core.heuristics
	-- @usage
	-- local heur = myFinder:getHeuristic()
	-- for i, heuristicName in ipairs(heur) do
	--   ...
	-- end
  function Pathfinder:getHeuristics()
    return Utils.getKeys(Heuristic)
  end

  --- Defines the search `mode`.
  -- The default search mode is the `DIAGONAL` mode, which implies 8-possible directions when moving (north, south, east, west and diagonals).
  -- In `ORTHOGONAL` mode, only 4-directions are allowed (north, south, east and west).
  -- Use @{Pathfinder:getModes} to get the list of all available search modes.
  -- @class function
  -- @tparam string mode the new search `mode`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getModes
	-- @see Modes
	-- @usage myFinder:setMode('ORTHOGONAL')
  function Pathfinder:setMode(mode)
    assert(searchModes[mode],'Invalid mode')
    self._allowDiagonal = (mode == 'DIAGONAL')
    return self
  end

  --- Returns the search mode.
  -- @class function
  -- @treturn string the current search mode
	-- @see Modes
	-- @usage local mode = myFinder:getMode()
  function Pathfinder:getMode()
    return (self._allowDiagonal and 'DIAGONAL' or 'ORTHOGONAL')
  end

  --- Gets the list of all available search modes.
  -- @class function
  -- @treturn {string,...} array of search modes.
	-- @see Modes
	-- @usage local modes = myFinder:getModes()
	-- for modeName in ipairs(modes) do
	--   ...
	-- end
  function Pathfinder:getModes()
    return Utils.getKeys(searchModes)
  end

  --- Enables tunnelling. Defines the ability for the `pathfinder` to tunnel through walls when heading diagonally.
	-- This feature __is not compatible__ with Jump Point Search algorithm (i.e. enabling it will not affect Jump Point Search)
  -- @class function
  -- @tparam bool bool a boolean
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setTunnelling(true)
  function Pathfinder:setTunnelling(bool)
    assert(Assert.isBool(bool), ('Wrong argument #1. Expected boolean, got %s'):format(type(bool)))
		self._tunnel = bool
		return self
  end

  --- Returns tunnelling feature state.
  -- @class function
	-- @treturn bool tunnelling feature actual state
	-- @usage local isTunnellingEnabled = myFinder:getTunnelling()
  function Pathfinder:getTunnelling()
		return self._tunnel
  end

  --- Calculates a `path`. Returns the `path` from location __[startX, startY]__ to location __[endX, endY]__.
  -- Both locations must exist on the collision map. The starting location can be unwalkable.
  -- @class function
  -- @tparam int startX the x-coordinate for the starting location
  -- @tparam int startY the y-coordinate for the starting location
  -- @tparam int endX the x-coordinate for the goal location
  -- @tparam int endY the y-coordinate for the goal location
  -- @tparam int clearance the amount of clearance (i.e the pathing agent size) to consider
  -- @treturn path a path (array of nodes) when found, otherwise nil
	-- @usage local path = myFinder:getPath(1,1,5,5)
  function Pathfinder:getPath(startX, startY, endX, endY, clearance)
		self:reset()
    local startNode = self._grid:getNodeAt(startX, startY)
    local endNode = self._grid:getNodeAt(endX, endY)
    assert(startNode, ('Invalid location [%d, %d]'):format(startX, startY))
    assert(endNode and self._grid:isWalkableAt(endX, endY),
      ('Invalid or unreachable location [%d, %d]'):format(endX, endY))
    local _endNode = Finders[self._finder](self, startNode, endNode, clearance, toClear)
    if _endNode then
			return Utils.traceBackPath(self, _endNode, startNode)
    end
    return nil
  end

  --- Resets the `pathfinder`. This function is called internally between successive pathfinding calls, so you should not
	-- use it explicitely, unless under specific circumstances.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage local path, len = myFinder:getPath(1,1,5,5)
	function Pathfinder:reset()
    for node in pairs(toClear) do node:reset() end
    toClear = {}
		return self
	end


  -- Returns Pathfinder class
	Pathfinder._VERSION = _VERSION
	Pathfinder._RELEASEDATE = _RELEASEDATE
  return setmetatable(Pathfinder,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end


--- FILE: \lib\Jumper\jumper\core\assert.lua ---

-- Various assertion function for API methods argument-checking

if (...) then
	
	-- Dependancies
	local _PATH = (...):gsub('%.core.assert$','')
	local Utils = require (_PATH .. '.core.utils')
	
	-- Local references
	local lua_type = type
	local floor = math.floor
	local concat = table.concat
	local next = next
	local pairs = pairs
	local getmetatable = getmetatable
	
	-- Is I an integer ?
	local function isInteger(i)
		return lua_type(i) ==('number') and (floor(i)==i)
	end
	
	-- Override lua_type to return integers
	local function type(v)
		return isInteger(v) and 'int' or lua_type(v)
	end
	
	-- Does the given array contents match a predicate type ?
	local function arrayContentsMatch(t,...)
		local n_count = Utils.arraySize(t)
		if n_count < 1 then return false end
		local init_count = t[0] and 0 or 1
		local n_count = (t[0] and n_count-1 or n_count)
		local types = {...}
		if types then types = concat(types) end
		for i=init_count,n_count,1 do
			if not t[i] then return false end
			if types then
				if not types:match(type(t[i])) then return false end
			end
		end
		return true
	end	
	
	-- Checks if arg is a valid array map
  local function isMap(m)
		if not arrayContentsMatch(m, 'table') then return false end
		local lsize = Utils.arraySize(m[next(m)])
		for k,v in pairs(m) do
			if not arrayContentsMatch(m[k], 'string', 'int') then return false end
			if Utils.arraySize(v)~=lsize then return false end
		end
		return true
  end	
	
	-- Checks if s is a valid string map
  local function isStringMap(s)
    if lua_type(s) ~= 'string' then return false end
    local w
    for row in s:gmatch('[^\n\r]+') do
      if not row then return false end
      w = w or #row
      if w ~= #row then return false end
    end
    return true
  end

	-- Does instance derive straight from class
	local function derives(instance, class)
		return getmetatable(instance) == class
	end
	
	-- Does instance inherits from class	
	local function inherits(instance, class)
		return (getmetatable(getmetatable(instance)) == class)
	end
	
	-- Is arg a boolean
	local function isBoolean(b) 
		return (b==true or b==false)
	end
	
	-- Is arg nil ?
	local function isNil(n)
		return (n==nil)
	end
	
	local function matchType(value, types)
		return types:match(type(value))	
	end
	
	return {
		arrayContentsMatch = arrayContentsMatch,
		derives = derives,
		inherits = inherits,
		isInteger = isInteger,
		isBool = isBoolean,
		isMap = isMap,
		isStrMap = isStringMap,
		isOutOfRange = isOutOfRange,
		isNil = isNil,
		type = type,
		matchType = matchType
	}

end




--- FILE: \lib\Jumper\jumper\core\bheap.lua ---

--- A light implementation of Binary heaps data structure.
-- While running a search, some search algorithms (Astar, Dijkstra, Jump Point Search) have to maintains
-- a list of nodes called __open list__. Retrieve from this list the lowest cost node can be quite slow, 
-- as it normally requires to skim through the full set of nodes stored in this list. This becomes a real 
-- problem especially when dozens of nodes are being processed (on large maps). 
--
-- The current module implements a <a href="http://www.policyalmanac.org/games/binaryHeaps.htm">binary heap</a>
-- data structure, from which the search algorithm will instantiate an open list, and cache the nodes being 
-- examined during a search. As such, retrieving the lower-cost node is faster and globally makes the search end 
-- up quickly.
-- 
-- This module is internally used by the library on purpose.
-- It should normally not be used explicitely, yet it remains fully accessible.
--

--[[
  Notes:
  This lighter implementation of binary heaps, based on :
    https://github.com/Yonaba/Binary-Heaps
--]]

if (...) then

	-- Dependency
	local Utils = require((...):gsub('%.bheap$','.utils'))
	
	-- Local reference
	local floor = math.floor

	-- Default comparison function
	local function f_min(a,b) return a < b end

	-- Percolates up
	local function percolate_up(heap, index)
		if index == 1 then return end
		local pIndex
		if index <= 1 then return end
		if index%2 == 0 then
			pIndex =  index/2
		else pIndex = (index-1)/2
		end
		if not heap._sort(heap._heap[pIndex], heap._heap[index]) then
			heap._heap[pIndex], heap._heap[index] = 
				heap._heap[index], heap._heap[pIndex]
			percolate_up(heap, pIndex)
		end
	end

	-- Percolates down
	local function percolate_down(heap,index)
		local lfIndex,rtIndex,minIndex
		lfIndex = 2*index
		rtIndex = lfIndex + 1
		if rtIndex > heap._size then
			if lfIndex > heap._size then return
			else minIndex = lfIndex  end
		else
			if heap._sort(heap._heap[lfIndex],heap._heap[rtIndex]) then
				minIndex = lfIndex
			else
				minIndex = rtIndex
			end
		end
		if not heap._sort(heap._heap[index],heap._heap[minIndex]) then
			heap._heap[index],heap._heap[minIndex] = heap._heap[minIndex],heap._heap[index]
			percolate_down(heap,minIndex)
		end
	end

	-- Produces a new heap
	local function newHeap(template,comp)
		return setmetatable({_heap = {},
			_sort = comp or f_min, _size = 0},
		template)
	end


	--- The `heap` class.<br/>
	-- This class is callable.
	-- _Therefore,_ <code>heap(...)</code> _is used to instantiate new heaps_.
	-- @type heap
	local heap = setmetatable({},
		{__call = function(self,...)
			return newHeap(self,...)
		end})
	heap.__index = heap

	--- Checks if a `heap` is empty
	-- @class function
	-- @treturn bool __true__ of no item is queued in the heap, __false__ otherwise
	-- @usage
	-- if myHeap:empty() then 
	--   print('Heap is empty!')
	-- end
	function heap:empty()
		return (self._size==0)
	end

	--- Clears the `heap` (removes all items queued in the heap)
	-- @class function
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage myHeap:clear()
	function heap:clear()
		self._heap = {}
		self._size = 0
		self._sort = self._sort or f_min
		return self
	end

	--- Adds a new item in the `heap`
	-- @class function
	-- @tparam value item a new value to be queued in the heap
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage
	-- myHeap:push(1)
	-- -- or, with chaining
	-- myHeap:push(1):push(2):push(4)
	function heap:push(item)
		if item then
			self._size = self._size + 1
			self._heap[self._size] = item
			percolate_up(self, self._size)
		end
		return self
	end

	--- Pops from the `heap`.
	-- Removes and returns the lowest cost item (with respect to the comparison function being used) from the `heap`.
	-- @class function
	-- @treturn value a value previously pushed into the heap
	-- @usage
	-- while not myHeap:empty() do 
	--   local lowestValue = myHeap:pop()
	--   ...
	-- end
	function heap:pop()
		local root
		if self._size > 0 then
			root = self._heap[1]
			self._heap[1] = self._heap[self._size]
			self._heap[self._size] = nil
			self._size = self._size-1
			if self._size>1 then
				percolate_down(self, 1)
			end
		end
		return root
	end

	--- Restores the `heap` property.
	-- Reorders the `heap` with respect to the comparison function being used. 
	-- When given argument __item__ (a value existing in the `heap`), will sort from that very item in the `heap`. 
	-- Otherwise, the whole `heap` will be cheacked. 
	-- @class function
	-- @tparam[opt] value item the modified value
	-- @treturn heap self (the calling `heap` itself, can be chained)
	-- @usage myHeap:heapify() 
	function heap:heapify(item)
		if self._size == 0 then return end
		if item then
			local i = Utils.indexOf(self._heap,item)
			if i then 
				percolate_down(self, i)
				percolate_up(self, i)
			end
			return
		end
		for i = floor(self._size/2),1,-1 do
			percolate_down(self,i)
		end
		return self
	end

	return heap
end


--- FILE: \lib\Jumper\jumper\core\heuristics.lua ---

--- Heuristic functions for search algorithms.
-- A <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">distance heuristic</a> 
-- provides an *estimate of the optimal distance cost* from a given location to a target. 
-- As such, it guides the pathfinder to the goal, helping it to decide which route is the best.
--
-- This script holds the definition of some built-in heuristics available through jumper.
--
-- Distance functions are internally used by the `pathfinder` to evaluate the optimal path
-- from the start location to the goal. These functions share the same prototype:
--     local function myHeuristic(nodeA, nodeB)
--       -- function body
--     end
-- Jumper features some built-in distance heuristics, namely `MANHATTAN`, `EUCLIDIAN`, `DIAGONAL`, `CARDINTCARD`.
-- You can also supply your own heuristic function, following the same template as above.


local abs = math.abs
local sqrt = math.sqrt
local sqrt2 = sqrt(2)
local max, min = math.max, math.min

local Heuristics = {}
  --- Manhattan distance.
  -- <br/>This heuristic is the default one being used by the `pathfinder` object.
  -- <br/>Evaluates as <code>distance = |dx|+|dy|</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('MANHATTAN')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.MANHATTAN)
  function Heuristics.MANHATTAN(nodeA, nodeB) 
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)
		return (dx + dy) 
	end
  
  --- Euclidian distance.
  -- <br/>Evaluates as <code>distance = squareRoot(dx*dx+dy*dy)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('EUCLIDIAN')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.EUCLIDIAN) 
  function Heuristics.EUCLIDIAN(nodeA, nodeB)
		local dx = nodeA._x - nodeB._x
		local dy = nodeA._y - nodeB._y
		return sqrt(dx*dx+dy*dy) 
	end
  
  --- Diagonal distance.
  -- <br/>Evaluates as <code>distance = max(|dx|, abs|dy|)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('DIAGONAL')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.DIAGONAL)
  function Heuristics.DIAGONAL(nodeA, nodeB)
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)	
		return max(dx,dy) 
	end
  
  --- Cardinal/Intercardinal distance.
  -- <br/>Evaluates as <code>distance = min(dx, dy)*squareRoot(2) + max(dx, dy) - min(dx, dy)</code>
  -- @class function
  -- @tparam node nodeA a node
  -- @tparam node nodeB another node
  -- @treturn number the distance from __nodeA__ to __nodeB__
	-- @usage
  -- -- First method
  -- pathfinder:setHeuristic('CARDINTCARD')
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.CARDINTCARD)
  function Heuristics.CARDINTCARD(nodeA, nodeB)
		local dx = abs(nodeA._x - nodeB._x)
		local dy = abs(nodeA._y - nodeB._y)	
    return min(dx,dy) * sqrt2 + max(dx,dy) - min(dx,dy)
  end

return Heuristics


--- FILE: \lib\Jumper\jumper\core\lookuptable.lua ---

local addNode(self, node, nextNode, ed)
	if not self._pathDB[node] then self._pathDB[node] = {} end
	self._pathDB[node][ed] = (nextNode == ed and node or nextNode)
end

-- Path lookupTable
local lookupTable = {}
lookupTable.__index = lookupTable

function lookupTable:new()
	local lut = {_pathDB = {}}
	return setmetatable(lut, lookupTable)
end

function lookupTable:addPath(path)
	local st, ed = path._nodes[1], path._nodes[#path._nodes]
	for node, count in path:nodes() do
		local nextNode = path._nodes[count+1]
		if nextNode then addNode(self, node, nextNode, ed) end
	end
end

function lookupTable:hasPath(nodeA, nodeB)
	local found
	found = self._pathDB[nodeA] and self._path[nodeA][nodeB]
	if found then return true, true end
	found = self._pathDB[nodeB] and self._path[nodeB][nodeA]
	if found then return true, false end
	return false
end

return lookupTable


--- FILE: \lib\Jumper\jumper\core\node.lua ---

--- The Node class.
-- The `node` represents a cell (or a tile) on a collision map. Basically, for each single cell (tile)
-- in the collision map passed-in upon initialization, a `node` object will be generated
-- and then cached within the `grid`.
--
-- In the following implementation, nodes can be compared using the `<` operator. The comparison is
-- made with regards of their `f` cost. From a given node being examined, the `pathfinder` will expand the search 
-- to the next neighbouring node having the lowest `f` cost. See `core.bheap` for more details.
-- 

if (...) then

	local assert = assert
	
	--- The `Node` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Node(...)</code> _acts as a shortcut to_ <code>Node:new(...)</code>.
	-- @type Node
  local Node = {}
  Node.__index = Node

  --- Inits a new `node`
  -- @class function
  -- @tparam int x the x-coordinate of the node on the collision map
  -- @tparam int y the y-coordinate of the node on the collision map
  -- @treturn node a new `node`
	-- @usage local node = Node(3,4)
  function Node:new(x,y)
    return setmetatable({_x = x, _y = y, _clearance = {}}, Node)
  end

  -- Enables the use of operator '<' to compare nodes.
  -- Will be used to sort a collection of nodes in a binary heap on the basis of their F-cost
  function Node.__lt(A,B) return (A._f < B._f) end

  --- Returns x-coordinate of a `node`
  -- @class function
  -- @treturn number the x-coordinate of the `node`
	-- @usage local x = node:getX()	
	function Node:getX() return self._x end
	
  --- Returns y-coordinate of a `node`
  -- @class function
  -- @treturn number the y-coordinate of the `node`	
	-- @usage local y = node:getY()		
	function Node:getY() return self._y end
	
  --- Returns x and y coordinates of a `node`
  -- @class function
  -- @treturn number the x-coordinate of the `node`
  -- @treturn number the y-coordinate of the `node`
	-- @usage local x, y = node:getPos()		
	function Node:getPos() return self._x, self._y end
	
  --- Returns the amount of true [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric) 
	-- for a given `node`
  -- @class function
  -- @tparam string|int|func walkable the value for walkable locations in the collision map array.
  -- @treturn int the clearance of the `node`
	-- @usage
	--  -- Assuming walkable was 0	
	-- local clearance = node:getClearance(0)		
	function Node:getClearance(walkable)
		return self._clearance[walkable]
	end
	
  --- Removes the clearance value for a given walkable.
  -- @class function
  -- @tparam string|int|func walkable the value for walkable locations in the collision map array.
	-- @treturn node self (the calling `node` itself, can be chained)
	-- @usage
	--  -- Assuming walkable is defined	
	-- node:removeClearance(walkable)	
	function Node:removeClearance(walkable)
		self._clearance[walkable] = nil
		return self
	end
	
	--- Clears temporary cached attributes of a `node`.
	-- Deletes the attributes cached within a given node after a pathfinding call.
	-- This function is internally used by the search algorithms, so you should not use it explicitely.
	-- @class function
	-- @treturn node self (the calling `node` itself, can be chained)
	-- @usage
	-- local thisNode = Node(1,2)
	-- thisNode:reset()
	function Node:reset()
		self._g, self._h, self._f = nil, nil, nil
		self._opened, self._closed, self._parent = nil, nil, nil
		return self
	end
	
  return setmetatable(Node,
		{__call = function(self,...) 
			return Node:new(...) 
		end}
	)
end


--- FILE: \lib\Jumper\jumper\core\path.lua ---

--- The Path class.
-- The `path` class is a structure which represents a path (ordered set of nodes) from a start location to a goal.
-- An instance from this class would be a result of a request addressed to `Pathfinder:getPath`.
--
-- This module is internally used by the library on purpose.
-- It should normally not be used explicitely, yet it remains fully accessible.
--


if (...) then
	
  -- Dependencies
	local _PATH = (...):match('(.+)%.path$')
  local Heuristic = require (_PATH .. '.heuristics')
	
	 -- Local references
  local abs, max = math.abs, math.max
	local t_insert, t_remove = table.insert, table.remove
	
	--- The `Path` class.<br/>
	-- This class is callable.
	-- Therefore, <em><code>Path(...)</code></em> acts as a shortcut to <em><code>Path:new(...)</code></em>.
	-- @type Path
  local Path = {}
  Path.__index = Path

  --- Inits a new `path`.
  -- @class function
  -- @treturn path a `path`
	-- @usage local p = Path()
  function Path:new()
    return setmetatable({_nodes = {}}, Path)
  end

  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns the `node` plus a count value. Aliased as @{Path:nodes}
  -- @class function
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see Path:nodes
	-- @usage
	-- for node, count in p:iter() do
	--   ...
	-- end
  function Path:iter()
    local i,pathLen = 1,#self._nodes
    return function()
      if self._nodes[i] then
        i = i+1
        return self._nodes[i-1],i-1
      end
    end
  end
  
  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns a `node` plus a count value. Alias for @{Path:iter}
  -- @class function
	-- @name Path:nodes
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see Path:iter	
	-- @usage
	-- for node, count in p:nodes() do
	--   ...
	-- end	
	Path.nodes = Path.iter
	
  --- Evaluates the `path` length
  -- @class function
  -- @treturn number the `path` length
	-- @usage local len = p:getLength()
  function Path:getLength()
    local len = 0
    for i = 2,#self._nodes do
      len = len + Heuristic.EUCLIDIAN(self._nodes[i], self._nodes[i-1])
    end
    return len
  end
	
	--- Counts the number of steps.
	-- Returns the number of waypoints (nodes) in the current path.
	-- @class function
	-- @tparam node node a node to be added to the path
	-- @tparam[opt] int index the index at which the node will be inserted. If omitted, the node will be appended after the last node in the path.
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage local nSteps = p:countSteps()
	function Path:addNode(node, index)
		index = index or #self._nodes+1
		t_insert(self._nodes, index, node)
		return self
	end
	
	
  --- `Path` filling modifier. Interpolates between non contiguous nodes along a `path`
  -- to build a fully continuous `path`. This maybe useful when using search algorithms such as Jump Point Search.
  -- Does the opposite of @{Path:filter}
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)	
  -- @see Path:filter
	-- @usage p:fill()
  function Path:fill()
    local i = 2
    local xi,yi,dx,dy
    local N = #self._nodes
    local incrX, incrY
    while true do
      xi,yi = self._nodes[i]._x,self._nodes[i]._y
      dx,dy = xi-self._nodes[i-1]._x,yi-self._nodes[i-1]._y
      if (abs(dx) > 1 or abs(dy) > 1) then
        incrX = dx/max(abs(dx),1)
        incrY = dy/max(abs(dy),1)
        t_insert(self._nodes, i, self._grid:getNodeAt(self._nodes[i-1]._x + incrX, self._nodes[i-1]._y +incrY))
        N = N+1
      else i=i+1
      end
      if i>N then break end
    end
		return self
  end

  --- `Path` compression modifier. Given a `path`, eliminates useless nodes to return a lighter `path` 
	-- consisting of straight moves. Does the opposite of @{Path:fill}
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)	
  -- @see Path:fill
	-- @usage p:filter()
  function Path:filter()
    local i = 2
    local xi,yi,dx,dy, olddx, olddy
    xi,yi = self._nodes[i]._x, self._nodes[i]._y
    dx, dy = xi - self._nodes[i-1]._x, yi-self._nodes[i-1]._y
    while true do
      olddx, olddy = dx, dy
      if self._nodes[i+1] then
        i = i+1
        xi, yi = self._nodes[i]._x, self._nodes[i]._y
        dx, dy = xi - self._nodes[i-1]._x, yi - self._nodes[i-1]._y
        if olddx == dx and olddy == dy then
          t_remove(self._nodes, i-1)
          i = i - 1
        end
      else break end
    end
		return self
  end
	
  --- Clones a `path`.
  -- @class function
  -- @treturn path a `path`
	-- @usage local p = path:clone()	
	function Path:clone()
		local p = Path:new()
		for node in self:nodes() do p:addNode(node) end
		return p
	end
	
  --- Checks if a `path` is equal to another. It also supports *filtered paths* (see @{Path:filter}).
  -- @class function
	-- @tparam path p2 a path
  -- @treturn boolean a boolean
	-- @usage print(myPath:isEqualTo(anotherPath))
	function Path:isEqualTo(p2)
		local p1 = self:clone():filter()
		local p2 = p2:clone():filter()
		for node, count in p1:nodes() do
			if not p2._nodes[count] then return false end
			local n = p2._nodes[count]
			if n._x~=node._x or n._y~=node._y then return false end
		end	
		return true
	end
	
  --- Reverses a `path`.
  -- @class function
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage myPath:reverse()	
	function Path:reverse()
		local _nodes = {}
		for i = #self._nodes,1,-1 do
			_nodes[#_nodes+1] = self._nodes[i]		
		end
		self._nodes = _nodes
		return self
	end	

  --- Appends a given `path` to self.
  -- @class function
	-- @tparam path p a path
	-- @treturn path self (the calling `path` itself, can be chained)
	-- @usage myPath:append(anotherPath)		
	function Path:append(p)
		for node in p:nodes() do self:addNode(node)	end
		return self
	end
	
  return setmetatable(Path,
    {__call = function(self,...)
      return Path:new(...)
    end
  })
end


--- FILE: \lib\Jumper\jumper\core\utils.lua ---

-- Various utilities for Jumper top-level modules

if (...) then

	-- Dependencies
	local _PATH = (...):gsub('%.utils$','')
	local Path = require (_PATH .. '.path')
	local Node = require (_PATH .. '.node')

	-- Local references
	local pairs = pairs
	local type = type
	local t_insert = table.insert
	local assert = assert
	local coroutine = coroutine

	-- Raw array items count
	local function arraySize(t)
		local count = 0
		for k,v in pairs(t) do
			count = count+1
		end
		return count
	end

	-- Parses a string map and builds an array map
  local function stringMapToArray(str)
		local map = {}
		local w, h
    for line in str:gmatch('[^\n\r]+') do
      if line then
        w = not w and #line or w
        assert(#line == w, 'Error parsing map, rows must have the same size!')
        h = (h or 0) + 1
        map[h] = {}
        for char in line:gmatch('.') do
					map[h][#map[h]+1] = char
				end
      end
    end
    return map
  end

	-- Collects and returns the keys of a given array
  local function getKeys(t)
    local keys = {}
    for k,v in pairs(t) do keys[#keys+1] = k end
    return keys
  end

	-- Calculates the bounds of a 2d array
  local function getArrayBounds(map)
    local min_x, max_x
    local min_y, max_y
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
        end
      end
    return min_x,max_x,min_y,max_y
  end

  -- Converts an array to a set of nodes
  local function arrayToNodes(map)
    local min_x, max_x
    local min_y, max_y
    local nodes = {}
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        nodes[y] = {}
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
          nodes[y][x] = Node:new(x,y)
        end
      end
    return nodes,
			 (min_x or 0), (max_x or 0),
			 (min_y or 0), (max_y or 0)
  end

	-- Iterator, wrapped within a coroutine
	-- Iterates around a given position following the outline of a square
	local function around()
		local iterf = function(x0, y0, s)
			local x, y = x0-s, y0-s
			coroutine.yield(x, y)
			repeat
				x = x + 1
				coroutine.yield(x,y)
			until x == x0+s
			repeat
				y = y + 1
				coroutine.yield(x,y)
			until y == y0 + s
			repeat
				x = x - 1
				coroutine.yield(x, y)
			until x == x0-s
			repeat
				y = y - 1
				coroutine.yield(x,y)
			until y == y0-s+1
		end
		return coroutine.create(iterf)
	end

	-- Extract a path from a given start/end position
  local function traceBackPath(finder, node, startNode)
    local path = Path:new()
    path._grid = finder._grid
    while true do
      if node._parent then
        t_insert(path._nodes,1,node)
        node = node._parent
      else
        t_insert(path._nodes,1,startNode)
        return path
      end
    end
  end

	-- Lookup for value in a table
	local indexOf = function(t,v)
		for i = 1,#t do
			if t[i] == v then return i end
		end
		return nil
	end

	-- Is i out of range
  local function outOfRange(i,low,up)
    return (i< low or i > up)
  end
	
	return {
		arraySize = arraySize,
		getKeys = getKeys,
		indexOf = indexOf,
		outOfRange = outOfRange,
		getArrayBounds = getArrayBounds,
		arrayToNodes = arrayToNodes,
		strToMap = stringMapToArray,
		around = around,
		drAround = drAround,
		traceBackPath = traceBackPath
	}

end


--- FILE: \lib\Jumper\jumper\search\astar.lua ---

-- Astar algorithm
-- This actual implementation of A-star is based on
-- [Nash A. & al. pseudocode](http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/)

if (...) then

	-- Internalization
	local ipairs = ipairs
	local huge = math.huge

	-- Dependancies
	local _PATH = (...):match('(.+)%.search.astar$')
	local Heuristics = require (_PATH .. '.core.heuristics')
	local Heap = require (_PATH.. '.core.bheap')

	-- Updates G-cost
	local function computeCost(node, neighbour, finder, clearance)
		local mCost = Heuristics.EUCLIDIAN(neighbour, node)
		if node._g + mCost < neighbour._g then
			neighbour._parent = node
			neighbour._g = node._g + mCost
		end
	end

	-- Updates vertex node-neighbour
	local function updateVertex(finder, openList, node, neighbour, endNode, clearance, heuristic, overrideCostEval)
		local oldG = neighbour._g
		local cmpCost = overrideCostEval or computeCost
		cmpCost(node, neighbour, finder, clearance)
		if neighbour._g < oldG then
			local nClearance = neighbour._clearance[finder._walkable]
			local pushThisNode = clearance and nClearance and (nClearance >= clearance)
			if (clearance and pushThisNode) or (not clearance) then
				if neighbour._opened then neighbour._opened = false end				
				neighbour._h = heuristic(endNode, neighbour)
				neighbour._f = neighbour._g + neighbour._h
				openList:push(neighbour)
				neighbour._opened = true
			end
		end
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear, overrideHeuristic, overrideCostEval)
		
		local heuristic = overrideHeuristic or finder._heuristic
		local openList = Heap()
		startNode._g = 0
		startNode._h = heuristic(endNode, startNode)
		startNode._f = startNode._g + startNode._h
		openList:push(startNode)
		toClear[startNode] = true
		startNode._opened = true

		while not openList:empty() do
			local node = openList:pop()
			node._closed = true
			if node == endNode then return node end
			local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
			for i = 1,#neighbours do
				local neighbour = neighbours[i]
				if not neighbour._closed then
					toClear[neighbour] = true
					if not neighbour._opened then
						neighbour._g = huge
						neighbour._parent = nil	
					end
					updateVertex(finder, openList, node, neighbour, endNode, clearance, heuristic, overrideCostEval)
				end	
			end	
		end
		
		return nil 
	end

end


--- FILE: \lib\Jumper\jumper\search\bfs.lua ---

-- Breadth-First search algorithm

if (...) then
  -- Internalization
  local t_remove = table.remove

  local function breadth_first_search(finder, openList, node, endNode, clearance, toClear)
    local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if not neighbour._closed and not neighbour._opened then
				local nClearance = neighbour._clearance[finder._walkable]
				local pushThisNode = clearance and nClearance and (nClearance >= clearance)			
        if (clearance and pushThisNode) or (not clearance) then
					openList[#openList+1] = neighbour
					neighbour._opened = true
					neighbour._parent = node
					toClear[neighbour] = true
				end
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)

    local openList = {} -- We'll use a FIFO queue (simple array)
    openList[1] = startNode
    startNode._opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[1]
      t_remove(openList,1)
      node._closed = true
      if node == endNode then return node end
      breadth_first_search(finder, openList, node, endNode, clearance, toClear)
    end

    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\dfs.lua ---

-- Depth-First search algorithm.

if (...) then
  -- Internalization
  local t_remove = table.remove

  local function depth_first_search(finder, openList, node, endNode, clearance, toClear)
    local neighbours = finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if (not neighbour._closed and not neighbour._opened) then
				local nClearance = neighbour._clearance[finder._walkable]
				local pushThisNode = clearance and nClearance and (nClearance >= clearance)
				if (clearance and pushThisNode) or (not clearance) then			
					openList[#openList+1] = neighbour
					neighbour._opened = true
					neighbour._parent = node
					toClear[neighbour] = true
				end
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)

    local openList = {} -- We'll use a LIFO queue (simple array)
    openList[1] = startNode
    startNode._opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[#openList]
      t_remove(openList)
      node._closed = true
      if node == endNode then return node end
      depth_first_search(finder, openList, node, endNode, clearance, toClear)
    end

    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\dijkstra.lua ---

-- Dijkstra algorithm (Uses Astar implementation)

if (...) then

  local astar_search = require ((...):gsub('%.dijkstra$','.astar'))
  -- Dijkstra is similar to aStar, with no heuristic
  local dijkstraHeuristic = function() return 0 end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear)
    return astar_search(finder, startNode, endNode, clearance, toClear, dijkstraHeuristic)
  end

end


--- FILE: \lib\Jumper\jumper\search\jps.lua ---

-- Jump Point search algorithm

if (...) then

  -- Dependancies
  local _PATH = (...):match('(.+)%.search.jps$')
  local Heuristics = require (_PATH .. '.core.heuristics')
	local Heap = require (_PATH.. '.core.bheap')

  -- Internalization
  local max, abs = math.max, math.abs

  -- Local helpers, these routines will stay private
  -- As they are internally used by the public interface

  -- Resets properties of nodes expanded during a search
  -- This is a lot faster than resetting all nodes
  -- between consecutive pathfinding requests

  --[[
    Looks for the neighbours of a given node.
    Returns its natural neighbours plus forced neighbours when the given
    node has no parent (generally occurs with the starting node).
    Otherwise, based on the direction of move from the parent, returns
    neighbours while pruning directions which will lead to symmetric paths.

    In case diagonal moves are forbidden, when the given node has no
    parent, we return straight neighbours (up, down, left and right).
    Otherwise, we add left and right node (perpendicular to the direction
    of move) in the neighbours list.
  --]]
  local function findNeighbours(finder, node, clearance)

    if node._parent then
      local neighbours = {}
      local x,y = node._x, node._y
      -- Node have a parent, we will prune some neighbours
      -- Gets the direction of move
      local dx = (x-node._parent._x)/max(abs(x-node._parent._x),1)
      local dy = (y-node._parent._y)/max(abs(y-node._parent._y),1)

        -- Diagonal move case
      if dx~=0 and dy~=0 then
        local walkY, walkX

        -- Natural neighbours
        if finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+dy)
          walkY = true
        end
        if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y)
          walkX = true
        end
        if walkX or walkY then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y+dy)
        end

        -- Forced neighbours
        if (not finder._grid:isWalkableAt(x-dx,y,finder._walkable, clearance)) and walkY then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x-dx,y+dy)
        end
        if (not finder._grid:isWalkableAt(x,y-dy,finder._walkable, clearance)) and walkX then
          neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y-dy)
        end

      else
        -- Move along Y-axis case
        if dx==0 then
          local walkY
          if finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
            neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+dy)

            -- Forced neighbours are left and right ahead along Y
            if (not finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+1,y+dy)
            end
            if (not finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x-1,y+dy)
            end
          end
          -- In case diagonal moves are forbidden : Needs to be optimized
          if not finder._allowDiagonal then
            if finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+1,y)
            end
            if finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance)
              then neighbours[#neighbours+1] = finder._grid:getNodeAt(x-1,y)
            end
          end
        else
        -- Move along X-axis case
          if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) then
            neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y)

            -- Forced neighbours are up and down ahead along X
            if (not finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y+1)
            end
            if (not finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance)) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x+dx,y-1)
            end
          end
          -- : In case diagonal moves are forbidden
          if not finder._allowDiagonal then
            if finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y+1)
            end
            if finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance) then
              neighbours[#neighbours+1] = finder._grid:getNodeAt(x,y-1)
            end
          end
        end
      end
      return neighbours
    end

    -- Node do not have parent, we return all neighbouring nodes
    return finder._grid:getNeighbours(node, finder._walkable, finder._allowDiagonal, finder._tunnel, clearance)
  end

  --[[
    Searches for a jump point (or a turning point) in a specific direction.
    This is a generic translation of the algorithm 2 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf
    The current expanded node is a jump point if near a forced node

    In case diagonal moves are forbidden, when lateral nodes (perpendicular to
    the direction of moves are walkable, we force them to be turning points in other
    to perform a straight move.
  --]]
  local function jump(finder, node, parent, endNode, clearance)
	if not node then return end

    local x,y = node._x, node._y
    local dx, dy = x - parent._x,y - parent._y

    -- If the node to be examined is unwalkable, return nil
    if not finder._grid:isWalkableAt(x,y,finder._walkable, clearance) then return end
		
    -- If the node to be examined is the endNode, return this node
    if node == endNode then return node end
    -- Diagonal search case
    if dx~=0 and dy~=0 then
      -- Current node is a jump point if one of his leftside/rightside neighbours ahead is forced
      if (finder._grid:isWalkableAt(x-dx,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x-dx,y,finder._walkable, clearance))) or
         (finder._grid:isWalkableAt(x+dx,y-dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y-dy,finder._walkable, clearance))) then
        return node
      end
    else
      -- Search along X-axis case
      if dx~=0 then
        if finder._allowDiagonal then
          -- Current node is a jump point if one of his upside/downside neighbours is forced
          if (finder._grid:isWalkableAt(x+dx,y+1,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance))) or
             (finder._grid:isWalkableAt(x+dx,y-1,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance) or finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance) then return node end
        end
      else
      -- Search along Y-axis case
        -- Current node is a jump point if one of his leftside/rightside neighbours is forced
        if finder._allowDiagonal then
          if (finder._grid:isWalkableAt(x+1,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x+1,y,finder._walkable, clearance))) or
             (finder._grid:isWalkableAt(x-1,y+dy,finder._walkable, clearance) and (not finder._grid:isWalkableAt(x-1,y,finder._walkable, clearance))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder._grid:isWalkableAt(x,y+1,finder._walkable, clearance) or finder._grid:isWalkableAt(x,y-1,finder._walkable, clearance) then return node end
        end
      end
    end

    -- Recursive horizontal/vertical search
    if dx~=0 and dy~=0 then
      if jump(finder,finder._grid:getNodeAt(x+dx,y),node,endNode, clearance) then return node end
      if jump(finder,finder._grid:getNodeAt(x,y+dy),node,endNode, clearance) then return node end
    end

    -- Recursive diagonal search
    if finder._allowDiagonal then
      if finder._grid:isWalkableAt(x+dx,y,finder._walkable, clearance) or finder._grid:isWalkableAt(x,y+dy,finder._walkable, clearance) then
        return jump(finder,finder._grid:getNodeAt(x+dx,y+dy),node,endNode, clearance)
      end
    end
end

  --[[
    Searches for successors of a given node in the direction of each of its neighbours.
    This is a generic translation of the algorithm 1 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf

    Also, we notice that processing neighbours in a reverse order producing a natural
    looking path, as the pathfinder tends to keep heading in the same direction.
    In case a jump point was found, and this node happened to be diagonal to the
    node currently expanded in a straight mode search, we skip this jump point.
  --]]
  local function identifySuccessors(finder, openList, node, endNode, clearance, toClear)

    -- Gets the valid neighbours of the given node
    -- Looks for a jump point in the direction of each neighbour
    local neighbours = findNeighbours(finder,node, clearance)
    for i = #neighbours,1,-1 do

      local skip = false
      local neighbour = neighbours[i]
      local jumpNode = jump(finder,neighbour,node,endNode, clearance)
		
      -- : in case a diagonal jump point was found in straight mode, skip it.
      if jumpNode and not finder._allowDiagonal then
        if ((jumpNode._x ~= node._x) and (jumpNode._y ~= node._y)) then skip = true end
      end
		
      -- Performs regular A-star on a set of jump points
      if jumpNode and not skip then
        -- Update the jump node and move it in the closed list if it wasn't there
        if not jumpNode._closed then			
					local extraG = Heuristics.EUCLIDIAN(jumpNode, node)
					local newG = node._g + extraG
					if not jumpNode._opened or newG < jumpNode._g then
						toClear[jumpNode] = true -- Records this node to reset its properties later.
						jumpNode._g = newG
						jumpNode._h = jumpNode._h or
							(finder._heuristic(jumpNode, endNode))
						jumpNode._f = jumpNode._g+jumpNode._h
						jumpNode._parent = node
						if not jumpNode._opened then
							openList:push(jumpNode)
							jumpNode._opened = true
						else
							openList:heapify(jumpNode)
						end
					end					
				end
      end
    end
  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function(finder, startNode, endNode, clearance, toClear)

    startNode._g, startNode._f, startNode._h = 0,0,0
		local openList = Heap()
    openList:push(startNode)
    startNode._opened = true
    toClear[startNode] = true

    local node
    while not openList:empty() do
      -- Pops the lowest F-cost node, moves it in the closed list
      node = openList:pop()
      node._closed = true
        -- If the popped node is the endNode, return it
        if node == endNode then
          return node
        end
      -- otherwise, identify successors of the popped node
      identifySuccessors(finder, openList, node, endNode, clearance, toClear)
    end

    -- No path found, return nil
    return nil
  end

end


--- FILE: \lib\Jumper\jumper\search\thetastar.lua ---

-- ThetaStar implementation
-- See: http://aigamedev.com/open/tutorials/theta-star-any-angle-paths for reference

if (...) then
	
	local _PATH = (...):gsub('%.search.thetastar$','')

	-- Depandancies
	local Heuristics   = require (_PATH .. '.core.heuristics')
	local astar_search = require (_PATH .. '.search.astar')

	-- Internalization
	local ipairs = ipairs
	local huge, abs = math._huge, math.abs
	
	-- Line Of Sight (Bresenham's line marching algorithm)
	-- http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
	local lineOfSight = function (node, neighbour, finder, clearance)
		local x0, y0 = node._x, node._y
		local x1, y1 = neighbour._x, neighbour._y
		local dx = abs(x1-x0)
		local dy = abs(y1-y0)
		local err = dx - dy
		local sx = (x0 < x1) and 1 or -1
		local sy = (y0 < y1) and 1 or -1		

		while true do
			if not finder._grid:isWalkableAt(x0, y0, finder._walkable, finder._tunnel, clearance) then 
				return false 
			end
			if x0 == x1 and y0 == y1 then
				break
			end
			local e2 = 2*err
			if e2 > -dy then
				err = err - dy
				x0 = x0 + sx
			end
			if e2 < dx then
				err = err + dx
				y0 = y0 + sy
			end
		end
		return true
	end
	
	-- Theta star cost evaluation
	local function computeCost(node, neighbour, finder, clearance)
		local parent = node._parent or node
		local mpCost = Heuristics.EUCLIDIAN(neighbour, parent)
		if lineOfSight(parent, neighbour, finder, clearance) then
			if parent._g + mpCost < neighbour._g then
				neighbour._parent = parent
				neighbour._g = parent._g + mpCost
			end
		else
			local mCost = Heuristics.EUCLIDIAN(neighbour, node)
			if node._g + mCost < neighbour._g then
				neighbour._parent = node
				neighbour._g = node._g + mCost
			end
		end
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear, overrideHeuristic)
    return astar_search(finder, startNode, endNode, clearance, toClear, overrideHeuristic, computeCost)
	end

end


--- FILE: \lib\Jumper\specs\bheap_specs.lua ---

context('Module BHeap', function()	
	local BHeap 
	
	before(function()
		BHeap = require ('jumper.core.bheap')
	end)
	
	context('BHeap class', function()
	
		test('BHeap() instantiates a new heap object', function()
			assert_equal(getmetatable(BHeap()), BHeap)
		end)
		
		test('the new heap is empty', function()
			assert_true((BHeap()):empty())
		end)
		
		test('items can be pushed inside', function()
			local h = BHeap()
			h:push(1):push(2):push(3)
			assert_equal(h._size, 3)
		end)
		
		test('popping returns the lowest element by default (< operator)', function()
			local h = BHeap()
			h:push(1):push(2):push(0)
			
			assert_equal(h:pop(),0)
			assert_equal(h:pop(),1)
			assert_equal(h:pop(),2)
			assert_nil(h:pop())
		end)
		
		test('a heap can be cleared', function()
			local h = BHeap()
			assert_true(h:empty())
			
			h:push(1):push(2):push(3)
			assert_false(h:empty())
			
			h:clear()
			assert_true(h:empty())			
		end)
		
		test('one can define a custom sort function', function()
			local sort = function(a,b) return a>b end
			local h = BHeap(sort)
			h:push(1):push(2):push(3)
			
			assert_equal(h:pop(),3)
			assert_equal(h:pop(),2)
			assert_equal(h:pop(),1)
			assert_nil(h:pop())
		end)		

		test('items pushed can be objects, with a custom sort function', function()
			local sortNode = function(a, b) return a.cost < b.cost end
			local makeObj = function(cost) return {cost = cost} end
			local h = BHeap(sortNode)
			h:push(makeObj(1)):push(makeObj(2)):push(makeObj(3))
			
			assert_equal(h:pop().cost,1)
			assert_equal(h:pop().cost,2)
			assert_equal(h:pop().cost,3)
			assert_nil(h:pop())					
		end)
		
		test('pushing a alue that cannot be compared to the previous ones raises an error', function()
			local h = BHeap()
			h:push(false)
			assert_error(pcall(h.push, h, false))
			assert_error(pcall(h.push, h, true))		
			assert_error(pcall(h.push, h, {}))		
			assert_error(pcall(h.push, h, function() end))		
		end)
		
		test('pushing nil does nothing', function()
			local h = BHeap()
			h:push()
			
			assert_true(h:empty())
			h:push(1):push()
			
			assert_false(h:empty())
			assert_equal(h._size,1)
		end)
		
		test('popping an empty heap returns nil', function()
			local h = BHeap()
			assert_nil(h:pop())		
		end)
		
		test('BHeap:heapify() forces a sort of the heap', function()
		
			local h = BHeap()
			local sort = function(a,b) return a.value < b.value end
			local function makeObj(v) return {value = v} end
			local h = BHeap(sort)
			local A, B, C = makeObj(1), makeObj(2), makeObj(3)
			
			h:push(A):push(B):push(C)
			C.value = 0
			h:heapify(C)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,0)
			
			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,1)

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			h:push(A):push(B):push(C)
			C.value, B.value, A.value = 3, 2, 100
			h:heapify()

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,3)

			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,100)
		
		end)
		
		
	end)
	
end)


--- FILE: \lib\Jumper\specs\grid_specs.lua ---

context('Module Grid', function()
	local Grid, Node
	
	before(function()
		Grid = require ('jumper.grid')
		Node = require ('jumper.core.node')
  end)
	
  context('Grid:new() or Grid() returns a new Grid object', function()
		
		test('Grid:new() or Grid() returns a new Grid object', function()
			assert_equal(getmetatable(getmetatable(Grid:new({{0}}))),Grid)
			assert_equal(getmetatable(getmetatable(Grid({{0}}))),Grid)
		end)
			
		test('Grid:new() requires a collision map upon initialization', function()
			local map = {{0,0},{0,0}}
			assert_not_nil(Grid:new(map))
		end)
			
		test('The passed-in map can be a string', function()
			local map = '00\n00'
			assert_not_nil(Grid:new(map))
		end)
			
		test('passing nil to Grid:new() or Grid() causes an error', function()
			assert_error(pcall(Grid, Grid))
			assert_error(pcall(Grid.new, Grid))
		end)			
			
		test('Grid and map should have the same width', function()
			local map = '00\n00'
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map)
			assert_equal(grid:getWidth(), 2)
			assert_equal(grid2:getWidth(), 2)	
		end)	
		
		test('Grid and map should have the same height', function()
			local map = '00\n00\n00'
			local map2 = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map2)
			assert_equal(grid:getHeight(), 3)
			assert_equal(grid2:getHeight(), 4)	
		end)
		
		test('Grid:getBounds() returns the grid corners coordinates', function()
			local map = {{0,0,0},{0,0,0},{0,0,0},{0,0,0}}
			local grid = Grid(map)
			local lx,ly,rx,ry = grid:getBounds()
			assert_equal(lx,1)
			assert_equal(ly,1)
			assert_equal(rx,3)
			assert_equal(ry,4)
			
			local map = {}
			for y = 0,2 do map[y] = {}
				for x = 0,2 do map[y][x] = 0 end
			end
			grid = Grid(map)
			local lx,ly,rx,ry = grid:getBounds()
			assert_equal(lx,0)
			assert_equal(ly,0)
			assert_equal(rx,2)
			assert_equal(ry,2)			
		end)
		
		test('Each value on the map matches a node on the grid', function()
			local map = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			
			for y in pairs(map) do
				for x in pairs(map[y]) do
					local node = grid:getNodeAt(x,y)
					assert_not_nil(node)
					assert_equal(getmetatable(node), Node)
				end
			end
		end)
		
		test('the passed-in map should have a width greather than 0',function()
			assert_error(pcall(Grid, Grid, {{},{}}))
			assert_error(pcall(Grid, Grid, '\n\n'))
		end)

		test('the passed-in map should have a height greather than 0',function()
			assert_error(pcall(Grid, Grid, {}))
			assert_error(pcall(Grid, Grid, ''))
		end)
		
		test('the passed-in map should have rows with the same width',function()
			assert_error(pcall(Grid, Grid, {{0},{0,0}}))
			assert_error(pcall(Grid, Grid, '00\n000'))
		end)

		test('values in the map should only be integers or strings',function()
			assert_error(pcall(Grid, Grid, {{0.1,0,0},{0,0,0}}))
			assert_error(pcall(Grid, Grid, {{0,function() end,0},{0,0,0}}))
		end)
		
	end)
	
	context('Grid types', function()
		
		test('passing a 2nd arg to Grid:new() or Grid() returns a safe-memory grid', function()
			local grid = Grid({{0}})
			local pgrid = Grid({{0}},true)
			assert_not_equal(getmetatable(grid), getmetatable(pgrid))
			assert_equal(getmetatable(getmetatable(grid)), getmetatable(getmetatable(pgrid)))
		end)
		
		test('those grids are memory safe, as nodes are cached on purpose', function()
			local map = {{0,0,0},{0,0,0},{0,0,0}}
			local pgrid = Grid(map, true)
			
			assert_equal(#pgrid:getNodes(), 0)
			local count = 0
			for node in pgrid:iter() do
				assert_equal(getmetatable(node), Node)
				count = count+1
			end
			assert_equal(count, pgrid:getWidth()*pgrid:getHeight())
		end)
		
	end)
	
	context('Grid:isWalkablkeAt', function()
		
			test('returns whether or not a node is walkable',function()
				local map = {{0,0},{0,0},{0,1},{0,0}}
				local grid = Grid(map)			
				local walkable = 1
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						if map[y][x] == walkable then
							assert_true(grid:isWalkableAt(x,y,walkable))
						else
							assert_false(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
				map = 'WXW\nWWW\n'
				grid = Grid(map)			
				walkable = 'W'
				
				for y = 1,2 do
					for x = 1,3 do
						if x==2 and y==1 then
							assert_false(grid:isWalkableAt(x,y,walkable))
						else
							assert_true(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
			end)

			test('All nodes are walkable when no walkability rule was set', function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						assert_true(grid:isWalkableAt(x,y,walkable))
					end
				end
			end)
	
	end)
		
	context('Grid:getMap()', function()
		
			test('returns the collision map',function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				assert_equal(grid:getMap(), map)
			end)
		
			test('returns the array parsed from a given string',function()
				local map = '00\n00'
				local grid = Grid(map)
				assert_equal(type(grid:getMap()), 'table')
				assert_not_equal(grid:getMap(), map)
			end)
		
	end)
	
	context('Grid:getNodeAt()', function()
			local map, grid
			before(function()
				map = {
					{0,0,0,0},
					{0,0,0,0},
				}
				grid = Grid(map)
      end)
			
			test('returns the node at a given position', function()
				local node = grid:getNodeAt(1,1)
				assert_equal(getmetatable(node),Node)
				assert_equal(node._x,1)
				assert_equal(node._y,1)
			end)
			
			test('returns nil if the node does not exist', function()
				assert_nil(grid:getNodeAt(0,0))
				assert_nil(grid:getNodeAt(5,1))
			end)

			test('returns nil if one of its args is missing', function()
				assert_nil(grid:getNodeAt(0))
				assert_nil(grid:getNodeAt())
			end)			
		
	end)
		
	context('Grid:getNodes()', function()
	
		test('returns the array of nodes', function()
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local nodes = grid:getNodes()
			
			assert_equal(type(nodes), 'table')	
			for y in pairs(nodes) do
				for x in pairs(nodes[y]) do
					assert_equal(getmetatable(nodes[y][x]),Node)
				end
			end 
		end)
	
	end)
	
	context('grid:getNeighbours()', function()
		
			test('returns neighbours of a given node', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable = 0
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 2)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
			end)
			
			test('passing true as a third arg includes ajacent nodes', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable, allowDiag = 0, true
				
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable, allowDiag)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 3)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
				assert_equal(nb[3], grid:getNodeAt(2,2))
			end)

			test('passing arg tunnel includes adjacent nodes that cannot be reached diagonnally', function()
				local map = {{0,0,0},{1,0,0},{0,2,0}}
				local grid = Grid(map)
				local walkable, allowDiag, tunnel = 0, true, true
				
				local node = grid:getNodeAt(1,3)
				local nb = grid:getNeighbours(node, walkable, allowDiag, tunnel)
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 1)
				assert_equal(nb[1], grid:getNodeAt(2,2))				
			end)
			
	end)
		
	context('Grid:iter()', function()
			
			test('iterates on all nodes in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
			
			test('can iterate only on a rectangle of nodes', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter(2,2,3,3) do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])					
					assert_gte(n._x, 2)
					assert_gte(n._y, 2)
					assert_lte(n._x, 3)
					assert_lte(n._y, 3)
					assert_nil(record[n])
					record[n] = true
				end
			end)			
			
	end)
	
	context('Grid:around()', function()
			
			test('iterates on nodes following a square outline pattern', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(2,2),1) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)
			
			test('arg spacing defaults to 1 when not given', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(2,2)) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)

			test('skips unexisting nodes', function()
				local map = {
					{0,0,0},
					{0,0,0},
					{0,0,0}
				}
				local m = {{2,1},{2,2},{1,2}}
				local grid = Grid(map)
				local record = {}
				local i = 0
				for n in grid:around(Node(1,1)) do
					i = i + 1
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n._x, m[i][1])
					assert_equal(n._y, m[i][2])
					assert_nil(record[n])
					record[n] = true
				end
			end)				
		
	end)	
		
	context('Grid:each()', function()
			
			test('calls a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:each(f, 3)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n.value,3)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)
		
	context('Grid:eachRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:eachRange(1,1,2,2,f,3)
				for n in grid:iter() do
					if n._x <= 2 and n._y <= 2 then
						assert_equal(n.value,3)
					else
						assert_nil(n.value)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
		
	context('Grid:imap()', function()
			
			test('Maps a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imap(f, 5)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_equal(n.v,5)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)

	context('Grid:imapRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}				
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imapRange(3,3,4,4,f,7)
				for n in grid:iter() do
					if n._x >= 3 and n._y >= 3 then
						assert_equal(n.v,7)
					else
						assert_nil(n.v)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n._y] and map[n._y][n._x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
	
end)


--- FILE: \lib\Jumper\specs\heuristics_specs.lua ---

context('Module Heuristics', function()
	local H, Node
	
	before(function()
		H = require ('jumper.core.heuristics')
		Node = require ('jumper.core.node')
  end)
	
  context('MANHATTAN distance', function()
	
    test('is a function',function()
			assert_type(H.MANHATTAN, 'function')
    end)
	
		test('evaluates as |dx|+|dy|', function()
			assert_equal(H.MANHATTAN(Node(0,0), Node(0,0)), 0)
			assert_equal(H.MANHATTAN(Node(1,1), Node(1,3)), 2)
			assert_equal(H.MANHATTAN(Node(0,0), Node(2,1)), 3)
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.MANHATTAN,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.MANHATTAN))
		end)		
		
  end)

  context('EUCLIDIAN distance', function()
	
    test('is a function',function()
			assert_type(H.EUCLIDIAN, 'function')
    end)
	
		test('evaluates as SQUAREROOT(dx*dx + dy*dy)', function()
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(0,0)), 0)
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(2,2)), math.sqrt(8))
			assert_equal(H.EUCLIDIAN(Node(0,0), Node(5,3)), math.sqrt(34))		
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.EUCLIDIAN,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.EUCLIDIAN))
		end)		
		
  end)
  
	context('DIAGONAL distance', function()
	
    test('is a function',function()
			assert_type(H.DIAGONAL, 'function')
    end)
	
		test('evaluates as MAX(|dx|+|dy|)', function()
			assert_equal(H.DIAGONAL(Node(0,0), Node(0,0)), 0)
			assert_equal(H.DIAGONAL(Node(0,0), Node(2,2)), 2)
			assert_equal(H.DIAGONAL(Node(0,0), Node(1,2)), 2)
			assert_equal(H.DIAGONAL(Node(0,0), Node(3,1)), 3)	
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.DIAGONAL,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.DIAGONAL))
		end)		
		
  end)

	context('CARDINTCARD distance', function()
	
    test('is a function',function()
			assert_type(H.CARDINTCARD, 'function')
    end)
		
		test('evaluates as (SQRT(2)-1)*MIN(|dx|+|dy|)+MAX(|dx|+|dy|)', function()
			assert_equal(H.CARDINTCARD(Node(0,0), Node(0,0)), 0)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(1,1))-(math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(1,2))-(1+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(-3,1))-(2+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(Node(0,0), Node(2,2))-(2*math.sqrt(2)),1e-6)
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.CARDINTCARD,Node(0,0)))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.CARDINTCARD))
		end)		
		
  end)
	
end)


--- FILE: \lib\Jumper\specs\node_specs.lua ---

context('Module Node', function()
	local Node
	
	before(function()
		Node = require ('jumper.core.node')
  end)
	
  context('The Node Class', function()
	
    test('Node:new() or Node() returns a Node object',function()
			assert_equal(getmetatable(Node:new(0,0)),Node)
			assert_equal(getmetatable(Node(0,0)),Node)
    end)
	
		test('A Node has x and y attributes', function()
			local node = Node:new(1,3)
			assert_equal(node._x, 1)
			assert_equal(node._y, 3)
		end)
		
		test('x and y attributes can be retrieved through methods', function()
			local node = Node:new(5,6)
			assert_equal(node:getX(), 5)
			assert_equal(node:getY(), 6)
			
			local x, y = node:getPos()
			assert_equal(x, 5)
			assert_equal(y, 6)
		end)		
		
		test('Nodes can be compared, if they both have an F-cost', function()
		  local nodeA, nodeB = Node(1,2), Node(1,2)
			nodeA._f, nodeB._f = 1, 2
			assert_less_than(nodeA, nodeB)
			
			nodeA._f = 3
			assert_less_than(nodeB, nodeA)
		end)	
		
  end)

end)


--- FILE: \lib\Jumper\specs\pathfinder_specs.lua ---

context('Module Pathfinder', function()
	local PF, H, Grid, Path, map, grid
	
	before(function()
		PF = require ('jumper.pathfinder')
		Grid = require ('jumper.grid')
		H = require ('jumper.core.heuristics')
		Path = require ('jumper.core.path')
		map = {{0,0,0},{0,0,0},{0,0,0}}
		grid = Grid(map)
  end)
	
  context('Pathfinder:new() or Pathfinder()', function()
		
		test('Inits a new Pathfinder object', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR')), PF)
			assert_equal(getmetatable(PF:new(grid, 'ASTAR')), PF)
		end)
		
		test('First arg is a grid object', function()
			assert_error(pcall(PF, PF))
			assert_error(pcall(PF, PF, map))
			assert_equal(getmetatable(PF(grid)), PF)
		end)
		
		test('Second arg, when given must be a valid finderName', function()
			assert_error(pcall(PF, PF, grid, 'finder'))
			for i, finder in ipairs(PF:getFinders()) do
				assert_equal(getmetatable(PF(grid, finder)), PF)
			end
		end)
		
		test('Defaults to \'ASTAR\' when not given', function()
			local pf = PF(grid)
			assert_equal(getmetatable(pf), PF)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Third arg walkable can be a string, function, int or nil', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR', 'A')), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', function() end)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', 1)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', nil)), PF)
			assert_error(pcall(PF, PF, grid, 'ASTAR', 2.2))
			assert_error(pcall(PF, PF, grid, 'ASTAR', {}))
		end)
		
	end)
	
	context('Pathfinder:getGrid()', function()
		
		test('returns the grid object used by the Pathfinder', function()
			local pf = PF(grid)
			assert_equal(pf:getGrid(), grid)
		end)
		
	end)
	
	context('Pathfinder:setGrid()', function()
	
		test('Sets the grid object on which the Pathfinder performs', function()
			local pf = PF(grid)
			local newGrid = Grid('00000\n00000')
			
			assert_equal(pf:getGrid(), grid)
			pf:setGrid(newGrid)
			assert_equal(pf:getGrid(), newGrid)
		end)
		
		test('passing nil raises an error', function()
			local pf = PF(grid)
			assert_error(pcall(pf.setGrid, pf, nil))
		end)
		
	end)
	
	context('Pathfinder:getWalkable()', function()
	
		test('returns the walkable parameter', function()
			local pf = PF(grid, 'ASTAR', 1)
			assert_equal(pf:getWalkable(), 1)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
	end)
	
	context('Pathfinder:setWalkable()', function()
	
		test('sets the string, function, nil or int walkable value', function()
			local pf = PF(grid, 'ASTAR')
			assert_nil(pf:getWalkable())
			
			pf:setWalkable('A')
			assert_equal(pf:getWalkable(), 'A')
			
			pf:setWalkable(2)
			assert_equal(pf:getWalkable(), 2)
			
			local f = function() end
			pf:setWalkable(f)
			assert_equal(pf:getWalkable(), f)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
		test('raises an error when passed-in value is not a string, int, nil or function', function()
			local pf = PF(grid)			
			assert_error(pcall(pf.setWalkable, pf, {}))
			assert_error(pcall(pf.setWalkable, pf, 0.4))
		end)
		
	end)	
	
	context('Pathfinder:getFinder()', function()
		
		test('returns the finder name used', function()
			local pf = PF(grid, 'JPS')
			assert_equal(pf:getFinder(), 'JPS')
		end)
		
	end)
	
	context('Pathfinder:setFinder()', function()

		test('sets the finder to be used', function()
			local pf = PF(grid)
			pf:setFinder('DFS')
			assert_equal(pf:getFinder(), 'DFS')
		end)
		
		test('Upon init, the default finder, when not given, is \'ASTAR\'', function()
			local pf = PF(grid)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)

		test('Passing nil sets \'ASTAR\` as the finder if no previous finder was set, is \'ASTAR\'', function()
			local pf = PF(grid)
			pf:setFinder()
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Passing nil has no effect if a finder was set previously', function()
			local pf = PF(grid, 'JPS')
			pf:setFinder()
			assert_equal(pf:getFinder(), 'JPS')
		end)			
	
	end)
	
	context('Pathfinder:getFinders()', function()
		
		test('returns the list of all existing finders', function()
			local fs = PF:getFinders()
			local pf = PF(grid)
			
			assert_greater_than(#fs, 0)
			for i,finder in ipairs(fs) do
				pf:setFinder(finder)
				assert_equal(pf:getFinder(), finder)
			end
		end)
		
	end)
	
	context('Pathfinder:getHeuristic()', function()
		
		test('returns the heuristic function used', function()
			local pf = PF(grid)
			assert_not_nil(pf:getHeuristic())
		end)
		
		test('default heuristic is \'MANHATTAN\'', function()
			local pf = PF(grid)
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
	end)
	
	context('Pathfinder:setHeuristic()', function()
		
		test('sets the heuristic function to be used', function()
			local pf = PF(grid)
			pf:setHeuristic('MANHATTAN')
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
		test('handles custom heuristic functions', function()
			local pf = PF(grid)
			local f = function() end
			pf:setHeuristic(f)
			assert_equal(pf:getHeuristic(),f)
		end)
		
		test('passing nil produces an error',function()
			local pf = PF(grid)
			assert_error(pcall(pf.setHeuristic, pf))
		end)
		
	end)

	context('Pathfinder:getHeuristics()', function()
		
		test('returns all available heuristics', function()
			local hs = PF:getHeuristics()
			assert_greater_than(#hs, 0)
			local pf = PF(grid)
			for i, heur in ipairs(hs) do
				pf:setHeuristic(heur)
				assert_equal(pf:getHeuristic(), H[heur])
			end
		end)
		
	end)
	
	context('Pathfinder:getMode()', function()
	
		test('returns the actual search mode', function()
			local pf = PF(grid)
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(),'DIAGONAL')
		end)

		test('default search mode is  \'DIAGONAL\'', function()
			local pf = PF(grid)
			assert_equal(pf:getMode(),'DIAGONAL')
		end)
		
	end)
	
	context('Pathfinder:setMode()', function()
		
		test('sets the search mode', function()
			local pf = PF(grid)		
			pf:setMode('ORTHOGONAL')
			assert_equal(pf:getMode(), 'ORTHOGONAL')
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(), 'DIAGONAL')	
		end)
		
		test('passing nil or any other invalid arg causes an error', function()
			local pf = PF(grid)		
			
			assert_error(pcall(pf.setMode, pf))		
			assert_error(pcall(pf.setMode, pf, 'ORTHO'))		
			assert_error(pcall(pf.setMode, pf, function() end))	
		end)
		
	end)
	
	context('Pathfinder:getModes()', function()
		
		test('returns all available modes', function()
			local ms = PF:getModes()
			assert_equal(#ms, 2)
			local pf = PF(grid)
			
			for i, mode in ipairs(ms) do
				pf:setMode(mode)
				assert_equal(pf:getMode(),mode)
			end
		end)
		
	end)
		
	context('Pathfinder:setTunnelling()', function()
		
		test('Enables or disables tunnelling feature', function()
			PF:setTunnelling(true)
			assert_true(PF:getTunnelling())
			PF:setTunnelling(false)
			assert_false(PF:getTunnelling())
		end)
		
		test('Enables or disables tunnelling feature', function()
			PF:setTunnelling(true)
			assert_true(PF:getTunnelling())
			PF:setTunnelling(false)
			assert_false(PF:getTunnelling())
		end)
		
		test('When on, finder goes through walls heading diagonally', function()
			local map = {{0,0,0},{1,0,0},{0,2,0}}
			local grid = Grid(map)
			local finder = PF(grid, 'ASTAR',0)
			finder:setTunnelling(true)
			local path = finder:getPath(1,3,3,1)
			assert_equal(path._nodes[1]._x,1)
			assert_equal(path._nodes[1]._y,3)
			assert_equal(path._nodes[2]._x,2)
			assert_equal(path._nodes[2]._y,2)
			assert_equal(path._nodes[3]._x,3)
			assert_equal(path._nodes[3]._y,1)			
		end)
		
	end)
	
	context('Pathfinder:getTunnelling()', function()
		
		test('Returns the actual state of tunnelling feature', function()
			assert_false(PF:getTunnelling())
		end)
		
	end)

	context('Pathfinder:annotateGrid()', function()
		
		test('Calculates clearance for the entire grid', function()
			local map = {
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,1,0,0,0,0,0,0},
			{0,0,1,0,0,0,0,0,2,0},
			{0,0,1,1,1,0,0,2,0,0},
			{0,0,0,1,1,0,2,0,0,2},
			{0,0,0,0,1,0,0,0,0,2},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0}
		}
		local clearances = {
			{6,6,5,5,4,4,4,3,2,1},
			{6,5,5,4,4,3,3,3,2,1},
			{6,5,4,4,3,3,2,2,2,1},
			{6,5,4,3,3,2,2,1,1,1},
			{6,5,4,3,2,2,1,1,0,1},
			{5,5,4,3,2,1,1,0,1,1},
			{4,4,4,3,2,1,0,2,1,0},
			{3,3,3,3,3,3,3,2,1,0},
			{2,2,2,2,2,2,2,2,2,1},
			{1,1,1,1,1,1,1,1,1,1}
		}
		local grid = Grid(map)
		local walkable = function(v) return v~=2 end
		local finder = PF(grid, 'ASTAR', walkable)
		finder:annotateGrid()
		for node in grid:iter() do
			assert_equal(node:getClearance(walkable), clearances[node._y][node._x])
		end			
		end)
		
	end)

	context('Pathfinder:clearAnnotations()', function()
		
		test('Clears cached clearance values for the entire grid', function()
			local map = {{0,1,0},{0,0,0},{1,1,0}}
			local grid = Grid(map)
			local walkable = 0
			local finder = PF(grid, 'ASTAR', walkable)
			finder:annotateGrid()
			finder:clearAnnotations()
			for node in grid:iter() do
				assert_nil(node:getClearance(walkable))
			end			
		end)
		
	end)
	
	context('Pathfinder:getPath()', function()
		
		test('returns a path', function()
			local pf = PF(grid, 'ASTAR', 0)
			local path = pf:getPath(1,1,3,3)
			assert_equal(getmetatable(path), Path)
		end)
		
		test('start and end locations must exist on the map', function()
			local pf = PF(grid, 'ASTAR', 0)
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
			assert_error(pcall(pf.getPath, pf, 1, 1, 4, 4))
			assert_error(pcall(pf.getPath, pf, 0,0, 4, 4))
		end)
		
		test('goal location must be walkable', function()
			local pf = PF(grid, 'ASTAR', 0)
			map[3][3] = 1
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
		end)
		
	end)	
	
end)


--- FILE: \lib\Jumper\specs\path_specs.lua ---

context('Module Path', function()
	local Path, Node
	
	before(function()
		Path = require ('jumper.core.path')
		Node = require ('jumper.core.node')
  end)
	
  context('The Path Class', function()
	
    test('Path:new() or Path() returns a Path object',function()
			assert_equal(getmetatable(Path:new()),Path)
			assert_equal(getmetatable(Path()),Path)
    end)
		
    test('Path:iter() iterates on nodes forming the path',function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(getmetatable(node), Node)
				assert_equal(node._x, i)
				assert_equal(node._y, i)
				assert_equal(count, i)
			end
    end)		
		
		test('Path:iter() is aliased as Path:nodes()',function()
			assert_equal(Path.iter, Path.nodes)
		end)
		
		test('Path:getLength() returns the length of the path', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,0) end
			assert_equal(p:getLength(),9)
			
			p = Path()
			for j = 1,10 do p._nodes[#p._nodes+1] = Node(0,j) end
			assert_equal(p:getLength(),9)

			p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			assert_less_than(p:getLength()-9*math.sqrt(2),1e-6)			
		end)
		
		test('Path:fill() interpolates a path', function()
			local p = Path()
			for i = 1,9,2 do p._nodes[#p._nodes+1] = Node(i,i) end
			p._grid = {getNodeAt = function(self,x,y) return {_x = x, _y = y} end}
			p:fill()
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(node._x, i)
				assert_equal(node._y, i)
				assert_equal(count, i)
			end			
			
		end)
		
		test('Interpolation does not affect the total path length', function()
			local p = Path()
			for i = 1,10,3 do p._nodes[#p._nodes+1] = Node(i,i) end
			local len = p:getLength()
			p._grid = {getNodeAt = function(self,x,y) return {_x = x, _y = y} end}			
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		

		test('Path:filter() compresses a path', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			p:filter()
			
			assert_equal(p._nodes[1]._x,1)
			assert_equal(p._nodes[1]._y,1)
			assert_equal(p._nodes[2]._x,10)
			assert_equal(p._nodes[2]._y,10)
			for i = 3,10 do
				assert_nil(p._nodes[i])
			end
			
		end)

		test('Compression does not affect the total path length', function()
			local p = Path()
			for i = 1,10 do p._nodes[#p._nodes+1] = Node(i,i) end
			local len = p:getLength()
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		
		
  end)

end)


--- FILE: \src\main_game.lua ---

-- src/main_game.lua
local Gamestate = require "lib.hump.gamestate"

function love.load()
    Gamestate.registerEvents()
    Gamestate.switch(require("src.states.MenuState"))
end


--- FILE: \src\entities\Ally.lua ---

---Modulos
local Sprite = require("src.systems.Sprite")
local animation = require("src.systems.animation")

local allyTypes = {
    ["soldado"] = {
        speed = 50, health = 100, cost = 10, damage = 10, color = {0, 0.8, 0},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"1/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"1/Attack.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"1/Preattack.png", 48, 48, 1)
        -- )
    },
    ["tank"]    = {
        speed = 30, health = 300, cost = 30, damage = 25, color = {0.8, 0, 0},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"2/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"2/Attack.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"2/Preattack.png", 48, 48, 1)
        -- )
    },
    ["ninja"]   = {
        speed = 80, health = 70,  cost = 15, damage = 5,  color = {0, 0, 0.8},
        -- sprite = Sprite:newSprite(
        -- animation:newAnimation(spritePath+"3/Idle.png", 48, 48, 1),
        -- animation:newAnimation(spritePath+"3/Attack.png", 72, 48, 1),
        -- animation:newAnimation(spritePath+"3/Preattack.png", 48, 48, 1)
        -- )
    },
}

---Início do módulo de aliados
local Ally = {
}
Ally.__index = Ally

-- Define os tipos de aliados com seus atributos


-- Construtor do Ally
function Ally.create(type, x, y)
    local stats = allyTypes[type]
    assert(stats, "Tipo de aliado inválido: " .. tostring(type))

    local allySpritePath = string.format("assets/allies/defenders/%s/", type)
    local ally = {
        type = type,
        x = x,
        y = y,
        speed = stats.speed,
        health = stats.health,
        maxHealth = stats.health,
        damage = stats.damage,
        cost = stats.cost,
        color = stats.color,
        alive = true,
        attackCooldown = 1,  -- 1 segundo entre ataques
        timeSinceAttack = 0,
        sprite = Sprite:newSprite(
            animation:newAnimation(allySpritePath.."Idle.png", 48, 48, 1),
            animation:newAnimation(allySpritePath.."Attack.png", 48, 48, 1),
            animation:newAnimation(allySpritePath.."Preattack.png", 48, 48, 1),
            true
        ),
    }

    return setmetatable(ally, Ally)
end

-- Atualiza posição e ataque
function Ally:update(dt, enemies)
    if not self.alive then return end

    self.sprite:update(dt)
    self.timeSinceAttack = self.timeSinceAttack + dt

    -- Verifica se há inimigos próximos para atacar
    local attacked = false
    for _, enemy in ipairs(enemies) do
        if enemy.alive and math.abs(self.x - enemy.x) < 25 then
            -- Atacar se estiver perto o suficiente
            if self.timeSinceAttack >= self.attackCooldown then
                -- self.sprite:setState(Sprite.attack)
                enemy:takeDamage(self.damage)
                self.timeSinceAttack = 0
            end
            else
                self.sprite:setState(Sprite.attack)
                attacked = true
            break
        end
    end

    -- Se não atacou, continua andando
    if not attacked then
        self.x = self.x + self.speed * dt
        self.sprite:setState(Sprite.idle)
    end
end

-- Desenha aliado e barra de vida
function Ally:draw()
    if not self.alive then return end

    -- Corpo
    -- love.graphics.setColor(self.color)
    -- love.graphics.rectangle("fill", self.x, self.y, 20, 20)
    self.sprite:draw(self.x, self.y)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", self.x, self.y - 5, 20, 3)

    love.graphics.setColor(0, 1, 0)
    local lifeWidth = (self.health / self.maxHealth) * 20
    love.graphics.rectangle("fill", self.x, self.y - 5, lifeWidth, 3)

    -- Reset cor
    love.graphics.setColor(1, 1, 1)
end

-- Sofrer dano
function Ally:takeDamage(dmg)
    self.health = self.health - dmg
    if self.health <= 0 then
        self.alive = false
    end
end

-- Retorna o custo do tipo
function Ally.getCost(type)
    return type and allyTypes[type].cost or math.huge
end

return Ally


--- FILE: \src\entities\Enemy.lua ---

-- src/entities/Enemy.lua

-- 1. Importa a classe base Unit
local Unit = require("src.entities.Unit")

-- 2. Cria a classe Enemy e a faz herdar de Unit
local Enemy = {}
setmetatable(Enemy, {__index = Unit})
Enemy.__index = Enemy

-- Tabela de atributos com o valor da recompensa ('reward')
local enemyTypes = {
    ["soldado"] = { speed = 50, health = 100, cost = 10, damage = 10, color = {0.8, 0.5, 0}, reward = 5 },
    ["tank"]    = { speed = 30, health = 300, cost = 30, damage = 25, color = {0.5, 0.2, 0.2}, reward = 15 },
    ["ninja"]   = { speed = 80, health = 70,  cost = 15, damage = 5,  color = {0.3, 0.3, 0.3}, reward = 10 },
}

-- Construtor do Enemy
function Enemy.create(type, x, y)
    local stats = enemyTypes[type]
    assert(stats, "Tipo de inimigo inválido: " .. tostring(type))

    local config = {
        x = x, y = y,
        speed = stats.speed,
        health = stats.health,
        damage = stats.damage,
        cost = stats.cost,
        color = stats.color
    }

    local enemy = Unit:new(config)
    setmetatable(enemy, Enemy)
    enemy.type = type
    
    -- Garante que a recompensa seja armazenada na instância do inimigo
    enemy.reward = stats.reward or 0
    
    return enemy
end

-- Atualiza a lógica do Enemy
function Enemy:update(dt, allies, structure)
    if not self.alive then return end

    self.timeSinceAttack = self.timeSinceAttack + dt
    local attacked = false

    -- Prioridade 1: Atacar aliados próximos
    for _, ally in ipairs(allies) do
        if ally.alive and math.abs(self.x - ally.x) < 25 then
            if self.timeSinceAttack >= self.attackCooldown then
                ally:takeDamage(self.damage)
                self.timeSinceAttack = 0
            end
            attacked = true
            break
        end
    end

    -- Prioridade 2: Se não atacou um aliado, verifica se pode atacar a estrutura
    if not attacked and structure and structure.alive and math.abs(self.x - structure.x) < 40 then
        if self.timeSinceAttack >= self.attackCooldown then
            structure:takeDamage(self.damage)
            self.timeSinceAttack = 0
        end
        attacked = true
    end

    -- Se não atacou ninguém, continua andando para a esquerda
    if not attacked then
        self.x = self.x - self.speed * dt
    end
end

-- Função estática para obter o custo
function Enemy.getCost(type)
    return enemyTypes[type] and enemyTypes[type].cost or math.huge
end

-- ######################################################################
-- A LINHA MAIS IMPORTANTE DO ARQUIVO!
-- Garante que o 'require' receba a tabela 'Enemy' e não 'true'.
-- ######################################################################
return Enemy


--- FILE: \src\entities\Projectile.lua ---

-- Conceito para Projectile.lua
local Projectile = {}

function Projectile.create(x, y, target, damage)
    -- ...
    -- Calcula a velocidade em direção ao alvo
    local angle = math.atan2(target.y - y, target.x - x)
    proj.velocityX = math.cos(angle) * speed
    proj.velocityY = math.sin(angle) * speed
    -- ...
end

function Projectile:update(dt)
    self.x = self.x + self.velocityX * dt
    self.y = self.y + self.velocityY * dt
    -- Lógica de colisão com alvos
end


--- FILE: \src\entities\Structure.lua ---

-- Structure.lua
local Sprite = require("src.systems.Sprite")
local animation = require("src.systems.animation")

local Structure = {}
Structure.__index = Structure

-- Tipos de estruturas pré-definidas (pode expandir depois)
local StructureTypes = {
    ["base"] = { width = 32, height = 128, health = 200, cost = 50, attackDamage = 0, attackRange = 0, attackSpeed = 0, color = {1, 1, 1} },
    -- Você pode adicionar mais tipos aqui no futuro
}

-- Construtor
function Structure.create(type, x, y)
    local stats = StructureTypes[type]
    assert(stats, "Tipo de estrutura inválido: " .. tostring(type))

    local structurePath = "assets/allies/tower/"
    local structure = {
        type = type,
        x = x,
        y = y,
        width = stats.width,
        height = stats.height,
        health = stats.health,
        maxHealth = stats.health,
        cost = stats.cost,
        alive = true,
        attackDamage = stats.attackDamage,
        attackRange = stats.attackRange,
        attackSpeed = stats.attackSpeed,
        timeSinceLastAttack = 0,
        color = stats.color,
        sprite = Sprite:newSprite(
        animation:newAnimation(structurePath.."1.png", 70, 130, 1),
        animation:newAnimation(structurePath.."2.png", 70, 130, 1),
        animation:newAnimation(structurePath.."3.png", 70, 130, 1),
        true
    )
    }

    return setmetatable(structure, Structure)
end

-- Atualiza estrutura
function Structure:update(dt)
    if not self.alive then return end

    self.sprite:update(dt)

    if self.attackDamage > 0 and self.attackRange > 0 then
        self.timeSinceLastAttack = self.timeSinceLastAttack + dt
        if self.timeSinceLastAttack >= (1 / self.attackSpeed) then
            self:performAttack()
            self.timeSinceLastAttack = 0
        end
    end

    if self.health <= 0 then
        self.health = 0
        self.alive = false
        self:onDeath()
    end
end

-- Desenha estrutura e vida
function Structure:draw()
    if not self.alive then return end

    self.sprite:draw(self.x, self.y)

    -- Barra de vida
    local barWidth = 40
    local barHeight = 5
    local currentWidth = (self.health / self.maxHealth) * barWidth
    love.graphics.setColor(0.2, 0.2, 0.2, 0.8)
    love.graphics.rectangle("fill", self.x - barWidth / 2, self.y - 5 / 2 - 10, barWidth, barHeight)
    love.graphics.setColor(0, 1, 0)
    love.graphics.rectangle("fill", self.x - barWidth / 2, self.y - 5 / 2 - 10, currentWidth, barHeight)

    love.graphics.setColor(1, 1, 1) -- Reset cor
end

-- Recebe dano
function Structure:takeDamage(amount)
    if not self.alive then return end

    self.health = self.health - amount
    if self.health <= 0 then
        self.health = 0
        self.alive = false
        self:onDeath()
    end
end

-- Ataque (placeholder)
function Structure:performAttack()
    -- Implementação futura se quiser ataque automático
end

-- Ao morrer
function Structure:onDeath()
    print(self.type .. " at (" .. self.x .. ", " .. self.y .. ") has been destroyed!")
end

-- Custo
function Structure.getCost(type)
    return StructureTypes[type] and StructureTypes[type].cost or math.huge
end

return Structure


--- FILE: \src\entities\Unit.lua ---

-- src/entities/Unit.lua
local Unit = {}
Unit.__index = Unit

function Unit:new(config)
    local unit = {}
    
    unit.x = config.x or 0
    unit.y = config.y or 0
    unit.speed = config.speed or 50
    unit.health = config.health or 100
    unit.maxHealth = config.health or 100
    unit.damage = config.damage or 10
    unit.cost = config.cost or 0
    unit.color = config.color or {1, 1, 1}
    unit.alive = true
    unit.attackCooldown = 1
    unit.timeSinceAttack = 0

    return setmetatable(unit, self)
end

function Unit:takeDamage(dmg)
    self.health = self.health - dmg
    if self.health <= 0 then
        self.health = 0
        self.alive = false
    end
end

function Unit:draw()
    if not self.alive then return end

    -- Corpo
    love.graphics.setColor(self.color)
    love.graphics.rectangle("fill", self.x, self.y, 20, 20)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", self.x, self.y - 5, 20, 3)

    love.graphics.setColor(0, 1, 0)
    local lifeWidth = (self.health / self.maxHealth) * 20
    love.graphics.rectangle("fill", self.x, self.y - 5, lifeWidth, 3)

    love.graphics.setColor(1, 1, 1)
end

-- Outras funções que são comuns a Ally e Enemy podem vir aqui.

return Unit


--- FILE: \src\states\BaseState.lua ---



--- FILE: \src\states\GameOverState.lua ---

local Gamestate = require "lib.hump.gamestate"

local gameover = {}

function gameover:load()
end

function gameover:draw()
    love.graphics.printf("GAME OVER - Pressione Espaço para Voltar ao Menu", 0, 300, love.graphics.getWidth(), "center")
end

function gameover:keypressed(key)
    if key == "space" then
        Gamestate.switch(require("src.states.MenuState"))
    end
end

return gameover


--- FILE: \src\states\MenuState.lua ---

local Gamestate = require "lib.hump.gamestate"
local menu = {}
menu.__index = menu


function menu:loadAssets()
    Background = love.graphics.newImage("assets/background/menu_1.png")
end

function menu:load()
    menu:loadAssets()
    return menu
end

function menu:draw()
    love.graphics.draw(Background, 0, 0)
    love.graphics.printf("MENU - Pressione Enter para Jogar", 0, 300, love.graphics.getWidth(), "center")
end

function menu:keypressed(key)
    if key == "return" then
        Gamestate.switch(require("src.states.PlayState"):load())
    end
end

return menu:load()


--- FILE: \src\states\PlayState.lua ---

-- src/states/PlayState.lua
local Gamestate = require "lib.hump.gamestate"

local Ally = require("src.entities.Ally")
local Enemy = require("src.entities.Enemy")
local Structure = require("src.entities.Structure")
local Button = require("src.ui.Button")

local PlayState = {}
PlayState.__index = PlayState

-- ############### NOVA FUNÇÃO AUXILIAR ###############
-- Esta função cria/recria os botões do painel de upgrade.
-- Ela será chamada apenas quando precisarmos atualizar a UI dos upgrades.
function PlayState:rebuildUpgradeUI()
    self.uiUpgradeElements = {} -- Limpa a lista antiga
    if not self.isUpgradePanelOpen then return end -- Se o painel está fechado, não faz nada

    local yPos = 120
    for key, upgrade in pairs(self.upgrades) do
        local cost = math.floor(upgrade.baseCost * (upgrade.costMultiplier ^ upgrade.level))
        local text = upgrade.name .. " (Lvl " .. upgrade.level .. ")\nCusto: $" .. cost
        
        local currentKey = key
        local btn = Button.create(200, yPos, love.graphics.getWidth() - 400, 60, text, function()
            self:purchaseUpgrade(currentKey)
        end)
        
        table.insert(self.uiUpgradeElements, btn)
        yPos = yPos + 80
    end
end
-- ######################################################

function PlayState:load()
    local state = {
        allies = {},
        enemies = {},
        structures = {},
        uiSpawnElements = {},
        uiUpgradeElements = {}, -- Começa vazia
        isUpgradePanelOpen = false,
        money = 150,
        enemySpawnTimer = 0,
        enemySpawnInterval = 5
    }
    setmetatable(state, PlayState)

    state.upgrades = {
        soldierDamage = { name = "Dano Soldado", level = 0, baseCost = 50, costMultiplier = 1.6, value = 5 },
        income = { name = "Renda Passiva", level = 0, baseCost = 100, costMultiplier = 2, value = 2 },
        baseHealth = { name = "Vida da Base", level = 0, baseCost = 75, costMultiplier = 1.8, value = 250 }
    }

    local playerStructure = Structure.create("base", 80, love.graphics.getHeight() - 198)
    table.insert(state.structures, playerStructure)

    local function spawnAlly(allyType)
        local bonusDamage = state.upgrades.soldierDamage.level * state.upgrades.soldierDamage.value
        local bonusHealth = 0
        local allyCost = Ally.getCost(allyType)
        if state.money >= allyCost then
            table.insert(state.allies, Ally.create(allyType, 120, love.graphics.getHeight() - 100, bonusDamage, bonusHealth))
            state.money = state.money - allyCost
        end
    end

    table.insert(state.uiSpawnElements, Button.create(10, 100, 120, 40, "Soldado", function() spawnAlly("soldado") end))
    table.insert(state.uiSpawnElements, Button.create(10, 150, 120, 40, "Tank", function() spawnAlly("tank") end))
    table.insert(state.uiSpawnElements, Button.create(10, 200, 120, 40, "Ninja", function() spawnAlly("ninja") end))
    
    -- ############### MUDANÇA NA LÓGICA DO BOTÃO ###############
    -- Agora, além de mudar a flag, ele chama a função para construir a UI.
    table.insert(state.uiSpawnElements, Button.create(10, 280, 120, 50, "UPGRADES", function()
        state.isUpgradePanelOpen = not state.isUpgradePanelOpen
        state:rebuildUpgradeUI()
    end))

    return state
end

function PlayState:purchaseUpgrade(upgradeType)
    local upgrade = self.upgrades[upgradeType]
    if not upgrade then return end
    local cost = math.floor(upgrade.baseCost * (upgrade.costMultiplier ^ upgrade.level))

    if self.money >= cost then
        self.money = self.money - cost
        upgrade.level = upgrade.level + 1

        if upgradeType == "baseHealth" then
            local structure = self.structures[1]
            structure.maxHealth = structure.maxHealth + upgrade.value
            structure.health = structure.health + upgrade.value
        end
        print("Upgrade '" .. upgrade.name .. "' comprado! Nível: " .. upgrade.level)
        
        -- ############### ATUALIZA A UI APÓS A COMPRA ###############
        self:rebuildUpgradeUI()
    else
        print("Dinheiro insuficiente para o upgrade: " .. upgrade.name)
    end
end

function PlayState:update(dt)
    -- print("No início do update, o tipo de Enemy é: " .. type(Enemy)) -- <<< ADICIONE ESTA LINHA

    local playerStructure = self.structures[1]
    if not playerStructure.alive then
        Gamestate.switch(require("src.states.GameOverState"))
        return
    end

    if not self.isUpgradePanelOpen then
        playerStructure:update(dt)

        -- Atualiza aliados
        for i = #self.allies, 1, -1 do
            local ally = self.allies[i]
            ally:update(dt, self.enemies)
            if not ally.alive or ally.x > love.graphics.getWidth() then
                table.remove(self.allies, i)
            end
        end

        -- Atualiza inimigos
        for i = #self.enemies, 1, -1 do
            local enemy = self.enemies[i] -- Note o 'e' minúsculo, que é o correto.
            enemy:update(dt, self.allies, playerStructure)

            -- Verifica se o inimigo morreu ou saiu da tela
            if not enemy.alive or enemy.x < 0 then
                -- Se o inimigo foi derrotado (e não apenas saiu da tela), dá a recompensa.
                if not enemy.alive then
                    self.money = self.money + (enemy.reward or 0)
                end
                -- Remove o inimigo do jogo
                table.remove(self.enemies, i)
            end
        end

        -- Lógica de economia e spawn
        local incomeValue = 5 + (self.upgrades.income.level * self.upgrades.income.value)
        self.money = self.money + incomeValue * dt
        
        self.enemySpawnTimer = self.enemySpawnTimer + dt
        if self.enemySpawnTimer >= self.enemySpawnInterval then
            self:spawnEnemy()
            self.enemySpawnTimer = 0
        end
    end
    
    -- Atualiza UI
    for _, element in ipairs(self.uiSpawnElements) do element:update(dt) end
    if self.isUpgradePanelOpen then
        for _, element in ipairs(self.uiUpgradeElements) do element:update(dt) end
    end
end

function PlayState:draw()
    love.graphics.clear(0.4, 0.5, 0.6)

    for _, s in ipairs(self.structures) do s:draw() end
    for _, a in ipairs(self.allies) do a:draw() end
    for _, e in ipairs(self.enemies) do e:draw() end

    local incomeValue = 5 + (self.upgrades.income.level * self.upgrades.income.value)
    love.graphics.print("Dinheiro: $" .. math.floor(self.money), 10, 10)
    love.graphics.print("Renda: $" .. incomeValue .. "/s", 10, 30)
    for _, element in ipairs(self.uiSpawnElements) do element:draw() end
    
    -- ############### FUNÇÃO DRAW SIMPLIFICADA ###############
    -- Agora ela apenas desenha, sem criar nada.
    if self.isUpgradePanelOpen then
        love.graphics.setColor(0, 0, 0, 0.7)
        love.graphics.rectangle("fill", 150, 50, love.graphics.getWidth() - 300, love.graphics.getHeight() - 100)
        love.graphics.setColor(1, 1, 1)
        love.graphics.printf("Painel de Upgrades", 150, 60, love.graphics.getWidth() - 300, "center")
        
        for _, element in ipairs(self.uiUpgradeElements) do element:draw() end
    end

    love.graphics.setColor(1, 1, 1)
end

function PlayState:mousepressed(x, y, button)
    if button ~= 1 then return end

    if self.isUpgradePanelOpen then
        for _, element in ipairs(self.uiUpgradeElements) do element:mousepressed(x, y, button) end
    end
    for _, element in ipairs(self.uiSpawnElements) do element:mousepressed(x, y, button) end
end

function PlayState:keypressed(key)
    if key == "escape" then
        Gamestate.switch(require("src.states.MenuState"))
    end
end

function PlayState:spawnEnemy()
    print("No início do spawnEnemy, o tipo de Enemy é: " .. type(Enemy)) -- <<< ADICIONE ESTA LINHA

    local enemyTypes = {"soldado", "tank", "ninja"}
    local randomType = enemyTypes[love.math.random(#enemyTypes)]
    local x = love.graphics.getWidth() + 20
    local y = love.graphics.getHeight() - 100
    
    -- Esta linha usa 'Enemy' (maiúsculo), que é a referência correta ao módulo.
    table.insert(self.enemies, Enemy.create(randomType, x, y))
end

return PlayState


--- FILE: \src\systems\animation.lua ---

---@class Animation
---@field spriteSheet love.Image
---@field quads table
---@field duration number
---@field currentTime number
local Animation = {}
Animation.__index = Animation


---@param imagePath string
---@param width integer
---@param height integer
---@param duration integer
---@return Animation obj
function Animation:newAnimation(imagePath, width, height, duration)
    local image = love.graphics.newImage(imagePath)
    local obj = {
        spriteSheet = image,
        quads = {}
    }
    setmetatable(obj, Animation)
    for y = 0, image:getHeight() - height, height do
        for x = 0, image:getWidth() - width, width do
            table.insert(obj.quads, love.graphics.newQuad(x, y, width, height, image:getDimensions()))
        end
    end

    obj.duration = duration or 1
    obj.currentTime = 0
    return obj
end

function Animation:_draw(x, y, flipped)
    local spriteNum = math.floor(self.currentTime / self.duration * #self.quads) + 1
    if spriteNum > #self.quads then spriteNum = #self.quads end
    local quad = self.quads[spriteNum]
    local sx = flipped and -1 or 1
    local ox = 0
    if flipped then
        local _, _, w, _ = quad:getViewport()
        ox = w
    end
    love.graphics.draw(self.spriteSheet, quad, x + ox, y, 0, sx, 1)
end


function Animation:_update(dt)
    self.currentTime = self.currentTime + dt
    if self.currentTime >= self.duration then
        self.currentTime = self.currentTime - self.duration
    end
end

function Animation:reset() self.currentTime = 0 end

return Animation


--- FILE: \src\systems\CollisionHandler.lua ---



--- FILE: \src\systems\Sprite.lua ---

---@class Sprite
---@field currentState number
---@field flipped boolean
local Sprite = {
    idle = 1, attack = 2, preAttack = 3
}
Sprite.__index = Sprite


---@param idle Animation
---@param attack Animation
---@param preAttack Animation
---@param flipped boolean
---@return Sprite
function Sprite:newSprite(idle, attack, preAttack, flipped)
    local obj = {
        idle,
        attack,
        preAttack,
        currentState = Sprite.idle,
        flipped = flipped
    }
    setmetatable(obj, Sprite)
    return obj
end

---@param state integer
function Sprite:setState(state)
    if self.currentState ~= state then
        self[self.currentState]:reset()
        self.currentState = state
    end
end

function Sprite:draw(x, y)
    self[self.currentState]:_draw(x, y, self.flipped)
end

function Sprite:update(dt)
    self[self.currentState]:_update(dt)
end

return Sprite


--- FILE: \src\systems\WaveManager.lua ---

-- Conceito para WaveManager.lua
local WaveManager = {}
-- ... (código do construtor)

function WaveManager:update(dt, enemies)
    if self.waveInProgress then
        -- Lógica de spawnar inimigos da wave atual
    elseif #enemies == 0 then
        -- Todos os inimigos morreram, inicia timer para próxima wave
        self.timer = self.timer + dt
        if self.timer > self.timeBetweenWaves then
            self:startNextWave()
        end
    end
end

function WaveManager:startNextWave()
    self.waveNumber = self.waveNumber + 1
    -- Aumenta a dificuldade: mais inimigos, inimigos mais fortes, etc.
end


--- FILE: \src\ui\Button.lua ---

-- src/ui/Button.lua
local Button = {}
Button.__index = Button

function Button.create(x, y, width, height, text, onClick)
    local btn = {
        x = x, y = y,
        width = width, height = height,
        text = text or "",
        onClick = onClick or function() end,
        isHovered = false
    }
    return setmetatable(btn, Button)
end

function Button:update(dt)
    local mx, my = love.mouse.getPosition()
    self.isHovered = mx > self.x and mx < self.x + self.width and
                     my > self.y and my < self.y + self.height
end

function Button:draw()
    if self.isHovered then
        love.graphics.setColor(0.5, 0.5, 0.5) -- Cinza quando hover
    else
        love.graphics.setColor(0.3, 0.3, 0.3) -- Cinza escuro normal
    end
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    
    love.graphics.setColor(1, 1, 1)
    love.graphics.printf(self.text, self.x, self.y + self.height / 4, self.width, "center")
end

function Button:mousepressed(x, y, button)
    if button == 1 and self.isHovered then
        self.onClick()
    end
end

return Button


--- FILE: \src\ui\Shop.lua ---



--- FILE: \src\utils\math.lua ---



